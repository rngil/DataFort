var tipuesearch = {"pages":[{"title":" DataFort ","text":"DataFort DataFort DataFort is a dataframes library for Fortran, providing pandas-like functionality for scientific computing and data analysis. ⚠️ Warning: Project is very much a WIP. Use at your own risk. Installation Using fpm [dependencies] DataFort = { git = \"https://github.com/rngil/DataFort\" } Manual git clone https://github.com/rngil/DataFort cd DataFort\n./run_all_tests.sh # Run test suite Quick Start program example use datafort use precision implicit none type ( data_frame ) :: df real ( rk ), dimension ( 3 ) :: temps = [ 2 3.1_rk , 2 5.3_rk , 2 4.8_rk ] integer ( ik ), dimension ( 3 ) :: pressures = [ 1013_ik , 1015_ik , 1012_ik ] ! Create and populate call df % new () call df % append ( temps , \"Temperature\" ) call df % append ( pressures , \"Pressure\" ) ! Display call df % write_console () ! Statistics print * , \"Mean temperature:\" , df % mean_real ( 1 ) ! Export call df % write_csv ( \"data.csv\" ) ! Cleanup call df % destroy () end program example Development make help # Show all available commands make build # Build the library make test # Run all tests make docs # Generate documentation make format # Format code make clean # Clean build artifacts Acknowledgments DataFort is built upon the initial work from fortranDF by Joshua Aiken. While the project has been significantly extended and refactored with new features, the original skeleton provided a valuable foundation. Developer Info Renee Gil","tags":"home","url":"index.html"},{"title":"column – DataFort ","text":"type, public :: column Components Type Visibility Attributes Name Initial complex(kind=rk), private, dimension(:), allocatable :: ccol character(len=:), private, dimension(:), allocatable :: charcol integer, public :: dtype = 0 integer(kind=ik), private, dimension(:), allocatable :: icol logical, private :: initialized = .false. logical, private, dimension(:), allocatable :: lcol integer, public :: n real(kind=rk), private, dimension(:), allocatable :: rcol Type-Bound Procedures procedure, public :: changec => change_col_complex private  subroutine change_col_complex (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i complex(kind=rk), intent(in) :: val procedure, public :: changech => change_col_character private  subroutine change_col_character (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i character(len=*), intent(in) :: val procedure, public :: changei => change_col_integer private  subroutine change_col_integer (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i integer(kind=ik), intent(in) :: val procedure, public :: changel => change_col_logical private  subroutine change_col_logical (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i logical, intent(in) :: val procedure, public :: changer => change_col_real private  subroutine change_col_real (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i real(kind=rk), intent(in) :: val procedure, private :: col_constructor_character private  subroutine col_constructor_character (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: dcol procedure, private :: col_constructor_complex private  subroutine col_constructor_complex (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: dcol procedure, private :: col_constructor_integer private  subroutine col_constructor_integer (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: dcol procedure, private :: col_constructor_logical private  subroutine col_constructor_logical (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this logical, intent(in), dimension(:) :: dcol procedure, private :: col_constructor_real private  subroutine col_constructor_real (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: dcol procedure, public :: destroy => col_destructor private  subroutine col_destructor (this) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this procedure, public :: emptyc => col_constructor_alloc_complex private  subroutine col_constructor_alloc_complex (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n procedure, public :: emptych => col_constructor_alloc_character private  subroutine col_constructor_alloc_character (this, n, len) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n integer, intent(in), optional :: len procedure, public :: emptyi => col_constructor_alloc_integer private  subroutine col_constructor_alloc_integer (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n procedure, public :: emptyl => col_constructor_alloc_logical private  subroutine col_constructor_alloc_logical (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n procedure, public :: emptyr => col_constructor_alloc_real private  subroutine col_constructor_alloc_real (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n procedure, private :: get_from_col_character private pure function get_from_col_character (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value character(len=:), dimension(:), allocatable procedure, private :: get_from_col_complex private pure function get_from_col_complex (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value complex(kind=rk), dimension(this%n) procedure, private :: get_from_col_integer private pure function get_from_col_integer (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer(kind=ik), dimension(this%n) procedure, private :: get_from_col_logical private pure function get_from_col_logical (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value logical, dimension(this%n) procedure, private :: get_from_col_real private pure function get_from_col_real (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value real(kind=rk), dimension(this%n) procedure, private :: get_single_col_character private pure function get_single_col_character (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value character(len=:), allocatable procedure, private :: get_single_col_complex private pure function get_single_col_complex (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value complex(kind=rk) procedure, private :: get_single_col_integer private pure function get_single_col_integer (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value integer(kind=ik) procedure, private :: get_single_col_logical private pure function get_single_col_logical (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value logical procedure, private :: get_single_col_real private pure function get_single_col_real (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) procedure, public :: get_type => get_from_col_dtype private pure function get_from_col_dtype (this) result(dtype) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer generic, public :: getc => get_from_col_complex , get_single_col_complex private pure function get_from_col_complex (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value complex(kind=rk), dimension(this%n) private pure function get_single_col_complex (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value complex(kind=rk) generic, public :: getch => get_from_col_character , get_single_col_character private pure function get_from_col_character (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value character(len=:), dimension(:), allocatable private pure function get_single_col_character (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value character(len=:), allocatable generic, public :: geti => get_from_col_integer , get_single_col_integer private pure function get_from_col_integer (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer(kind=ik), dimension(this%n) private pure function get_single_col_integer (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value integer(kind=ik) generic, public :: getl => get_from_col_logical , get_single_col_logical private pure function get_from_col_logical (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value logical, dimension(this%n) private pure function get_single_col_logical (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value logical generic, public :: getr => get_from_col_real , get_single_col_real private pure function get_from_col_real (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value real(kind=rk), dimension(this%n) private pure function get_single_col_real (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) generic, public :: new => col_constructor_real , col_constructor_integer , col_constructor_logical , col_constructor_character , col_constructor_complex private  subroutine col_constructor_real (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: dcol private  subroutine col_constructor_integer (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: dcol private  subroutine col_constructor_logical (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this logical, intent(in), dimension(:) :: dcol private  subroutine col_constructor_character (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: dcol private  subroutine col_constructor_complex (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: dcol Source Code type :: column private integer , public :: dtype = 0 ! no type integer , public :: n ! elements in column ! arrays to hold data ! only one (associated with dtype) will ever be allocated real ( rk ), dimension (:), allocatable :: rcol integer ( ik ), dimension (:), allocatable :: icol logical , dimension (:), allocatable :: lcol character ( len = :), dimension (:), allocatable :: charcol complex ( rk ), dimension (:), allocatable :: ccol logical :: initialized = . false . contains private ! empty constructors procedure , public :: emptyr => col_constructor_alloc_real procedure , public :: emptyi => col_constructor_alloc_integer procedure , public :: emptyl => col_constructor_alloc_logical procedure , public :: emptych => col_constructor_alloc_character procedure , public :: emptyc => col_constructor_alloc_complex ! constructor/setter combo procedure :: col_constructor_real , & col_constructor_integer , & col_constructor_logical , & col_constructor_character , & col_constructor_complex generic , public :: new => col_constructor_real , & col_constructor_integer , & col_constructor_logical , & col_constructor_character , & col_constructor_complex ! destructor procedure , public :: destroy => col_destructor ! get data type procedure , public :: get_type => get_from_col_dtype ! get either whole column as array or single value procedure :: get_from_col_real , & get_from_col_integer , & get_from_col_logical , & get_from_col_character , & get_from_col_complex procedure :: get_single_col_real , & get_single_col_integer , & get_single_col_logical , & get_single_col_character , & get_single_col_complex generic , public :: getr => get_from_col_real , get_single_col_real generic , public :: geti => get_from_col_integer , get_single_col_integer generic , public :: getl => get_from_col_logical , get_single_col_logical generic , public :: getch => get_from_col_character , get_single_col_character generic , public :: getc => get_from_col_complex , get_single_col_complex ! Give element new value (setter) procedure , public :: changer => change_col_real procedure , public :: changei => change_col_integer procedure , public :: changel => change_col_logical procedure , public :: changech => change_col_character procedure , public :: changec => change_col_complex end type column","tags":"","url":"type/column.html"},{"title":"data_frame – DataFort ","text":"type, public :: data_frame Main data frame type for storing heterogeneous tabular data A data frame consists of columns of potentially different types,\nsimilar to a spreadsheet or database table. Each column must have\nthe same number of rows. Type-bound Procedures Constructor/Destructor new([char_len]) - Initialize data frame destroy() - Free memory Data Manipulation append(column, [header]) - Add column (generic for all types) getr/geti/getl/getch/getc(index) - Get column by type select_columns(indices) - Extract subset of columns slice_rows(start, end) - Extract row range filter_rows_*() - Filter by condition sort_by_column(col) - Sort by column values Statistical Functions mean_*/std_*/median_*() - Statistical measures sum_*/min_*/max_*() - Aggregate functions correlation_real() - Pearson correlation Join Operations inner_join/left_join/right_join/outer_join() - SQL-style joins I/O write_csv(filename) - Export to CSV read_csv(filename) - Import from CSV write_console() - Display in terminal Components Type Visibility Attributes Name Initial type( column ), private, dimension(:), allocatable :: data_cols character(len=:), private, dimension(:), allocatable :: headers logical, private :: initialized = .false. integer, private :: max_char_len = MAX_CHAR_LEN_DEFAULT integer, private :: num_cols = 0 logical, private :: with_headers = .false. Type-Bound Procedures procedure, public :: abs_column_integer private  subroutine abs_column_integer (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index procedure, public :: abs_column_real private  subroutine abs_column_real (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index procedure, private :: add_col_character private  subroutine add_col_character (this, col, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header procedure, private :: add_col_complex private  subroutine add_col_complex (this, col, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header procedure, private :: add_col_integer private  subroutine add_col_integer (this, col, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header procedure, private :: add_col_logical private  subroutine add_col_logical (this, col, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this logical, intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header procedure, private :: add_col_real private  subroutine add_col_real (this, col, header) Append a real-valued column to the data frame Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header procedure, private :: already_header private  function already_header (this, header) result(exists) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value logical generic, public :: append => add_col_real , add_col_integer , add_col_logical , add_col_character , add_col_complex private  subroutine add_col_real (this, col, header) Append a real-valued column to the data frame Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header private  subroutine add_col_integer (this, col, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header private  subroutine add_col_logical (this, col, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this logical, intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header private  subroutine add_col_character (this, col, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header private  subroutine add_col_complex (this, col, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header procedure, public :: apply_to_all_rows_real private  function apply_to_all_rows_real (this, func) result(outputs) Apply a function to all rows Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this procedure( row_func_real ) :: func Return Value real(kind=rk), dimension(:), allocatable procedure, public :: apply_to_row_real private  function apply_to_row_real (this, row_idx, func) result(output) Apply a function to a single row Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: row_idx procedure( row_func_real ) :: func Return Value real(kind=rk) procedure, public :: clear private  subroutine clear (this) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this procedure, public :: clip_integer private  subroutine clip_integer (this, col_index, min_val, max_val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in) :: min_val integer(kind=ik), intent(in) :: max_val procedure, public :: clip_real private  subroutine clip_real (this, col_index, min_val, max_val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: min_val real(kind=rk), intent(in) :: max_val procedure, public :: concat private  function concat (this, other, axis) result(result_df) Concatenate two dataframes vertically (rows) or horizontally (columns) Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: axis Return Value type( data_frame ) procedure, public :: copy private  function copy (this) result(new_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value type( data_frame ) procedure, public :: correlation_real private  function correlation_real (this, col_index1, col_index2) result(corr) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index1 integer, intent(in) :: col_index2 Return Value real(kind=rk) procedure, public :: cumsum_integer private  subroutine cumsum_integer (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index procedure, public :: cumsum_real private  subroutine cumsum_real (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index procedure, public :: describe_numeric private  subroutine describe_numeric (this, unit) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: unit procedure, public :: destroy => df_destructor private  subroutine df_destructor (this) Destroy a data frame and free all memory Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this procedure, private :: df_get_col_type_header private pure function df_get_col_type_header (this, header) result(dtype) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer procedure, private :: df_get_col_type_index private pure function df_get_col_type_index (this, index) result(dtype) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value integer procedure, public :: diff_integer private  function diff_integer (this, col_index) result(differences) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik), dimension(:), allocatable procedure, public :: diff_real private  function diff_real (this, col_index) result(differences) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk), dimension(:), allocatable procedure, public :: drop_column private  subroutine drop_column (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index procedure, public :: drop_duplicates private  function drop_duplicates (this) result(unique_df) Remove duplicate rows Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value type( data_frame ) procedure, public :: drop_duplicates_subset private  function drop_duplicates_subset (this, col_indices) result(unique_df) Drop duplicate rows based on specific columns (subset) Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_indices (:) Return Value type( data_frame ) procedure, public :: dropna private  function dropna (this) result(clean_df) Remove rows containing NaN values Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value type( data_frame ) generic, public :: dtype => df_get_col_type_header , df_get_col_type_index private pure function df_get_col_type_header (this, header) result(dtype) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer private pure function df_get_col_type_index (this, index) result(dtype) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value integer procedure, public :: duplicated private  function duplicated (this) result(is_dup) Check which rows are duplicates Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical, dimension(:), allocatable procedure, public :: empty private pure function empty (this) result(is_empty) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical procedure, public :: exp_column private  subroutine exp_column (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index procedure, public :: fillna_integer private  subroutine fillna_integer (this, col_index, fill_value) Replace NaN values in an integer column with a fill value Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in) :: fill_value procedure, public :: fillna_real private  subroutine fillna_real (this, col_index, fill_value) Replace NaN values in a real column with a fill value Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: fill_value procedure, public :: filter_rows_integer_range private  function filter_rows_integer_range (this, col_index, min_val, max_val) result(filtered_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in) :: min_val integer(kind=ik), intent(in) :: max_val Return Value type( data_frame ) procedure, public :: filter_rows_logical private  function filter_rows_logical (this, logical_col_index) result(new_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: logical_col_index Return Value type( data_frame ) procedure, public :: filter_rows_real_range private  function filter_rows_real_range (this, col_index, min_val, max_val) result(filtered_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: min_val real(kind=rk), intent(in) :: max_val Return Value type( data_frame ) procedure, public :: filter_rows_string_pattern private  function filter_rows_string_pattern (this, col_index, pattern) result(filtered_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index character(len=*), intent(in) :: pattern Return Value type( data_frame ) procedure, private :: find_header_index private pure function find_header_index (this, header) result(index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer procedure, private :: get_col_character private  function get_col_character (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value character(len=:), dimension(:), allocatable procedure, private :: get_col_complex private  function get_col_complex (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value complex(kind=rk), dimension(:), allocatable procedure, private :: get_col_integer private  function get_col_integer (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value integer(kind=ik), dimension(:), allocatable procedure, private :: get_col_logical private  function get_col_logical (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value logical, dimension(:), allocatable procedure, private :: get_col_real private  function get_col_real (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value real(kind=rk), dimension(:), allocatable procedure, public :: get_max_char_len => df_get_max_char_len private pure function df_get_max_char_len (this) result(max_len) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer procedure, public :: get_val_character private  function get_val_character (this, col_index, row_index) result(val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value character(len=:), allocatable procedure, public :: get_val_complex private  function get_val_complex (this, col_index, row_index) result(val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value complex(kind=rk) procedure, public :: get_val_integer private  function get_val_integer (this, col_index, row_index) result(val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value integer(kind=ik) procedure, public :: get_val_logical private  function get_val_logical (this, col_index, row_index) result(val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value logical procedure, public :: get_val_real private  function get_val_real (this, col_index, row_index) result(val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value real(kind=rk) generic, public :: getc => get_col_complex private  function get_col_complex (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value complex(kind=rk), dimension(:), allocatable generic, public :: getch => get_col_character private  function get_col_character (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value character(len=:), dimension(:), allocatable generic, public :: geti => get_col_integer private  function get_col_integer (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value integer(kind=ik), dimension(:), allocatable generic, public :: getl => get_col_logical private  function get_col_logical (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value logical, dimension(:), allocatable generic, public :: getr => get_col_real private  function get_col_real (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value real(kind=rk), dimension(:), allocatable procedure, public :: head private  function head (this, n) result(head_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: n Return Value type( data_frame ) procedure, public :: header => get_header private  function get_header (this, index) result(header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value character(len=:), allocatable procedure, public :: info private  subroutine info (this, unit) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: unit procedure, public :: inner_join private  function inner_join (this, other, this_key_col, other_key_col) result(joined_df) Perform an inner join between two data frames Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: this_key_col integer, intent(in) :: other_key_col Return Value type( data_frame ) procedure, public :: is_initialized => df_is_initialized private pure function df_is_initialized (this) result(is_init) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical procedure, public :: is_sorted_integer private  function is_sorted_integer (this, col_index, ascending) result(sorted) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value logical procedure, public :: is_sorted_real private  function is_sorted_real (this, col_index, ascending) result(sorted) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value logical procedure, public :: isna_integer private  function isna_integer (this, col_index) result(mask) Check for NaN values in an integer column Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value logical, dimension(:), allocatable procedure, public :: isna_real private  function isna_real (this, col_index) result(mask) Check for NaN values in a real column Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value logical, dimension(:), allocatable procedure, public :: left_join private  function left_join (this, other, this_key_col, other_key_col) result(joined_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: this_key_col integer, intent(in) :: other_key_col Return Value type( data_frame ) procedure, public :: log_column private  subroutine log_column (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index procedure, public :: max_integer private  function max_integer (this, col_index) result(max_val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik) procedure, public :: max_real private  function max_real (this, col_index) result(max_val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) procedure, public :: mean_integer private  function mean_integer (this, col_index) result(avg) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) procedure, public :: mean_real private  function mean_real (this, col_index) result(avg) Calculate the arithmetic mean of a real column Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) procedure, public :: median_integer private  function median_integer (this, col_index) result(med) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) procedure, public :: median_real private  function median_real (this, col_index) result(med) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) procedure, public :: merge private  function merge (this, other, on_column, how) result(merged_df) Merge two dataframes on column names (similar to SQL join but using names) Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other character(len=*), intent(in) :: on_column character(len=*), intent(in) :: how Return Value type( data_frame ) procedure, public :: min_integer private  function min_integer (this, col_index) result(min_val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik) procedure, public :: min_real private  function min_real (this, col_index) result(min_val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) procedure, public :: ncols => df_get_num_cols private pure function df_get_num_cols (this) result(num_cols) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer procedure, public :: new => df_constructor private  subroutine df_constructor (this, char_len) Initialize a new data frame Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), optional :: char_len procedure, public :: normalize_column_real private  subroutine normalize_column_real (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index procedure, public :: nrows => df_get_num_rows private pure function df_get_num_rows (this) result(num_rows) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer procedure, public :: outer_join private  function outer_join (this, other, this_key_col, other_key_col) result(joined_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: this_key_col integer, intent(in) :: other_key_col Return Value type( data_frame ) procedure, public :: percentile_integer private  function percentile_integer (this, col_index, percentile) result(perc) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: percentile Return Value real(kind=rk) procedure, public :: percentile_real private  function percentile_real (this, col_index, percentile) result(perc) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: percentile Return Value real(kind=rk) procedure, public :: pow_column private  subroutine pow_column (this, col_index, power) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: power procedure, public :: rank_integer private  function rank_integer (this, col_index, ascending) result(ranks) Rank values in an integer column Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value integer(kind=ik), dimension(:), allocatable procedure, public :: rank_real private  function rank_real (this, col_index, ascending) result(ranks) Rank values in a real column Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value integer(kind=ik), dimension(:), allocatable procedure, public :: read_csv private  subroutine read_csv (this, filename, has_headers) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this character(len=*), intent(in) :: filename logical, intent(in) :: has_headers procedure, public :: rename_column private  subroutine rename_column (this, col_index, new_name) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index character(len=*), intent(in) :: new_name procedure, public :: reorder_columns private  subroutine reorder_columns (this, new_order) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), dimension(:) :: new_order procedure, public :: replace_value_integer private  subroutine replace_value_integer (this, col_index, old_value, new_value) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in) :: old_value integer(kind=ik), intent(in) :: new_value procedure, public :: replace_value_real private  subroutine replace_value_real (this, col_index, old_value, new_value) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: old_value real(kind=rk), intent(in) :: new_value procedure, private :: resize_storage private  subroutine resize_storage (this) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this procedure, public :: right_join private  function right_join (this, other, this_key_col, other_key_col) result(joined_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: this_key_col integer, intent(in) :: other_key_col Return Value type( data_frame ) procedure, public :: round_column private  subroutine round_column (this, col_index, decimals) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: decimals procedure, public :: sample private  function sample (this, n, seed) result(sampled_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: n integer, intent(in), optional :: seed Return Value type( data_frame ) procedure, public :: select_columns private  function select_columns (this, column_indices) result(new_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), dimension(:) :: column_indices Return Value type( data_frame ) procedure, private :: set_col_character private  subroutine set_col_character (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index character(len=*), intent(in), dimension(:) :: col procedure, private :: set_col_complex private  subroutine set_col_complex (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index complex(kind=rk), intent(in), dimension(:) :: col procedure, private :: set_col_integer private  subroutine set_col_integer (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in), dimension(:) :: col procedure, private :: set_col_logical private  subroutine set_col_logical (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index logical, intent(in), dimension(:) :: col procedure, private :: set_col_real private  subroutine set_col_real (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in), dimension(:) :: col procedure, public :: set_val_character private  subroutine set_val_character (this, col_index, row_index, val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index character(len=*), intent(in) :: val procedure, public :: set_val_complex private  subroutine set_val_complex (this, col_index, row_index, val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index complex(kind=rk), intent(in) :: val procedure, public :: set_val_integer private  subroutine set_val_integer (this, col_index, row_index, val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index integer(kind=ik), intent(in) :: val procedure, public :: set_val_logical private  subroutine set_val_logical (this, col_index, row_index, val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index logical, intent(in) :: val procedure, public :: set_val_real private  subroutine set_val_real (this, col_index, row_index, val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index real(kind=rk), intent(in) :: val generic, public :: setc => set_col_complex private  subroutine set_col_complex (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index complex(kind=rk), intent(in), dimension(:) :: col generic, public :: setch => set_col_character private  subroutine set_col_character (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index character(len=*), intent(in), dimension(:) :: col generic, public :: seti => set_col_integer private  subroutine set_col_integer (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in), dimension(:) :: col generic, public :: setl => set_col_logical private  subroutine set_col_logical (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index logical, intent(in), dimension(:) :: col generic, public :: setr => set_col_real private  subroutine set_col_real (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in), dimension(:) :: col procedure, public :: shape private  function shape (this) result(dims) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer, dimension(2) procedure, public :: shuffle private  subroutine shuffle (this, seed) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), optional :: seed procedure, public :: slice_rows private  function slice_rows (this, start_row, end_row) result(new_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: start_row integer, intent(in) :: end_row Return Value type( data_frame ) procedure, public :: sort_by_column private  subroutine sort_by_column (this, col_index, ascending) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending procedure, public :: sqrt_column private  subroutine sqrt_column (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index procedure, public :: standardize_column_real private  subroutine standardize_column_real (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index procedure, public :: std_integer private  function std_integer (this, col_index) result(stddev) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) procedure, public :: std_real private  function std_real (this, col_index) result(stddev) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) procedure, public :: sum_integer private  function sum_integer (this, col_index) result(total) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik) procedure, public :: sum_real private  function sum_real (this, col_index) result(total) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) procedure, public :: tail private  function tail (this, n) result(tail_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: n Return Value type( data_frame ) procedure, public :: transpose private  function transpose (this) result(transposed_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value type( data_frame ) procedure, public :: unique_character private  function unique_character (this, col_index) result(unique_vals) Get unique values from a character column Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value character(len=:), allocatable, (:) procedure, public :: unique_integer private  function unique_integer (this, col_index) result(unique_vals) Get unique values from an integer column Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik), dimension(:), allocatable procedure, public :: unique_real private  function unique_real (this, col_index) result(unique_vals) Get unique values from a real column Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk), dimension(:), allocatable procedure, private :: validate_column_addition private  subroutine validate_column_addition (this, header, col_size) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this character(len=*), intent(in), optional :: header integer, intent(in) :: col_size procedure, public :: value_counts_character private  function value_counts_character (this, col_index) result(counts_df) Count occurrences of each value in a character column Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value type( data_frame ) procedure, public :: value_counts_integer private  function value_counts_integer (this, col_index) result(counts_df) Count occurrences of each value in an integer column Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value type( data_frame ) procedure, public :: value_counts_real private  function value_counts_real (this, col_index) result(counts_df) Count occurrences of each value in a real column Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value type( data_frame ) procedure, public :: variance_integer private  function variance_integer (this, col_index) result(var) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) procedure, public :: variance_real private  function variance_real (this, col_index) result(var) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) procedure, public :: write_console private  subroutine write_console (this, unit) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: unit procedure, public :: write_csv private  subroutine write_csv (this, filename) Export data frame to a CSV file Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: filename Source Code type :: data_frame private integer :: num_cols = 0 , max_char_len = MAX_CHAR_LEN_DEFAULT logical :: with_headers = . false . character ( len = :), dimension (:), allocatable :: headers type ( column ), dimension (:), allocatable :: data_cols logical :: initialized = . false . contains private ! Constructor/Destructor procedure , public :: new => df_constructor procedure , public :: destroy => df_destructor procedure , public :: is_initialized => df_is_initialized ! Basic info procedure , public :: ncols => df_get_num_cols procedure , public :: nrows => df_get_num_rows procedure , public :: get_max_char_len => df_get_max_char_len procedure , public :: header => get_header procedure :: df_get_col_type_header , df_get_col_type_index generic , public :: dtype => df_get_col_type_header , df_get_col_type_index ! Data manipulation procedure :: add_col_real , add_col_integer , add_col_logical , & add_col_character , add_col_complex generic , public :: append => add_col_real , add_col_integer , add_col_logical , & add_col_character , add_col_complex ! Getters (get entire columns) procedure :: get_col_real , get_col_integer , get_col_logical , & get_col_character , get_col_complex generic , public :: getr => get_col_real generic , public :: geti => get_col_integer generic , public :: getl => get_col_logical generic , public :: getch => get_col_character generic , public :: getc => get_col_complex ! Getters (get single values) procedure , public :: get_val_real , get_val_integer , get_val_logical , & get_val_character , get_val_complex ! Setters (set entire columns) procedure :: set_col_real , set_col_integer , set_col_logical , & set_col_character , set_col_complex generic , public :: setr => set_col_real generic , public :: seti => set_col_integer generic , public :: setl => set_col_logical generic , public :: setch => set_col_character generic , public :: setc => set_col_complex ! Setters (set single values) procedure , public :: set_val_real , set_val_integer , set_val_logical , & set_val_character , set_val_complex ! Mathematical operations procedure , public :: sum_real , sum_integer procedure , public :: mean_real , mean_integer procedure , public :: std_real , std_integer procedure , public :: median_real , median_integer procedure , public :: percentile_real , percentile_integer procedure , public :: variance_real , variance_integer procedure , public :: correlation_real procedure , public :: normalize_column_real procedure , public :: standardize_column_real procedure , public :: abs_column_real , abs_column_integer procedure , public :: cumsum_real , cumsum_integer procedure , public :: diff_real , diff_integer procedure , public :: replace_value_real , replace_value_integer procedure , public :: clip_real , clip_integer procedure , public :: is_sorted_real , is_sorted_integer procedure , public :: round_column procedure , public :: log_column , exp_column , sqrt_column procedure , public :: pow_column ! I/O operations procedure , public :: write_csv procedure , public :: read_csv procedure , public :: write_console ! Data manipulation operations procedure , public :: select_columns procedure , public :: slice_rows procedure , public :: min_real , min_integer procedure , public :: max_real , max_integer procedure , public :: sort_by_column procedure , public :: copy procedure , public :: filter_rows_logical procedure , public :: filter_rows_real_range procedure , public :: filter_rows_integer_range procedure , public :: filter_rows_string_pattern procedure , public :: rename_column procedure , public :: drop_column procedure , public :: reorder_columns procedure , public :: transpose ! Convenience functions procedure , public :: head procedure , public :: tail procedure , public :: shape procedure , public :: info procedure , public :: empty procedure , public :: clear procedure , public :: describe_numeric procedure , public :: sample procedure , public :: shuffle ! Join operations procedure , public :: inner_join procedure , public :: left_join procedure , public :: right_join procedure , public :: outer_join ! NaN handling procedure , public :: isna_real , isna_integer procedure , public :: fillna_real , fillna_integer procedure , public :: dropna ! Advanced data operations procedure , public :: unique_real , unique_integer , unique_character procedure , public :: value_counts_real , value_counts_integer , value_counts_character procedure , public :: concat procedure , public :: merge procedure , public :: rank_real , rank_integer procedure , public :: duplicated procedure , public :: drop_duplicates procedure , public :: drop_duplicates_subset ! Row operations procedure , public :: apply_to_row_real procedure , public :: apply_to_all_rows_real ! Utility procedures procedure :: already_header procedure :: resize_storage procedure :: validate_column_addition procedure :: find_header_index end type data_frame","tags":"","url":"type/data_frame.html"},{"title":"row_func_real – DataFort","text":"interface private  function row_func_real(row_values, num_cols) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: row_values integer, intent(in) :: num_cols Return Value real(kind=rk)","tags":"","url":"interface/row_func_real.html"},{"title":"get_from_col_character – DataFort","text":"private pure function get_from_col_character(this) result(col) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value character(len=:), dimension(:), allocatable Source Code pure function get_from_col_character ( this ) result ( col ) class ( column ), intent ( in ) :: this character ( len = :), dimension (:), allocatable :: col integer :: arr_size , elem_len if ( this % dtype /= CHARACTER_NUM ) error stop 'column is not of type character' ! will cause segfault if col not char type arr_size = size ( this % charcol , dim = 1 ) elem_len = len ( this % charcol ( 1 )) allocate ( character ( elem_len ) :: col ( arr_size )) col = this % charcol end function get_from_col_character","tags":"","url":"proc/get_from_col_character.html"},{"title":"get_from_col_complex – DataFort","text":"private pure function get_from_col_complex(this) result(col) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value complex(kind=rk), dimension(this%n) Source Code pure function get_from_col_complex ( this ) result ( col ) class ( column ), intent ( in ) :: this complex ( rk ), dimension ( this % n ) :: col if ( this % dtype /= COMPLEX_NUM ) error stop 'column is not of type complex' col = this % ccol end function get_from_col_complex","tags":"","url":"proc/get_from_col_complex.html"},{"title":"get_from_col_dtype – DataFort","text":"private pure function get_from_col_dtype(this) result(dtype) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer Source Code pure function get_from_col_dtype ( this ) result ( dtype ) class ( column ), intent ( in ) :: this integer :: dtype dtype = this % dtype end function get_from_col_dtype","tags":"","url":"proc/get_from_col_dtype.html"},{"title":"get_from_col_integer – DataFort","text":"private pure function get_from_col_integer(this) result(col) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer(kind=ik), dimension(this%n) Source Code pure function get_from_col_integer ( this ) result ( col ) class ( column ), intent ( in ) :: this integer ( ik ), dimension ( this % n ) :: col if ( this % dtype /= INTEGER_NUM ) error stop 'column is not of type integer' col = this % icol end function get_from_col_integer","tags":"","url":"proc/get_from_col_integer.html"},{"title":"get_from_col_logical – DataFort","text":"private pure function get_from_col_logical(this) result(col) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value logical, dimension(this%n) Source Code pure function get_from_col_logical ( this ) result ( col ) class ( column ), intent ( in ) :: this logical , dimension ( this % n ) :: col if ( this % dtype /= LOGICAL_NUM ) error stop 'column is not of type logical' col = this % lcol end function get_from_col_logical","tags":"","url":"proc/get_from_col_logical.html"},{"title":"get_from_col_real – DataFort","text":"private pure function get_from_col_real(this) result(col) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value real(kind=rk), dimension(this%n) Source Code pure function get_from_col_real ( this ) result ( col ) class ( column ), intent ( in ) :: this real ( rk ), dimension ( this % n ) :: col if ( this % dtype /= REAL_NUM ) error stop 'column is not of type real' col = this % rcol end function get_from_col_real","tags":"","url":"proc/get_from_col_real.html"},{"title":"get_single_col_character – DataFort","text":"private pure function get_single_col_character(this, i) result(val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value character(len=:), allocatable Source Code pure function get_single_col_character ( this , i ) result ( val ) class ( column ), intent ( in ) :: this integer , intent ( in ) :: i character ( len = :), allocatable :: val if ( this % dtype /= CHARACTER_NUM ) error stop 'column is not of type character' if ( i > this % n ) error stop 'out of bounds attempt on data column' val = this % charcol ( i ) end function get_single_col_character","tags":"","url":"proc/get_single_col_character.html"},{"title":"get_single_col_complex – DataFort","text":"private pure function get_single_col_complex(this, i) result(val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value complex(kind=rk) Source Code pure function get_single_col_complex ( this , i ) result ( val ) class ( column ), intent ( in ) :: this integer , intent ( in ) :: i complex ( rk ) :: val if ( this % dtype /= COMPLEX_NUM ) error stop 'column is not of type complex' if ( i > this % n ) error stop 'out of bounds attempt on data column' val = this % ccol ( i ) end function get_single_col_complex","tags":"","url":"proc/get_single_col_complex.html"},{"title":"get_single_col_integer – DataFort","text":"private pure function get_single_col_integer(this, i) result(val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value integer(kind=ik) Source Code pure function get_single_col_integer ( this , i ) result ( val ) class ( column ), intent ( in ) :: this integer , intent ( in ) :: i integer ( ik ) :: val if ( this % dtype /= INTEGER_NUM ) error stop 'column is not of type integer' if ( i > this % n ) error stop 'out of bounds attempt on data column' val = this % icol ( i ) end function get_single_col_integer","tags":"","url":"proc/get_single_col_integer.html"},{"title":"get_single_col_logical – DataFort","text":"private pure function get_single_col_logical(this, i) result(val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value logical Source Code pure function get_single_col_logical ( this , i ) result ( val ) class ( column ), intent ( in ) :: this integer , intent ( in ) :: i logical :: val if ( this % dtype /= LOGICAL_NUM ) error stop 'column is not of type logical' if ( i > this % n ) error stop 'out of bounds attempt on data column' val = this % lcol ( i ) end function get_single_col_logical","tags":"","url":"proc/get_single_col_logical.html"},{"title":"get_single_col_real – DataFort","text":"private pure function get_single_col_real(this, i) result(val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) Source Code pure function get_single_col_real ( this , i ) result ( val ) class ( column ), intent ( in ) :: this integer , intent ( in ) :: i real ( rk ) :: val if ( this % dtype /= REAL_NUM ) error stop 'column is not of type real' if ( i > this % n ) error stop 'out of bounds attempt on data column' val = this % rcol ( i ) end function get_single_col_real","tags":"","url":"proc/get_single_col_real.html"},{"title":"change_col_character – DataFort","text":"private  subroutine change_col_character(this, i, val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i character(len=*), intent(in) :: val Source Code subroutine change_col_character ( this , i , val ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: i character ( len =* ), intent ( in ) :: val if ( this % dtype /= CHARACTER_NUM ) error stop 'column is not of type character' this % charcol ( i ) = val end subroutine change_col_character","tags":"","url":"proc/change_col_character.html"},{"title":"change_col_complex – DataFort","text":"private  subroutine change_col_complex(this, i, val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i complex(kind=rk), intent(in) :: val Source Code subroutine change_col_complex ( this , i , val ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: i complex ( rk ), intent ( in ) :: val if ( this % dtype /= COMPLEX_NUM ) error stop 'column is not of type complex' this % ccol ( i ) = val end subroutine change_col_complex","tags":"","url":"proc/change_col_complex.html"},{"title":"change_col_integer – DataFort","text":"private  subroutine change_col_integer(this, i, val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i integer(kind=ik), intent(in) :: val Source Code subroutine change_col_integer ( this , i , val ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: i integer ( ik ), intent ( in ) :: val if ( this % dtype /= INTEGER_NUM ) error stop 'column is not of type integer' this % icol ( i ) = val end subroutine change_col_integer","tags":"","url":"proc/change_col_integer.html"},{"title":"change_col_logical – DataFort","text":"private  subroutine change_col_logical(this, i, val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i logical, intent(in) :: val Source Code subroutine change_col_logical ( this , i , val ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: i logical , intent ( in ) :: val if ( this % dtype /= LOGICAL_NUM ) error stop 'column is not of type logical' this % lcol ( i ) = val end subroutine change_col_logical","tags":"","url":"proc/change_col_logical.html"},{"title":"change_col_real – DataFort","text":"private  subroutine change_col_real(this, i, val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i real(kind=rk), intent(in) :: val Source Code subroutine change_col_real ( this , i , val ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: i real ( rk ), intent ( in ) :: val if ( this % dtype /= REAL_NUM ) error stop 'column is not of type real' this % rcol ( i ) = val end subroutine change_col_real","tags":"","url":"proc/change_col_real.html"},{"title":"col_constructor_alloc_character – DataFort","text":"private  subroutine col_constructor_alloc_character(this, n, len) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n integer, intent(in), optional :: len Source Code subroutine col_constructor_alloc_character ( this , n , len ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: n integer , intent ( in ), optional :: len integer :: char_len if ( present ( len )) then char_len = len else char_len = MAX_CHAR_LEN_DEFAULT end if if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = CHARACTER_NUM this % n = n allocate ( character ( len = char_len ) :: this % charcol ( n )) end subroutine col_constructor_alloc_character","tags":"","url":"proc/col_constructor_alloc_character.html"},{"title":"col_constructor_alloc_complex – DataFort","text":"private  subroutine col_constructor_alloc_complex(this, n) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n Source Code subroutine col_constructor_alloc_complex ( this , n ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: n if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = COMPLEX_NUM this % n = n allocate ( this % ccol ( n )) end subroutine col_constructor_alloc_complex","tags":"","url":"proc/col_constructor_alloc_complex.html"},{"title":"col_constructor_alloc_integer – DataFort","text":"private  subroutine col_constructor_alloc_integer(this, n) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n Source Code subroutine col_constructor_alloc_integer ( this , n ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: n if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = INTEGER_NUM this % n = n allocate ( this % icol ( n )) end subroutine col_constructor_alloc_integer","tags":"","url":"proc/col_constructor_alloc_integer.html"},{"title":"col_constructor_alloc_logical – DataFort","text":"private  subroutine col_constructor_alloc_logical(this, n) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n Source Code subroutine col_constructor_alloc_logical ( this , n ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: n if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = LOGICAL_NUM this % n = n allocate ( this % lcol ( n )) end subroutine col_constructor_alloc_logical","tags":"","url":"proc/col_constructor_alloc_logical.html"},{"title":"col_constructor_alloc_real – DataFort","text":"private  subroutine col_constructor_alloc_real(this, n) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n Source Code subroutine col_constructor_alloc_real ( this , n ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: n if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = REAL_NUM this % n = n allocate ( this % rcol ( n )) end subroutine col_constructor_alloc_real","tags":"","url":"proc/col_constructor_alloc_real.html"},{"title":"col_constructor_character – DataFort","text":"private  subroutine col_constructor_character(this, dcol) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: dcol Source Code subroutine col_constructor_character ( this , dcol ) class ( column ), intent ( inout ) :: this character ( len =* ), dimension (:), intent ( in ) :: dcol integer :: elem_len if ( this % initialized ) call this % destroy () this % initialized = . true . this % n = size ( dcol , dim = 1 ) elem_len = len ( dcol ( 1 )) this % dtype = CHARACTER_NUM allocate ( character ( elem_len ) :: this % charcol ( this % n )) this % charcol = dcol end subroutine col_constructor_character","tags":"","url":"proc/col_constructor_character.html"},{"title":"col_constructor_complex – DataFort","text":"private  subroutine col_constructor_complex(this, dcol) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: dcol Source Code subroutine col_constructor_complex ( this , dcol ) class ( column ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: dcol if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = COMPLEX_NUM this % n = size ( dcol , dim = 1 ) allocate ( this % ccol ( this % n )) this % ccol = dcol end subroutine col_constructor_complex","tags":"","url":"proc/col_constructor_complex.html"},{"title":"col_constructor_integer – DataFort","text":"private  subroutine col_constructor_integer(this, dcol) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: dcol Source Code subroutine col_constructor_integer ( this , dcol ) class ( column ), intent ( inout ) :: this integer ( ik ), dimension (:), intent ( in ) :: dcol if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = INTEGER_NUM this % n = size ( dcol , dim = 1 ) allocate ( this % icol ( this % n )) this % icol = dcol end subroutine col_constructor_integer","tags":"","url":"proc/col_constructor_integer.html"},{"title":"col_constructor_logical – DataFort","text":"private  subroutine col_constructor_logical(this, dcol) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this logical, intent(in), dimension(:) :: dcol Source Code subroutine col_constructor_logical ( this , dcol ) class ( column ), intent ( inout ) :: this logical , dimension (:), intent ( in ) :: dcol if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = LOGICAL_NUM this % n = size ( dcol , dim = 1 ) allocate ( this % lcol ( this % n )) this % lcol = dcol end subroutine col_constructor_logical","tags":"","url":"proc/col_constructor_logical.html"},{"title":"col_constructor_real – DataFort","text":"private  subroutine col_constructor_real(this, dcol) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: dcol Source Code subroutine col_constructor_real ( this , dcol ) class ( column ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: dcol if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = REAL_NUM this % n = size ( dcol , dim = 1 ) allocate ( this % rcol ( this % n )) this % rcol = dcol end subroutine col_constructor_real","tags":"","url":"proc/col_constructor_real.html"},{"title":"col_destructor – DataFort","text":"private  subroutine col_destructor(this) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this Source Code subroutine col_destructor ( this ) class ( column ), intent ( inout ) :: this if ( allocated ( this % rcol )) deallocate ( this % rcol ) if ( allocated ( this % icol )) deallocate ( this % icol ) if ( allocated ( this % lcol )) deallocate ( this % lcol ) if ( allocated ( this % ccol )) deallocate ( this % ccol ) if ( allocated ( this % charcol )) deallocate ( this % charcol ) end subroutine col_destructor","tags":"","url":"proc/col_destructor.html"},{"title":"already_header – DataFort","text":"private  function already_header(this, header) result(exists) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value logical Source Code function already_header ( this , header ) result ( exists ) class ( data_frame ), intent ( in ) :: this character ( len =* ), intent ( in ) :: header logical :: exists integer :: i character ( len = :), allocatable :: trimmed_header exists = . false . if (. not . this % with_headers ) return trimmed_header = trim ( adjustl ( header )) do i = 1 , this % num_cols if ( trim ( adjustl ( this % headers ( i ))) == trimmed_header ) then exists = . true . exit end if end do end function already_header","tags":"","url":"proc/already_header.html"},{"title":"apply_to_all_rows_real – DataFort","text":"private  function apply_to_all_rows_real(this, func) result(outputs) Apply a function to all rows Applies a user-defined function to each row in the data frame,\nreturning an array of results. @param[in] func Function to apply (must match row_func_real interface)\n@return Array of results, one per row Example real ( rk ), dimension (:), allocatable :: row_sums row_sums = df % apply_to_all_rows_real ( row_sum ) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this procedure( row_func_real ) :: func Return Value real(kind=rk), dimension(:), allocatable Source Code function apply_to_all_rows_real ( this , func ) result ( outputs ) class ( data_frame ), intent ( in ) :: this procedure ( row_func_real ) :: func real ( rk ), dimension (:), allocatable :: outputs integer :: i , n_rows n_rows = this % nrows () allocate ( outputs ( n_rows )) do i = 1 , n_rows outputs ( i ) = this % apply_to_row_real ( i , func ) end do end function apply_to_all_rows_real","tags":"","url":"proc/apply_to_all_rows_real.html"},{"title":"apply_to_row_real – DataFort","text":"private  function apply_to_row_real(this, row_idx, func) result(output) Apply a function to a single row Extracts all numeric values from a specified row and applies\na user-defined function to them. Non-numeric columns are skipped. @param[in] row_idx Row index to process\n@param[in] func Function to apply (must match row_func_real interface)\n@return Result of applying the function to the row Example ! Define a function that computes row sum function row_sum ( values , n ) result ( s ) real ( rk ), dimension (:), intent ( in ) :: values integer , intent ( in ) :: n real ( rk ) :: s s = sum ( values ( 1 : n )) end function ! Apply it result = df % apply_to_row_real ( 5 , row_sum ) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: row_idx procedure( row_func_real ) :: func Return Value real(kind=rk) Source Code function apply_to_row_real ( this , row_idx , func ) result ( output ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: row_idx procedure ( row_func_real ) :: func real ( rk ) :: output real ( rk ), dimension (:), allocatable :: row_values integer :: i , n_numeric , col_type real ( rk ) :: temp_real integer ( ik ) :: temp_int ! Count numeric columns n_numeric = 0 do i = 1 , this % num_cols col_type = this % data_cols ( i )% dtype if ( col_type == 1 . or . col_type == 2 ) then ! 1=REAL_NUM, 2=INT_NUM n_numeric = n_numeric + 1 end if end do ! Allocate and fill row values allocate ( row_values ( n_numeric )) n_numeric = 0 do i = 1 , this % num_cols col_type = this % data_cols ( i )% dtype if ( col_type == 1 ) then ! REAL_NUM n_numeric = n_numeric + 1 row_values ( n_numeric ) = this % get_val_real ( i , row_idx ) else if ( col_type == 2 ) then ! INT_NUM n_numeric = n_numeric + 1 row_values ( n_numeric ) = real ( this % get_val_integer ( i , row_idx ), rk ) end if end do ! Apply function output = func ( row_values , n_numeric ) deallocate ( row_values ) end function apply_to_row_real","tags":"","url":"proc/apply_to_row_real.html"},{"title":"concat – DataFort","text":"private  function concat(this, other, axis) result(result_df) Concatenate two dataframes vertically (rows) or horizontally (columns) @param[in] this First dataframe\n@param[in] other Second dataframe\n@param[in] axis 0 for vertical (stack rows), 1 for horizontal (add columns)\n@return Concatenated dataframe Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: axis Return Value type( data_frame ) Source Code function concat ( this , other , axis ) result ( result_df ) class ( data_frame ), intent ( in ) :: this , other integer , intent ( in ) :: axis type ( data_frame ) :: result_df integer :: i , j , dtype character ( len = 100 ) :: header_name real ( rk ), dimension (:), allocatable :: real_col1 , real_col2 , real_combined , real_col integer ( ik ), dimension (:), allocatable :: int_col1 , int_col2 , int_combined , int_col logical , dimension (:), allocatable :: log_col1 , log_col2 , log_combined , log_col character ( len = :), allocatable :: char_col1 (:), char_col2 (:), char_combined (:), char_col (:) complex ( rk ), dimension (:), allocatable :: cmplx_col1 , cmplx_col2 , cmplx_combined , cmplx_col if ( axis == 0 ) then ! Vertical concatenation (stack rows) if ( this % ncols () /= other % ncols ()) then print * , \"Error: DataFrames must have same number of columns\" call result_df % new () return end if call result_df % new ( max ( this % max_char_len , other % max_char_len )) do i = 1 , this % ncols () dtype = this % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) real_col1 = this % getr ( i ) real_col2 = other % getr ( i ) allocate ( real_combined ( size ( real_col1 ) + size ( real_col2 ))) real_combined ( 1 : size ( real_col1 )) = real_col1 real_combined ( size ( real_col1 ) + 1 :) = real_col2 if ( this % with_headers ) then header_name = this % header ( i ) call result_df % append ( real_combined , trim ( header_name )) else call result_df % append ( real_combined ) end if deallocate ( real_col1 , real_col2 , real_combined ) case ( INTEGER_NUM ) int_col1 = this % geti ( i ) int_col2 = other % geti ( i ) allocate ( int_combined ( size ( int_col1 ) + size ( int_col2 ))) int_combined ( 1 : size ( int_col1 )) = int_col1 int_combined ( size ( int_col1 ) + 1 :) = int_col2 if ( this % with_headers ) then header_name = this % header ( i ) call result_df % append ( int_combined , trim ( header_name )) else call result_df % append ( int_combined ) end if deallocate ( int_col1 , int_col2 , int_combined ) case ( LOGICAL_NUM ) log_col1 = this % getl ( i ) log_col2 = other % getl ( i ) allocate ( log_combined ( size ( log_col1 ) + size ( log_col2 ))) log_combined ( 1 : size ( log_col1 )) = log_col1 log_combined ( size ( log_col1 ) + 1 :) = log_col2 if ( this % with_headers ) then header_name = this % header ( i ) call result_df % append ( log_combined , trim ( header_name )) else call result_df % append ( log_combined ) end if deallocate ( log_col1 , log_col2 , log_combined ) case ( CHARACTER_NUM ) char_col1 = this % getch ( i ) char_col2 = other % getch ( i ) allocate ( character ( len = max ( len ( char_col1 ), len ( char_col2 ))) :: char_combined ( size ( char_col1 ) + size ( char_col2 ))) char_combined ( 1 : size ( char_col1 )) = char_col1 char_combined ( size ( char_col1 ) + 1 :) = char_col2 if ( this % with_headers ) then header_name = this % header ( i ) call result_df % append ( char_combined , trim ( header_name )) else call result_df % append ( char_combined ) end if deallocate ( char_col1 , char_col2 , char_combined ) case ( COMPLEX_NUM ) cmplx_col1 = this % getc ( i ) cmplx_col2 = other % getc ( i ) allocate ( cmplx_combined ( size ( cmplx_col1 ) + size ( cmplx_col2 ))) cmplx_combined ( 1 : size ( cmplx_col1 )) = cmplx_col1 cmplx_combined ( size ( cmplx_col1 ) + 1 :) = cmplx_col2 if ( this % with_headers ) then header_name = this % header ( i ) call result_df % append ( cmplx_combined , trim ( header_name )) else call result_df % append ( cmplx_combined ) end if deallocate ( cmplx_col1 , cmplx_col2 , cmplx_combined ) end select end do else if ( axis == 1 ) then ! Horizontal concatenation (add columns) if ( this % nrows () /= other % nrows ()) then print * , \"Error: DataFrames must have same number of rows\" call result_df % new () return end if result_df = this % copy () ! Add columns from other do i = 1 , other % ncols () dtype = other % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) real_col = other % getr ( i ) if ( other % with_headers ) then header_name = other % header ( i ) call result_df % append ( real_col , trim ( header_name )) else call result_df % append ( real_col ) end if deallocate ( real_col ) case ( INTEGER_NUM ) int_col = other % geti ( i ) if ( other % with_headers ) then header_name = other % header ( i ) call result_df % append ( int_col , trim ( header_name )) else call result_df % append ( int_col ) end if deallocate ( int_col ) case ( LOGICAL_NUM ) log_col = other % getl ( i ) if ( other % with_headers ) then header_name = other % header ( i ) call result_df % append ( log_col , trim ( header_name )) else call result_df % append ( log_col ) end if deallocate ( log_col ) case ( CHARACTER_NUM ) char_col = other % getch ( i ) if ( other % with_headers ) then header_name = other % header ( i ) call result_df % append ( char_col , trim ( header_name )) else call result_df % append ( char_col ) end if deallocate ( char_col ) case ( COMPLEX_NUM ) cmplx_col = other % getc ( i ) if ( other % with_headers ) then header_name = other % header ( i ) call result_df % append ( cmplx_col , trim ( header_name )) else call result_df % append ( cmplx_col ) end if deallocate ( cmplx_col ) end select end do else print * , \"Error: axis must be 0 (vertical) or 1 (horizontal)\" call result_df % new () end if end function concat","tags":"","url":"proc/concat.html"},{"title":"copy – DataFort","text":"private  function copy(this) result(new_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value type( data_frame ) Source Code function copy ( this ) result ( new_df ) class ( data_frame ), intent ( in ) :: this type ( data_frame ) :: new_df integer :: i call new_df % new ( this % max_char_len ) do i = 1 , this % num_cols select case ( this % data_cols ( i )% get_type ()) case ( REAL_NUM ) if ( this % with_headers ) then call new_df % append ( this % data_cols ( i )% getr (), this % headers ( i )) else call new_df % append ( this % data_cols ( i )% getr ()) end if case ( INTEGER_NUM ) if ( this % with_headers ) then call new_df % append ( this % data_cols ( i )% geti (), this % headers ( i )) else call new_df % append ( this % data_cols ( i )% geti ()) end if case ( LOGICAL_NUM ) if ( this % with_headers ) then call new_df % append ( this % data_cols ( i )% getl (), this % headers ( i )) else call new_df % append ( this % data_cols ( i )% getl ()) end if case ( CHARACTER_NUM ) if ( this % with_headers ) then call new_df % append ( this % data_cols ( i )% getch (), this % headers ( i )) else call new_df % append ( this % data_cols ( i )% getch ()) end if case ( COMPLEX_NUM ) if ( this % with_headers ) then call new_df % append ( this % data_cols ( i )% getc (), this % headers ( i )) else call new_df % append ( this % data_cols ( i )% getc ()) end if end select end do end function copy","tags":"","url":"proc/copy.html"},{"title":"correlation_real – DataFort","text":"private  function correlation_real(this, col_index1, col_index2) result(corr) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index1 integer, intent(in) :: col_index2 Return Value real(kind=rk) Source Code function correlation_real ( this , col_index1 , col_index2 ) result ( corr ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index1 , col_index2 real ( rk ) :: corr real ( rk ), dimension (:), allocatable :: col1 , col2 real ( rk ) :: mean1 , mean2 , std1 , std2 , covariance integer :: i , n col1 = this % getr ( col_index1 ) col2 = this % getr ( col_index2 ) n = size ( col1 ) if ( n /= size ( col2 )) error stop \"columns must have same length\" mean1 = this % mean_real ( col_index1 ) mean2 = this % mean_real ( col_index2 ) std1 = this % std_real ( col_index1 ) std2 = this % std_real ( col_index2 ) ! Calculate covariance covariance = 0.0_rk do i = 1 , n covariance = covariance + ( col1 ( i ) - mean1 ) * ( col2 ( i ) - mean2 ) end do covariance = covariance / real ( n - 1 , rk ) ! Pearson correlation = covariance / (std1 * std2) if ( std1 > 0.0_rk . and . std2 > 0.0_rk ) then corr = covariance / ( std1 * std2 ) else corr = 0.0_rk ! undefined if either std is zero end if end function correlation_real","tags":"","url":"proc/correlation_real.html"},{"title":"df_get_col_type_header – DataFort","text":"private pure function df_get_col_type_header(this, header) result(dtype) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer Source Code pure function df_get_col_type_header ( this , header ) result ( dtype ) class ( data_frame ), intent ( in ) :: this character ( len =* ), intent ( in ) :: header integer :: dtype integer :: ind ind = this % find_header_index ( header ) dtype = this % data_cols ( ind )% get_type () end function df_get_col_type_header","tags":"","url":"proc/df_get_col_type_header.html"},{"title":"df_get_col_type_index – DataFort","text":"private pure function df_get_col_type_index(this, index) result(dtype) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value integer Source Code pure function df_get_col_type_index ( this , index ) result ( dtype ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: index integer :: dtype if ( index < 1 . or . index > this % num_cols ) error stop \"column index out of range\" dtype = this % data_cols ( index )% get_type () end function df_get_col_type_index","tags":"","url":"proc/df_get_col_type_index.html"},{"title":"df_get_max_char_len – DataFort","text":"private pure function df_get_max_char_len(this) result(max_len) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer Source Code pure function df_get_max_char_len ( this ) result ( max_len ) class ( data_frame ), intent ( in ) :: this integer :: max_len max_len = this % max_char_len end function df_get_max_char_len","tags":"","url":"proc/df_get_max_char_len.html"},{"title":"df_get_num_cols – DataFort","text":"private pure function df_get_num_cols(this) result(num_cols) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer Source Code pure function df_get_num_cols ( this ) result ( num_cols ) class ( data_frame ), intent ( in ) :: this integer :: num_cols num_cols = this % num_cols end function df_get_num_cols","tags":"","url":"proc/df_get_num_cols.html"},{"title":"df_get_num_rows – DataFort","text":"private pure function df_get_num_rows(this) result(num_rows) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer Source Code pure function df_get_num_rows ( this ) result ( num_rows ) class ( data_frame ), intent ( in ) :: this integer :: num_rows if ( this % num_cols == 0 ) then num_rows = 0 else num_rows = this % data_cols ( 1 )% n end if end function df_get_num_rows","tags":"","url":"proc/df_get_num_rows.html"},{"title":"df_is_initialized – DataFort","text":"private pure function df_is_initialized(this) result(is_init) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical Source Code pure function df_is_initialized ( this ) result ( is_init ) class ( data_frame ), intent ( in ) :: this logical :: is_init is_init = this % initialized end function df_is_initialized","tags":"","url":"proc/df_is_initialized.html"},{"title":"diff_integer – DataFort","text":"private  function diff_integer(this, col_index) result(differences) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik), dimension(:), allocatable Source Code function diff_integer ( this , col_index ) result ( differences ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index integer ( ik ), dimension (:), allocatable :: differences integer ( ik ), dimension (:), allocatable :: col integer :: i , n col = this % geti ( col_index ) n = size ( col ) if ( n < 2 ) then allocate ( differences ( 0 )) return end if allocate ( differences ( n - 1 )) do i = 1 , n - 1 differences ( i ) = col ( i + 1 ) - col ( i ) end do end function diff_integer","tags":"","url":"proc/diff_integer.html"},{"title":"diff_real – DataFort","text":"private  function diff_real(this, col_index) result(differences) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk), dimension(:), allocatable Source Code function diff_real ( this , col_index ) result ( differences ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: differences real ( rk ), dimension (:), allocatable :: col integer :: i , n col = this % getr ( col_index ) n = size ( col ) if ( n < 2 ) then allocate ( differences ( 0 )) return end if allocate ( differences ( n - 1 )) do i = 1 , n - 1 differences ( i ) = col ( i + 1 ) - col ( i ) end do end function diff_real","tags":"","url":"proc/diff_real.html"},{"title":"drop_duplicates – DataFort","text":"private  function drop_duplicates(this) result(unique_df) Remove duplicate rows Returns new dataframe with duplicate rows removed (keeps first occurrence) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value type( data_frame ) Source Code function drop_duplicates ( this ) result ( unique_df ) class ( data_frame ), intent ( in ) :: this type ( data_frame ) :: unique_df logical , dimension (:), allocatable :: is_dup , keep_mask integer :: i , j , num_unique , dtype integer , dimension (:), allocatable :: unique_indices character ( len = 100 ) :: header_name real ( rk ), dimension (:), allocatable :: real_col , real_unique_col integer ( ik ), dimension (:), allocatable :: int_col , int_unique_col logical , dimension (:), allocatable :: log_col , log_unique_col character ( len = :), allocatable :: char_col (:), char_unique_col (:) complex ( rk ), dimension (:), allocatable :: cmplx_col , cmplx_unique_col is_dup = this % duplicated () allocate ( keep_mask ( this % nrows ())) keep_mask = . not . is_dup num_unique = count ( keep_mask ) if ( num_unique == 0 ) then call unique_df % new () return end if ! Build index array allocate ( unique_indices ( num_unique )) j = 0 do i = 1 , this % nrows () if ( keep_mask ( i )) then j = j + 1 unique_indices ( j ) = i end if end do ! Build result dataframe call unique_df % new ( this % max_char_len ) do i = 1 , this % ncols () dtype = this % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) real_col = this % getr ( i ) allocate ( real_unique_col ( num_unique )) do j = 1 , num_unique real_unique_col ( j ) = real_col ( unique_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call unique_df % append ( real_unique_col , trim ( header_name )) else call unique_df % append ( real_unique_col ) end if deallocate ( real_unique_col ) case ( INTEGER_NUM ) int_col = this % geti ( i ) allocate ( int_unique_col ( num_unique )) do j = 1 , num_unique int_unique_col ( j ) = int_col ( unique_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call unique_df % append ( int_unique_col , trim ( header_name )) else call unique_df % append ( int_unique_col ) end if deallocate ( int_unique_col ) case ( LOGICAL_NUM ) log_col = this % getl ( i ) allocate ( log_unique_col ( num_unique )) do j = 1 , num_unique log_unique_col ( j ) = log_col ( unique_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call unique_df % append ( log_unique_col , trim ( header_name )) else call unique_df % append ( log_unique_col ) end if deallocate ( log_unique_col ) case ( CHARACTER_NUM ) char_col = this % getch ( i ) allocate ( character ( len = len ( char_col )) :: char_unique_col ( num_unique )) do j = 1 , num_unique char_unique_col ( j ) = char_col ( unique_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call unique_df % append ( char_unique_col , trim ( header_name )) else call unique_df % append ( char_unique_col ) end if deallocate ( char_unique_col ) case ( COMPLEX_NUM ) cmplx_col = this % getc ( i ) allocate ( cmplx_unique_col ( num_unique )) do j = 1 , num_unique cmplx_unique_col ( j ) = cmplx_col ( unique_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call unique_df % append ( cmplx_unique_col , trim ( header_name )) else call unique_df % append ( cmplx_unique_col ) end if deallocate ( cmplx_unique_col ) end select end do deallocate ( is_dup , keep_mask , unique_indices ) end function drop_duplicates","tags":"","url":"proc/drop_duplicates.html"},{"title":"drop_duplicates_subset – DataFort","text":"private  function drop_duplicates_subset(this, col_indices) result(unique_df) Drop duplicate rows based on specific columns (subset) @param[in] this The dataframe\n@param[in] col_indices Array of column indices to check for duplicates\n@return New dataframe with duplicate rows removed Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_indices (:) Return Value type( data_frame ) Source Code function drop_duplicates_subset ( this , col_indices ) result ( unique_df ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_indices (:) type ( data_frame ) :: unique_df logical , dimension (:), allocatable :: is_dup , keep_mask integer , dimension (:), allocatable :: unique_indices integer :: i , j , k , row1 , row2 , dtype , num_unique , col_idx logical :: is_duplicate character ( len = :), allocatable :: header_name real ( rk ), dimension (:), allocatable :: real_col , real_unique_col integer ( ik ), dimension (:), allocatable :: int_col , int_unique_col logical , dimension (:), allocatable :: log_col , log_unique_col character ( len = :), allocatable :: char_col (:), char_unique_col (:) complex ( rk ), dimension (:), allocatable :: cmplx_col , cmplx_unique_col allocate ( is_dup ( this % nrows ())) is_dup = . false . ! Check each row against all previous rows (only comparing subset columns) do row1 = 1 , this % nrows () if ( is_dup ( row1 )) cycle do row2 = row1 + 1 , this % nrows () if ( is_dup ( row2 )) cycle is_duplicate = . true . ! Only check columns in subset do k = 1 , size ( col_indices ) col_idx = col_indices ( k ) dtype = this % dtype ( col_idx ) select case ( dtype ) case ( REAL_NUM ) real_col = this % getr ( col_idx ) if (. not . ieee_is_nan ( real_col ( row1 )) . and . . not . ieee_is_nan ( real_col ( row2 ))) then if ( real_col ( row1 ) /= real_col ( row2 )) then is_duplicate = . false . exit end if else if ( ieee_is_nan ( real_col ( row1 )) . neqv . ieee_is_nan ( real_col ( row2 ))) then is_duplicate = . false . exit end if case ( INTEGER_NUM ) int_col = this % geti ( col_idx ) if (. not . is_nan_integer ( int_col ( row1 )) . and . . not . is_nan_integer ( int_col ( row2 ))) then if ( int_col ( row1 ) /= int_col ( row2 )) then is_duplicate = . false . exit end if else if ( is_nan_integer ( int_col ( row1 )) . neqv . is_nan_integer ( int_col ( row2 ))) then is_duplicate = . false . exit end if case ( LOGICAL_NUM ) log_col = this % getl ( col_idx ) if ( log_col ( row1 ) . neqv . log_col ( row2 )) then is_duplicate = . false . exit end if case ( CHARACTER_NUM ) char_col = this % getch ( col_idx ) if ( char_col ( row1 ) /= char_col ( row2 )) then is_duplicate = . false . exit end if case ( COMPLEX_NUM ) cmplx_col = this % getc ( col_idx ) if ( cmplx_col ( row1 ) /= cmplx_col ( row2 )) then is_duplicate = . false . exit end if end select end do if ( is_duplicate ) then is_dup ( row2 ) = . true . end if end do end do ! Build mask for rows to keep allocate ( keep_mask ( this % nrows ())) keep_mask = . not . is_dup num_unique = count ( keep_mask ) ! Get indices of unique rows allocate ( unique_indices ( num_unique )) j = 0 do i = 1 , this % nrows () if ( keep_mask ( i )) then j = j + 1 unique_indices ( j ) = i end if end do ! Build result dataframe with all columns call unique_df % new ( this % max_char_len ) do i = 1 , this % ncols () dtype = this % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) real_col = this % getr ( i ) allocate ( real_unique_col ( num_unique )) do j = 1 , num_unique real_unique_col ( j ) = real_col ( unique_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call unique_df % append ( real_unique_col , trim ( header_name )) else call unique_df % append ( real_unique_col ) end if deallocate ( real_unique_col ) case ( INTEGER_NUM ) int_col = this % geti ( i ) allocate ( int_unique_col ( num_unique )) do j = 1 , num_unique int_unique_col ( j ) = int_col ( unique_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call unique_df % append ( int_unique_col , trim ( header_name )) else call unique_df % append ( int_unique_col ) end if deallocate ( int_unique_col ) case ( LOGICAL_NUM ) log_col = this % getl ( i ) allocate ( log_unique_col ( num_unique )) do j = 1 , num_unique log_unique_col ( j ) = log_col ( unique_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call unique_df % append ( log_unique_col , trim ( header_name )) else call unique_df % append ( log_unique_col ) end if deallocate ( log_unique_col ) case ( CHARACTER_NUM ) char_col = this % getch ( i ) allocate ( character ( len = len ( char_col )) :: char_unique_col ( num_unique )) do j = 1 , num_unique char_unique_col ( j ) = char_col ( unique_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call unique_df % append ( char_unique_col , trim ( header_name )) else call unique_df % append ( char_unique_col ) end if deallocate ( char_unique_col ) case ( COMPLEX_NUM ) cmplx_col = this % getc ( i ) allocate ( cmplx_unique_col ( num_unique )) do j = 1 , num_unique cmplx_unique_col ( j ) = cmplx_col ( unique_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call unique_df % append ( cmplx_unique_col , trim ( header_name )) else call unique_df % append ( cmplx_unique_col ) end if deallocate ( cmplx_unique_col ) end select end do deallocate ( is_dup , keep_mask , unique_indices ) end function drop_duplicates_subset","tags":"","url":"proc/drop_duplicates_subset.html"},{"title":"dropna – DataFort","text":"private  function dropna(this) result(clean_df) Remove rows containing NaN values Returns a new data frame with all rows containing NaN in any column removed.\nChecks real and integer columns for NaN values. @param[in] this The data frame instance\n@return New data frame with NaN-containing rows removed Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value type( data_frame ) Source Code function dropna ( this ) result ( clean_df ) class ( data_frame ), intent ( in ) :: this type ( data_frame ) :: clean_df logical , dimension (:), allocatable :: keep_mask integer :: i , j , dtype , num_clean_rows integer , dimension (:), allocatable :: clean_indices real ( rk ), dimension (:), allocatable :: real_col , real_clean_col integer ( ik ), dimension (:), allocatable :: int_col , int_clean_col logical , dimension (:), allocatable :: log_col , log_clean_col character ( len = :), allocatable :: char_col (:), char_clean_col (:) complex ( rk ), dimension (:), allocatable :: cmplx_col , cmplx_clean_col character ( len = 100 ) :: header_name allocate ( keep_mask ( this % nrows ())) keep_mask = . true . ! Check all columns for NaN do i = 1 , this % ncols () dtype = this % dtype ( i ) if ( dtype == REAL_NUM ) then real_col = this % getr ( i ) do j = 1 , size ( real_col ) if ( is_nan_real ( real_col ( j ))) then keep_mask ( j ) = . false . end if end do deallocate ( real_col ) else if ( dtype == INTEGER_NUM ) then int_col = this % geti ( i ) do j = 1 , size ( int_col ) if ( is_nan_integer ( int_col ( j ))) then keep_mask ( j ) = . false . end if end do deallocate ( int_col ) end if end do ! Count rows to keep num_clean_rows = count ( keep_mask ) if ( num_clean_rows == 0 ) then call clean_df % new ( this % max_char_len ) return end if ! Build index array of rows to keep allocate ( clean_indices ( num_clean_rows )) j = 0 do i = 1 , this % nrows () if ( keep_mask ( i )) then j = j + 1 clean_indices ( j ) = i end if end do ! Create new dataframe with clean rows call clean_df % new ( this % max_char_len ) do i = 1 , this % ncols () dtype = this % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) real_col = this % getr ( i ) allocate ( real_clean_col ( num_clean_rows )) do j = 1 , num_clean_rows real_clean_col ( j ) = real_col ( clean_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call clean_df % append ( real_clean_col , trim ( header_name )) else call clean_df % append ( real_clean_col ) end if deallocate ( real_col ) deallocate ( real_clean_col ) case ( INTEGER_NUM ) int_col = this % geti ( i ) allocate ( int_clean_col ( num_clean_rows )) do j = 1 , num_clean_rows int_clean_col ( j ) = int_col ( clean_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call clean_df % append ( int_clean_col , trim ( header_name )) else call clean_df % append ( int_clean_col ) end if deallocate ( int_col ) deallocate ( int_clean_col ) case ( LOGICAL_NUM ) log_col = this % getl ( i ) allocate ( log_clean_col ( num_clean_rows )) do j = 1 , num_clean_rows log_clean_col ( j ) = log_col ( clean_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call clean_df % append ( log_clean_col , trim ( header_name )) else call clean_df % append ( log_clean_col ) end if deallocate ( log_col ) deallocate ( log_clean_col ) case ( CHARACTER_NUM ) char_col = this % getch ( i ) allocate ( character ( len = len ( char_col )) :: char_clean_col ( num_clean_rows )) do j = 1 , num_clean_rows char_clean_col ( j ) = char_col ( clean_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call clean_df % append ( char_clean_col , trim ( header_name )) else call clean_df % append ( char_clean_col ) end if deallocate ( char_col ) deallocate ( char_clean_col ) case ( COMPLEX_NUM ) cmplx_col = this % getc ( i ) allocate ( cmplx_clean_col ( num_clean_rows )) do j = 1 , num_clean_rows cmplx_clean_col ( j ) = cmplx_col ( clean_indices ( j )) end do if ( this % with_headers ) then header_name = this % header ( i ) call clean_df % append ( cmplx_clean_col , trim ( header_name )) else call clean_df % append ( cmplx_clean_col ) end if deallocate ( cmplx_col ) deallocate ( cmplx_clean_col ) end select end do deallocate ( keep_mask ) deallocate ( clean_indices ) end function dropna","tags":"","url":"proc/dropna.html"},{"title":"duplicated – DataFort","text":"private  function duplicated(this) result(is_dup) Check which rows are duplicates Returns logical array where .true. indicates a duplicate row\n(first occurrence is not marked as duplicate) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical, dimension(:), allocatable Source Code function duplicated ( this ) result ( is_dup ) class ( data_frame ), intent ( in ) :: this logical , dimension (:), allocatable :: is_dup integer :: i , j , k , dtype logical :: rows_match allocate ( is_dup ( this % nrows ())) is_dup = . false . do i = 2 , this % nrows () do j = 1 , i - 1 rows_match = . true . ! Compare all columns do k = 1 , this % ncols () dtype = this % dtype ( k ) select case ( dtype ) case ( REAL_NUM ) if ( abs ( this % get_val_real ( k , i ) - this % get_val_real ( k , j )) >= 1.0e-10_rk ) then rows_match = . false . exit end if case ( INTEGER_NUM ) if ( this % get_val_integer ( k , i ) /= this % get_val_integer ( k , j )) then rows_match = . false . exit end if case ( LOGICAL_NUM ) if ( this % get_val_logical ( k , i ) . neqv . this % get_val_logical ( k , j )) then rows_match = . false . exit end if case ( CHARACTER_NUM ) if ( trim ( this % get_val_character ( k , i )) /= trim ( this % get_val_character ( k , j ))) then rows_match = . false . exit end if case ( COMPLEX_NUM ) if ( this % get_val_complex ( k , i ) /= this % get_val_complex ( k , j )) then rows_match = . false . exit end if end select end do if ( rows_match ) then is_dup ( i ) = . true . exit end if end do end do end function duplicated","tags":"","url":"proc/duplicated.html"},{"title":"empty – DataFort","text":"private pure function empty(this) result(is_empty) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical Source Code pure function empty ( this ) result ( is_empty ) class ( data_frame ), intent ( in ) :: this logical :: is_empty is_empty = ( this % nrows () == 0 . or . this % ncols () == 0 ) end function empty","tags":"","url":"proc/empty.html"},{"title":"filter_rows_integer_range – DataFort","text":"private  function filter_rows_integer_range(this, col_index, min_val, max_val) result(filtered_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in) :: min_val integer(kind=ik), intent(in) :: max_val Return Value type( data_frame ) Source Code function filter_rows_integer_range ( this , col_index , min_val , max_val ) result ( filtered_df ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index integer ( ik ), intent ( in ) :: min_val , max_val type ( data_frame ) :: filtered_df integer , dimension (:), allocatable :: selected_rows integer :: i , count , idx integer ( ik ) :: val if ( this % data_cols ( col_index )% get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" ! Count matching rows count = 0 do i = 1 , this % nrows () val = this % data_cols ( col_index )% geti ( i ) if ( val >= min_val . and . val <= max_val ) count = count + 1 end do ! Collect matching row indices allocate ( selected_rows ( count )) idx = 0 do i = 1 , this % nrows () val = this % data_cols ( col_index )% geti ( i ) if ( val >= min_val . and . val <= max_val ) then idx = idx + 1 selected_rows ( idx ) = i end if end do ! Create filtered dataframe call filtered_df % new ( this % max_char_len ) do i = 1 , this % num_cols call copy_filtered_column ( this , filtered_df , i , selected_rows ) end do deallocate ( selected_rows ) end function filter_rows_integer_range","tags":"","url":"proc/filter_rows_integer_range.html"},{"title":"filter_rows_logical – DataFort","text":"private  function filter_rows_logical(this, logical_col_index) result(new_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: logical_col_index Return Value type( data_frame ) Source Code function filter_rows_logical ( this , logical_col_index ) result ( new_df ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: logical_col_index type ( data_frame ) :: new_df logical , dimension (:), allocatable :: mask integer , allocatable :: selected_rows (:) integer :: i , count_true , idx if ( this % data_cols ( logical_col_index )% get_type () /= LOGICAL_NUM ) then error stop \"Column must be logical type for filtering\" end if mask = this % data_cols ( logical_col_index )% getl () count_true = count ( mask ) if ( count_true == 0 ) then call new_df % new ( this % max_char_len ) return end if ! Get indices of true values allocate ( selected_rows ( count_true )) idx = 1 do i = 1 , size ( mask ) if ( mask ( i )) then selected_rows ( idx ) = i idx = idx + 1 end if end do call new_df % new ( this % max_char_len ) ! Copy selected rows for each column do i = 1 , this % num_cols call copy_filtered_column ( this , new_df , i , selected_rows ) end do deallocate ( selected_rows ) end function filter_rows_logical","tags":"","url":"proc/filter_rows_logical.html"},{"title":"filter_rows_real_range – DataFort","text":"private  function filter_rows_real_range(this, col_index, min_val, max_val) result(filtered_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: min_val real(kind=rk), intent(in) :: max_val Return Value type( data_frame ) Source Code function filter_rows_real_range ( this , col_index , min_val , max_val ) result ( filtered_df ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: min_val , max_val type ( data_frame ) :: filtered_df integer , dimension (:), allocatable :: selected_rows integer :: i , count , idx real ( rk ) :: val if ( this % data_cols ( col_index )% get_type () /= REAL_NUM ) error stop \"column is not real type\" ! Count matching rows count = 0 do i = 1 , this % nrows () val = this % data_cols ( col_index )% getr ( i ) if ( val >= min_val . and . val <= max_val ) count = count + 1 end do ! Collect matching row indices allocate ( selected_rows ( count )) idx = 0 do i = 1 , this % nrows () val = this % data_cols ( col_index )% getr ( i ) if ( val >= min_val . and . val <= max_val ) then idx = idx + 1 selected_rows ( idx ) = i end if end do ! Create filtered dataframe call filtered_df % new ( this % max_char_len ) do i = 1 , this % num_cols call copy_filtered_column ( this , filtered_df , i , selected_rows ) end do deallocate ( selected_rows ) end function filter_rows_real_range","tags":"","url":"proc/filter_rows_real_range.html"},{"title":"filter_rows_string_pattern – DataFort","text":"private  function filter_rows_string_pattern(this, col_index, pattern) result(filtered_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index character(len=*), intent(in) :: pattern Return Value type( data_frame ) Source Code function filter_rows_string_pattern ( this , col_index , pattern ) result ( filtered_df ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index character ( len =* ), intent ( in ) :: pattern type ( data_frame ) :: filtered_df integer , dimension (:), allocatable :: selected_rows integer :: i , count , idx character ( len = :), allocatable :: val if ( this % data_cols ( col_index )% get_type () /= CHARACTER_NUM ) error stop \"column is not character type\" ! Count matching rows count = 0 do i = 1 , this % nrows () val = this % data_cols ( col_index )% getch ( i ) if ( index ( val , pattern ) > 0 ) count = count + 1 end do ! Collect matching row indices allocate ( selected_rows ( count )) idx = 0 do i = 1 , this % nrows () val = this % data_cols ( col_index )% getch ( i ) if ( index ( val , pattern ) > 0 ) then idx = idx + 1 selected_rows ( idx ) = i end if end do ! Create filtered dataframe call filtered_df % new ( this % max_char_len ) do i = 1 , this % num_cols call copy_filtered_column ( this , filtered_df , i , selected_rows ) end do deallocate ( selected_rows ) end function filter_rows_string_pattern","tags":"","url":"proc/filter_rows_string_pattern.html"},{"title":"find_header_index – DataFort","text":"private pure function find_header_index(this, header) result(index) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer Source Code pure function find_header_index ( this , header ) result ( index ) class ( data_frame ), intent ( in ) :: this character ( len =* ), intent ( in ) :: header integer :: index integer :: i character ( len = :), allocatable :: trimmed_header if (. not . this % with_headers ) error stop \"data frame has no headers\" trimmed_header = trim ( adjustl ( header )) index = - 1 do i = 1 , this % num_cols if ( trim ( adjustl ( this % headers ( i ))) == trimmed_header ) then index = i exit end if end do if ( index == - 1 ) error stop \"header not found\" end function find_header_index","tags":"","url":"proc/find_header_index.html"},{"title":"get_col_character – DataFort","text":"private  function get_col_character(this, index) result(col) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value character(len=:), dimension(:), allocatable Source Code function get_col_character ( this , index ) result ( col ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: index character ( len = :), dimension (:), allocatable :: col if ( index < 1 . or . index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( index )% get_type () /= CHARACTER_NUM ) error stop \"column is not character type\" col = this % data_cols ( index )% getch () end function get_col_character","tags":"","url":"proc/get_col_character.html"},{"title":"get_col_complex – DataFort","text":"private  function get_col_complex(this, index) result(col) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value complex(kind=rk), dimension(:), allocatable Source Code function get_col_complex ( this , index ) result ( col ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: index complex ( rk ), dimension (:), allocatable :: col if ( index < 1 . or . index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( index )% get_type () /= COMPLEX_NUM ) error stop \"column is not complex type\" col = this % data_cols ( index )% getc () end function get_col_complex","tags":"","url":"proc/get_col_complex.html"},{"title":"get_col_integer – DataFort","text":"private  function get_col_integer(this, index) result(col) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value integer(kind=ik), dimension(:), allocatable Source Code function get_col_integer ( this , index ) result ( col ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: index integer ( ik ), dimension (:), allocatable :: col if ( index < 1 . or . index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( index )% get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" col = this % data_cols ( index )% geti () end function get_col_integer","tags":"","url":"proc/get_col_integer.html"},{"title":"get_col_logical – DataFort","text":"private  function get_col_logical(this, index) result(col) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value logical, dimension(:), allocatable Source Code function get_col_logical ( this , index ) result ( col ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: index logical , dimension (:), allocatable :: col if ( index < 1 . or . index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( index )% get_type () /= LOGICAL_NUM ) error stop \"column is not logical type\" col = this % data_cols ( index )% getl () end function get_col_logical","tags":"","url":"proc/get_col_logical.html"},{"title":"get_col_real – DataFort","text":"private  function get_col_real(this, index) result(col) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value real(kind=rk), dimension(:), allocatable Source Code function get_col_real ( this , index ) result ( col ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: index real ( rk ), dimension (:), allocatable :: col if ( index < 1 . or . index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( index )% get_type () /= REAL_NUM ) error stop \"column is not real type\" col = this % data_cols ( index )% getr () end function get_col_real","tags":"","url":"proc/get_col_real.html"},{"title":"get_header – DataFort","text":"private  function get_header(this, index) result(header) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value character(len=:), allocatable Source Code function get_header ( this , index ) result ( header ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: index character ( len = :), allocatable :: header if (. not . this % with_headers ) error stop \"data frame has no headers\" if ( index < 1 . or . index > this % num_cols ) error stop \"header index out of range\" header = trim ( this % headers ( index )) end function get_header","tags":"","url":"proc/get_header.html"},{"title":"get_val_character – DataFort","text":"private  function get_val_character(this, col_index, row_index) result(val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value character(len=:), allocatable Source Code function get_val_character ( this , col_index , row_index ) result ( val ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index , row_index character ( len = :), allocatable :: val if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= CHARACTER_NUM ) error stop \"column is not character type\" val = this % data_cols ( col_index )% getch ( row_index ) end function get_val_character","tags":"","url":"proc/get_val_character.html"},{"title":"get_val_complex – DataFort","text":"private  function get_val_complex(this, col_index, row_index) result(val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value complex(kind=rk) Source Code function get_val_complex ( this , col_index , row_index ) result ( val ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index , row_index complex ( rk ) :: val if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= COMPLEX_NUM ) error stop \"column is not complex type\" val = this % data_cols ( col_index )% getc ( row_index ) end function get_val_complex","tags":"","url":"proc/get_val_complex.html"},{"title":"get_val_integer – DataFort","text":"private  function get_val_integer(this, col_index, row_index) result(val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value integer(kind=ik) Source Code function get_val_integer ( this , col_index , row_index ) result ( val ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index , row_index integer ( ik ) :: val if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" val = this % data_cols ( col_index )% geti ( row_index ) end function get_val_integer","tags":"","url":"proc/get_val_integer.html"},{"title":"get_val_logical – DataFort","text":"private  function get_val_logical(this, col_index, row_index) result(val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value logical Source Code function get_val_logical ( this , col_index , row_index ) result ( val ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index , row_index logical :: val if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= LOGICAL_NUM ) error stop \"column is not logical type\" val = this % data_cols ( col_index )% getl ( row_index ) end function get_val_logical","tags":"","url":"proc/get_val_logical.html"},{"title":"get_val_real – DataFort","text":"private  function get_val_real(this, col_index, row_index) result(val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value real(kind=rk) Source Code function get_val_real ( this , col_index , row_index ) result ( val ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index , row_index real ( rk ) :: val if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= REAL_NUM ) error stop \"column is not real type\" val = this % data_cols ( col_index )% getr ( row_index ) end function get_val_real","tags":"","url":"proc/get_val_real.html"},{"title":"head – DataFort","text":"private  function head(this, n) result(head_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: n Return Value type( data_frame ) Source Code function head ( this , n ) result ( head_df ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ), optional :: n type ( data_frame ) :: head_df integer :: num_rows if ( present ( n )) then num_rows = min ( n , this % nrows ()) else num_rows = min ( 6 , this % nrows ()) ! Default to 6 rows like pandas end if if ( num_rows == 0 . or . this % nrows () == 0 ) then call head_df % new ( this % max_char_len ) return end if head_df = this % slice_rows ( 1 , num_rows ) end function head","tags":"","url":"proc/head.html"},{"title":"inner_join – DataFort","text":"private  function inner_join(this, other, this_key_col, other_key_col) result(joined_df) Perform an inner join between two data frames Returns a new data frame containing only rows where the key columns match\nin both data frames. Similar to SQL INNER JOIN. @param[in] this The left data frame\n@param[in] other The right data frame\n@param[in] this_key_col Column index for join key in left data frame\n@param[in] other_key_col Column index for join key in right data frame\n@return A new data frame with matched rows from both tables Note Key columns must have the same data type (integer, real, or character) Note Right table columns are suffixed with “_right” to avoid name conflicts Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: this_key_col integer, intent(in) :: other_key_col Return Value type( data_frame ) Source Code function inner_join ( this , other , this_key_col , other_key_col ) result ( joined_df ) class ( data_frame ), intent ( in ) :: this , other integer , intent ( in ) :: this_key_col , other_key_col type ( data_frame ) :: joined_df integer :: i , j , this_dtype , other_dtype , num_matches integer , dimension (:), allocatable :: match_indices_this , match_indices_other logical :: match_found ! Check if key columns are compatible types this_dtype = this % dtype ( this_key_col ) other_dtype = other % dtype ( other_key_col ) if ( this_dtype /= other_dtype ) then print * , \"Error: Key columns must have the same data type\" call joined_df % new () return end if ! Count matches first num_matches = 0 do i = 1 , this % nrows () do j = 1 , other % nrows () match_found = . false . select case ( this_dtype ) case ( INTEGER_NUM ) if ( this % get_val_integer ( this_key_col , i ) == other % get_val_integer ( other_key_col , j )) then match_found = . true . end if case ( REAL_NUM ) if ( abs ( this % get_val_real ( this_key_col , i ) - other % get_val_real ( other_key_col , j )) < 1.0e-10_rk ) then match_found = . true . end if case ( CHARACTER_NUM ) if ( trim ( this % get_val_character ( this_key_col , i )) == trim ( other % get_val_character ( other_key_col , j ))) then match_found = . true . end if end select if ( match_found ) then num_matches = num_matches + 1 end if end do end do if ( num_matches == 0 ) then call joined_df % new () return end if ! Allocate arrays to store matching indices allocate ( match_indices_this ( num_matches )) allocate ( match_indices_other ( num_matches )) ! Find all matching pairs num_matches = 0 do i = 1 , this % nrows () do j = 1 , other % nrows () match_found = . false . select case ( this_dtype ) case ( INTEGER_NUM ) if ( this % get_val_integer ( this_key_col , i ) == other % get_val_integer ( other_key_col , j )) then match_found = . true . end if case ( REAL_NUM ) if ( abs ( this % get_val_real ( this_key_col , i ) - other % get_val_real ( other_key_col , j )) < 1.0e-10_rk ) then match_found = . true . end if case ( CHARACTER_NUM ) if ( trim ( this % get_val_character ( this_key_col , i )) == trim ( other % get_val_character ( other_key_col , j ))) then match_found = . true . end if end select if ( match_found ) then num_matches = num_matches + 1 match_indices_this ( num_matches ) = i match_indices_other ( num_matches ) = j end if end do end do ! Build the joined dataframe call build_joined_dataframe ( this , other , match_indices_this , match_indices_other , & num_matches , joined_df ) deallocate ( match_indices_this ) deallocate ( match_indices_other ) end function inner_join","tags":"","url":"proc/inner_join.html"},{"title":"is_sorted_integer – DataFort","text":"private  function is_sorted_integer(this, col_index, ascending) result(sorted) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value logical Source Code function is_sorted_integer ( this , col_index , ascending ) result ( sorted ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index logical , intent ( in ), optional :: ascending logical :: sorted integer ( ik ), dimension (:), allocatable :: col logical :: asc integer :: i asc = . true . if ( present ( ascending )) asc = ascending col = this % geti ( col_index ) sorted = . true . if ( asc ) then do i = 1 , size ( col ) - 1 if ( col ( i ) > col ( i + 1 )) then sorted = . false . return end if end do else do i = 1 , size ( col ) - 1 if ( col ( i ) < col ( i + 1 )) then sorted = . false . return end if end do end if end function is_sorted_integer","tags":"","url":"proc/is_sorted_integer.html"},{"title":"is_sorted_real – DataFort","text":"private  function is_sorted_real(this, col_index, ascending) result(sorted) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value logical Source Code function is_sorted_real ( this , col_index , ascending ) result ( sorted ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index logical , intent ( in ), optional :: ascending logical :: sorted real ( rk ), dimension (:), allocatable :: col logical :: asc integer :: i asc = . true . if ( present ( ascending )) asc = ascending col = this % getr ( col_index ) sorted = . true . if ( asc ) then do i = 1 , size ( col ) - 1 if ( col ( i ) > col ( i + 1 )) then sorted = . false . return end if end do else do i = 1 , size ( col ) - 1 if ( col ( i ) < col ( i + 1 )) then sorted = . false . return end if end do end if end function is_sorted_real","tags":"","url":"proc/is_sorted_real.html"},{"title":"isna_integer – DataFort","text":"private  function isna_integer(this, col_index) result(mask) Check for NaN values in an integer column Returns a logical array indicating which values are NaN (sentinel value) @param[in] this The data frame instance\n@param[in] col_index Column index to check\n@return Logical array where .true. indicates NaN Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value logical, dimension(:), allocatable Source Code function isna_integer ( this , col_index ) result ( mask ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index logical , dimension (:), allocatable :: mask integer ( ik ), dimension (:), allocatable :: col integer :: i col = this % geti ( col_index ) allocate ( mask ( size ( col ))) do i = 1 , size ( col ) mask ( i ) = is_nan_integer ( col ( i )) end do end function isna_integer","tags":"","url":"proc/isna_integer.html"},{"title":"isna_real – DataFort","text":"private  function isna_real(this, col_index) result(mask) Check for NaN values in a real column Returns a logical array indicating which values are NaN @param[in] this The data frame instance\n@param[in] col_index Column index to check\n@return Logical array where .true. indicates NaN Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value logical, dimension(:), allocatable Source Code function isna_real ( this , col_index ) result ( mask ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index logical , dimension (:), allocatable :: mask real ( rk ), dimension (:), allocatable :: col integer :: i col = this % getr ( col_index ) allocate ( mask ( size ( col ))) do i = 1 , size ( col ) mask ( i ) = is_nan_real ( col ( i )) end do end function isna_real","tags":"","url":"proc/isna_real.html"},{"title":"left_join – DataFort","text":"private  function left_join(this, other, this_key_col, other_key_col) result(joined_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: this_key_col integer, intent(in) :: other_key_col Return Value type( data_frame ) Source Code function left_join ( this , other , this_key_col , other_key_col ) result ( joined_df ) class ( data_frame ), intent ( in ) :: this , other integer , intent ( in ) :: this_key_col , other_key_col type ( data_frame ) :: joined_df integer :: i , j , this_dtype , other_dtype integer , dimension (:), allocatable :: match_indices_this , match_indices_other logical :: match_found integer :: num_rows this_dtype = this % dtype ( this_key_col ) other_dtype = other % dtype ( other_key_col ) if ( this_dtype /= other_dtype ) then print * , \"Error: Key columns must have the same data type\" call joined_df % new () return end if ! For left join, we need one row for each row in 'this', possibly more if multiple matches num_rows = 0 allocate ( match_indices_this ( this % nrows () * max ( 1 , other % nrows ()))) allocate ( match_indices_other ( this % nrows () * max ( 1 , other % nrows ()))) do i = 1 , this % nrows () match_found = . false . do j = 1 , other % nrows () select case ( this_dtype ) case ( INTEGER_NUM ) if ( this % get_val_integer ( this_key_col , i ) == other % get_val_integer ( other_key_col , j )) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = j match_found = . true . end if case ( REAL_NUM ) if ( abs ( this % get_val_real ( this_key_col , i ) - other % get_val_real ( other_key_col , j )) < 1.0e-10_rk ) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = j match_found = . true . end if case ( CHARACTER_NUM ) if ( trim ( this % get_val_character ( this_key_col , i )) == trim ( other % get_val_character ( other_key_col , j ))) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = j match_found = . true . end if end select end do ! If no match found, still include the row from 'this' with NULL for 'other' if (. not . match_found ) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = - 1 ! -1 indicates no match end if end do call build_joined_dataframe ( this , other , match_indices_this ( 1 : num_rows ), & match_indices_other ( 1 : num_rows ), num_rows , joined_df ) deallocate ( match_indices_this ) deallocate ( match_indices_other ) end function left_join","tags":"","url":"proc/left_join.html"},{"title":"max_integer – DataFort","text":"private  function max_integer(this, col_index) result(max_val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik) Source Code function max_integer ( this , col_index ) result ( max_val ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index integer ( ik ) :: max_val integer ( ik ), dimension (:), allocatable :: col col = this % geti ( col_index ) max_val = maxval ( col ) end function max_integer","tags":"","url":"proc/max_integer.html"},{"title":"max_real – DataFort","text":"private  function max_real(this, col_index) result(max_val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function max_real ( this , col_index ) result ( max_val ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ) :: max_val real ( rk ), dimension (:), allocatable :: col col = this % getr ( col_index ) max_val = maxval ( col ) end function max_real","tags":"","url":"proc/max_real.html"},{"title":"mean_integer – DataFort","text":"private  function mean_integer(this, col_index) result(avg) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function mean_integer ( this , col_index ) result ( avg ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ) :: avg integer ( ik ), dimension (:), allocatable :: col col = this % geti ( col_index ) avg = real ( sum ( col ), rk ) / real ( size ( col ), rk ) end function mean_integer","tags":"","url":"proc/mean_integer.html"},{"title":"mean_real – DataFort","text":"private  function mean_real(this, col_index) result(avg) Calculate the arithmetic mean of a real column Computes the average value of all elements in a real-valued column @param[in] this The data frame instance\n@param[in] col_index Index of the column (1-based)\n@return Mean value of the column Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function mean_real ( this , col_index ) result ( avg ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ) :: avg real ( rk ), dimension (:), allocatable :: col col = this % getr ( col_index ) avg = sum ( col ) / real ( size ( col ), rk ) end function mean_real","tags":"","url":"proc/mean_real.html"},{"title":"median_integer – DataFort","text":"private  function median_integer(this, col_index) result(med) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function median_integer ( this , col_index ) result ( med ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ) :: med integer ( ik ), dimension (:), allocatable :: col , sorted_col integer :: n , mid col = this % geti ( col_index ) n = size ( col ) sorted_col = col call quick_sort_integer ( sorted_col , 1 , n ) if ( mod ( n , 2 ) == 1 ) then mid = ( n + 1 ) / 2 med = real ( sorted_col ( mid ), rk ) else mid = n / 2 med = ( real ( sorted_col ( mid ), rk ) + real ( sorted_col ( mid + 1 ), rk )) / 2.0_rk end if end function median_integer","tags":"","url":"proc/median_integer.html"},{"title":"median_real – DataFort","text":"private  function median_real(this, col_index) result(med) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function median_real ( this , col_index ) result ( med ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ) :: med real ( rk ), dimension (:), allocatable :: col , sorted_col integer :: n , mid col = this % getr ( col_index ) n = size ( col ) sorted_col = col ! Simple bubble sort for median calculation call quick_sort_real ( sorted_col , 1 , n ) if ( mod ( n , 2 ) == 1 ) then mid = ( n + 1 ) / 2 med = sorted_col ( mid ) else mid = n / 2 med = ( sorted_col ( mid ) + sorted_col ( mid + 1 )) / 2.0_rk end if end function median_real","tags":"","url":"proc/median_real.html"},{"title":"merge – DataFort","text":"private  function merge(this, other, on_column, how) result(merged_df) Merge two dataframes on column names (similar to SQL join but using names) @param[in] this Left dataframe\n@param[in] other Right dataframe\n@param[in] on_column Name of column to join on\n@param[in] how Type of join: “inner”, “left”, “right”, “outer”\n@return Merged dataframe Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other character(len=*), intent(in) :: on_column character(len=*), intent(in) :: how Return Value type( data_frame ) Source Code function merge ( this , other , on_column , how ) result ( merged_df ) class ( data_frame ), intent ( in ) :: this , other character ( len =* ), intent ( in ) :: on_column , how type ( data_frame ) :: merged_df integer :: this_col_idx , other_col_idx ! Find column indices this_col_idx = this % find_header_index ( on_column ) other_col_idx = other % find_header_index ( on_column ) if ( this_col_idx == - 1 . or . other_col_idx == - 1 ) then print * , \"Error: Column '\" , trim ( on_column ), \"' not found in one or both dataframes\" call merged_df % new () return end if ! Perform appropriate join based on 'how' select case ( trim ( how )) case ( \"inner\" ) merged_df = this % inner_join ( other , this_col_idx , other_col_idx ) case ( \"left\" ) merged_df = this % left_join ( other , this_col_idx , other_col_idx ) case ( \"right\" ) merged_df = this % right_join ( other , this_col_idx , other_col_idx ) case ( \"outer\" ) merged_df = this % outer_join ( other , this_col_idx , other_col_idx ) case default print * , \"Error: 'how' must be 'inner', 'left', 'right', or 'outer'\" call merged_df % new () end select end function merge","tags":"","url":"proc/merge.html"},{"title":"min_integer – DataFort","text":"private  function min_integer(this, col_index) result(min_val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik) Source Code function min_integer ( this , col_index ) result ( min_val ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index integer ( ik ) :: min_val integer ( ik ), dimension (:), allocatable :: col col = this % geti ( col_index ) min_val = minval ( col ) end function min_integer","tags":"","url":"proc/min_integer.html"},{"title":"min_real – DataFort","text":"private  function min_real(this, col_index) result(min_val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function min_real ( this , col_index ) result ( min_val ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ) :: min_val real ( rk ), dimension (:), allocatable :: col col = this % getr ( col_index ) min_val = minval ( col ) end function min_real","tags":"","url":"proc/min_real.html"},{"title":"outer_join – DataFort","text":"private  function outer_join(this, other, this_key_col, other_key_col) result(joined_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: this_key_col integer, intent(in) :: other_key_col Return Value type( data_frame ) Source Code function outer_join ( this , other , this_key_col , other_key_col ) result ( joined_df ) class ( data_frame ), intent ( in ) :: this , other integer , intent ( in ) :: this_key_col , other_key_col type ( data_frame ) :: joined_df integer :: i , j , this_dtype , other_dtype integer , dimension (:), allocatable :: match_indices_this , match_indices_other logical , dimension (:), allocatable :: other_matched integer :: num_rows logical :: found_match this_dtype = this % dtype ( this_key_col ) other_dtype = other % dtype ( other_key_col ) if ( this_dtype /= other_dtype ) then print * , \"Error: Key columns must have the same data type\" call joined_df % new () return end if allocate ( other_matched ( other % nrows ())) other_matched = . false . num_rows = 0 allocate ( match_indices_this (( this % nrows () + other % nrows ()) * max ( 1 , max ( this % nrows (), other % nrows ())))) allocate ( match_indices_other (( this % nrows () + other % nrows ()) * max ( 1 , max ( this % nrows (), other % nrows ())))) ! First pass: all rows from 'this' with matches from 'other' do i = 1 , this % nrows () found_match = . false . do j = 1 , other % nrows () select case ( this_dtype ) case ( INTEGER_NUM ) if ( this % get_val_integer ( this_key_col , i ) == other % get_val_integer ( other_key_col , j )) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = j other_matched ( j ) = . true . found_match = . true . end if case ( REAL_NUM ) if ( abs ( this % get_val_real ( this_key_col , i ) - other % get_val_real ( other_key_col , j )) < 1.0e-10_rk ) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = j other_matched ( j ) = . true . found_match = . true . end if case ( CHARACTER_NUM ) if ( trim ( this % get_val_character ( this_key_col , i )) == trim ( other % get_val_character ( other_key_col , j ))) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = j other_matched ( j ) = . true . found_match = . true . end if end select end do if (. not . found_match ) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = - 1 end if end do ! Second pass: unmatched rows from 'other' do j = 1 , other % nrows () if (. not . other_matched ( j )) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = - 1 match_indices_other ( num_rows ) = j end if end do call build_joined_dataframe ( this , other , match_indices_this ( 1 : num_rows ), & match_indices_other ( 1 : num_rows ), num_rows , joined_df ) deallocate ( match_indices_this ) deallocate ( match_indices_other ) deallocate ( other_matched ) end function outer_join","tags":"","url":"proc/outer_join.html"},{"title":"partition_indices_integer – DataFort","text":"private  function partition_indices_integer(values, indices, low, high, ascending) result(pivot_idx) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending Return Value integer Source Code function partition_indices_integer ( values , indices , low , high , ascending ) result ( pivot_idx ) integer ( ik ), dimension (:), intent ( in ) :: values integer , dimension (:), intent ( inout ) :: indices integer , intent ( in ) :: low , high logical , intent ( in ) :: ascending integer :: pivot_idx integer ( ik ) :: pivot integer :: i , j , temp pivot = values ( indices ( high )) i = low - 1 do j = low , high - 1 if (( ascending . and . values ( indices ( j )) <= pivot ) . or . & (. not . ascending . and . values ( indices ( j )) >= pivot )) then i = i + 1 temp = indices ( i ) indices ( i ) = indices ( j ) indices ( j ) = temp end if end do temp = indices ( i + 1 ) indices ( i + 1 ) = indices ( high ) indices ( high ) = temp pivot_idx = i + 1 end function partition_indices_integer","tags":"","url":"proc/partition_indices_integer.html"},{"title":"partition_indices_real – DataFort","text":"private  function partition_indices_real(values, indices, low, high, ascending) result(pivot_idx) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending Return Value integer Source Code function partition_indices_real ( values , indices , low , high , ascending ) result ( pivot_idx ) real ( rk ), dimension (:), intent ( in ) :: values integer , dimension (:), intent ( inout ) :: indices integer , intent ( in ) :: low , high logical , intent ( in ) :: ascending integer :: pivot_idx real ( rk ) :: pivot integer :: i , j , temp pivot = values ( indices ( high )) i = low - 1 do j = low , high - 1 if (( ascending . and . values ( indices ( j )) <= pivot ) . or . & (. not . ascending . and . values ( indices ( j )) >= pivot )) then i = i + 1 temp = indices ( i ) indices ( i ) = indices ( j ) indices ( j ) = temp end if end do temp = indices ( i + 1 ) indices ( i + 1 ) = indices ( high ) indices ( high ) = temp pivot_idx = i + 1 end function partition_indices_real","tags":"","url":"proc/partition_indices_real.html"},{"title":"percentile_integer – DataFort","text":"private  function percentile_integer(this, col_index, percentile) result(perc) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: percentile Return Value real(kind=rk) Source Code function percentile_integer ( this , col_index , percentile ) result ( perc ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: percentile real ( rk ) :: perc integer ( ik ), dimension (:), allocatable :: col , sorted_col integer :: n , idx real ( rk ) :: pos if ( percentile < 0.0_rk . or . percentile > 10 0.0_rk ) error stop \"percentile must be between 0 and 100\" col = this % geti ( col_index ) n = size ( col ) sorted_col = col call quick_sort_integer ( sorted_col , 1 , n ) pos = ( percentile / 10 0.0_rk ) * real ( n - 1 , rk ) + 1.0_rk idx = int ( pos ) if ( idx >= n ) then perc = real ( sorted_col ( n ), rk ) else if ( idx < 1 ) then perc = real ( sorted_col ( 1 ), rk ) else ! Linear interpolation perc = real ( sorted_col ( idx ), rk ) + ( pos - real ( idx , rk )) * & ( real ( sorted_col ( idx + 1 ), rk ) - real ( sorted_col ( idx ), rk )) end if end function percentile_integer","tags":"","url":"proc/percentile_integer.html"},{"title":"percentile_real – DataFort","text":"private  function percentile_real(this, col_index, percentile) result(perc) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: percentile Return Value real(kind=rk) Source Code function percentile_real ( this , col_index , percentile ) result ( perc ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: percentile real ( rk ) :: perc real ( rk ), dimension (:), allocatable :: col , sorted_col integer :: n , idx real ( rk ) :: pos if ( percentile < 0.0_rk . or . percentile > 10 0.0_rk ) error stop \"percentile must be between 0 and 100\" col = this % getr ( col_index ) n = size ( col ) sorted_col = col call quick_sort_real ( sorted_col , 1 , n ) pos = ( percentile / 10 0.0_rk ) * real ( n - 1 , rk ) + 1.0_rk idx = int ( pos ) if ( idx >= n ) then perc = sorted_col ( n ) else if ( idx < 1 ) then perc = sorted_col ( 1 ) else ! Linear interpolation perc = sorted_col ( idx ) + ( pos - real ( idx , rk )) * ( sorted_col ( idx + 1 ) - sorted_col ( idx )) end if end function percentile_real","tags":"","url":"proc/percentile_real.html"},{"title":"rank_integer – DataFort","text":"private  function rank_integer(this, col_index, ascending) result(ranks) Rank values in an integer column Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value integer(kind=ik), dimension(:), allocatable Source Code function rank_integer ( this , col_index , ascending ) result ( ranks ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index logical , intent ( in ), optional :: ascending integer ( ik ), dimension (:), allocatable :: ranks integer ( ik ), dimension (:), allocatable :: col , sorted_col integer :: i , j , n logical :: asc asc = . true . if ( present ( ascending )) asc = ascending col = this % geti ( col_index ) n = size ( col ) allocate ( ranks ( n )) allocate ( sorted_col ( n )) sorted_col = col call quick_sort_integer ( sorted_col , 1 , n ) if (. not . asc ) then sorted_col = sorted_col ( n : 1 : - 1 ) end if do i = 1 , n do j = 1 , n if ( col ( i ) == sorted_col ( j )) then ranks ( i ) = j exit end if end do end do deallocate ( sorted_col ) end function rank_integer","tags":"","url":"proc/rank_integer.html"},{"title":"rank_real – DataFort","text":"private  function rank_real(this, col_index, ascending) result(ranks) Rank values in a real column @param[in] this The dataframe\n@param[in] col_index Column to rank\n@param[in] ascending Rank in ascending order (default .true.)\n@return Integer array of ranks (1 = smallest/largest) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value integer(kind=ik), dimension(:), allocatable Source Code function rank_real ( this , col_index , ascending ) result ( ranks ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index logical , intent ( in ), optional :: ascending integer ( ik ), dimension (:), allocatable :: ranks real ( rk ), dimension (:), allocatable :: col , sorted_col integer :: i , j , n logical :: asc asc = . true . if ( present ( ascending )) asc = ascending col = this % getr ( col_index ) n = size ( col ) allocate ( ranks ( n )) allocate ( sorted_col ( n )) sorted_col = col call quick_sort_real ( sorted_col , 1 , n ) if (. not . asc ) then ! Reverse for descending sorted_col = sorted_col ( n : 1 : - 1 ) end if do i = 1 , n do j = 1 , n if ( abs ( col ( i ) - sorted_col ( j )) < 1.0e-10_rk ) then ranks ( i ) = j exit end if end do end do deallocate ( sorted_col ) end function rank_real","tags":"","url":"proc/rank_real.html"},{"title":"right_join – DataFort","text":"private  function right_join(this, other, this_key_col, other_key_col) result(joined_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: this_key_col integer, intent(in) :: other_key_col Return Value type( data_frame ) Source Code function right_join ( this , other , this_key_col , other_key_col ) result ( joined_df ) class ( data_frame ), intent ( in ) :: this , other integer , intent ( in ) :: this_key_col , other_key_col type ( data_frame ) :: joined_df ! Right join is just a left join with arguments swapped joined_df = other % left_join ( this , other_key_col , this_key_col ) end function right_join","tags":"","url":"proc/right_join.html"},{"title":"sample – DataFort","text":"private  function sample(this, n, seed) result(sampled_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: n integer, intent(in), optional :: seed Return Value type( data_frame ) Source Code function sample ( this , n , seed ) result ( sampled_df ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ), optional :: seed type ( data_frame ) :: sampled_df integer , dimension (:), allocatable :: indices , selected_indices , seed_array integer :: i , j , temp , num_samples , seed_size real :: rand_val num_samples = min ( n , this % nrows ()) if ( num_samples == 0 ) then call sampled_df % new ( this % max_char_len ) return end if ! Initialize random seed if provided if ( present ( seed )) then call random_seed ( size = seed_size ) allocate ( seed_array ( seed_size )) seed_array = seed call random_seed ( put = seed_array ) deallocate ( seed_array ) end if ! Create array of all indices allocate ( indices ( this % nrows ())) do i = 1 , this % nrows () indices ( i ) = i end do ! Fisher-Yates shuffle to get random sample do i = this % nrows (), 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = indices ( i ) indices ( i ) = indices ( j ) indices ( j ) = temp end do ! Take first n shuffled indices allocate ( selected_indices ( num_samples )) selected_indices = indices ( 1 : num_samples ) ! Create sampled dataframe call sampled_df % new ( this % max_char_len ) do i = 1 , this % num_cols call copy_filtered_column ( this , sampled_df , i , selected_indices ) end do deallocate ( indices , selected_indices ) end function sample","tags":"","url":"proc/sample.html"},{"title":"select_columns – DataFort","text":"private  function select_columns(this, column_indices) result(new_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), dimension(:) :: column_indices Return Value type( data_frame ) Source Code function select_columns ( this , column_indices ) result ( new_df ) class ( data_frame ), intent ( in ) :: this integer , dimension (:), intent ( in ) :: column_indices type ( data_frame ) :: new_df integer :: i , col_idx call new_df % new ( this % max_char_len ) do i = 1 , size ( column_indices ) col_idx = column_indices ( i ) if ( col_idx < 1 . or . col_idx > this % num_cols ) then error stop \"Column index out of range in select_columns\" end if select case ( this % data_cols ( col_idx )% get_type ()) case ( REAL_NUM ) if ( this % with_headers ) then call new_df % append ( this % data_cols ( col_idx )% getr (), this % headers ( col_idx )) else call new_df % append ( this % data_cols ( col_idx )% getr ()) end if case ( INTEGER_NUM ) if ( this % with_headers ) then call new_df % append ( this % data_cols ( col_idx )% geti (), this % headers ( col_idx )) else call new_df % append ( this % data_cols ( col_idx )% geti ()) end if case ( LOGICAL_NUM ) if ( this % with_headers ) then call new_df % append ( this % data_cols ( col_idx )% getl (), this % headers ( col_idx )) else call new_df % append ( this % data_cols ( col_idx )% getl ()) end if case ( CHARACTER_NUM ) if ( this % with_headers ) then call new_df % append ( this % data_cols ( col_idx )% getch (), this % headers ( col_idx )) else call new_df % append ( this % data_cols ( col_idx )% getch ()) end if case ( COMPLEX_NUM ) if ( this % with_headers ) then call new_df % append ( this % data_cols ( col_idx )% getc (), this % headers ( col_idx )) else call new_df % append ( this % data_cols ( col_idx )% getc ()) end if end select end do end function select_columns","tags":"","url":"proc/select_columns.html"},{"title":"shape – DataFort","text":"private  function shape(this) result(dims) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer, dimension(2) Source Code function shape ( this ) result ( dims ) class ( data_frame ), intent ( in ) :: this integer , dimension ( 2 ) :: dims dims ( 1 ) = this % nrows () dims ( 2 ) = this % ncols () end function shape","tags":"","url":"proc/shape.html"},{"title":"slice_rows – DataFort","text":"private  function slice_rows(this, start_row, end_row) result(new_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: start_row integer, intent(in) :: end_row Return Value type( data_frame ) Source Code function slice_rows ( this , start_row , end_row ) result ( new_df ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: start_row , end_row type ( data_frame ) :: new_df integer :: i , j , new_size real ( rk ), allocatable :: real_slice (:) integer ( ik ), allocatable :: int_slice (:) logical , allocatable :: logical_slice (:) character ( len = :), allocatable :: char_slice (:) complex ( rk ), allocatable :: complex_slice (:) if ( start_row < 1 . or . end_row > this % nrows () . or . start_row > end_row ) then error stop \"Invalid row range in slice_rows\" end if new_size = end_row - start_row + 1 call new_df % new ( this % max_char_len ) do i = 1 , this % num_cols select case ( this % data_cols ( i )% get_type ()) case ( REAL_NUM ) allocate ( real_slice ( new_size )) do j = 1 , new_size real_slice ( j ) = this % data_cols ( i )% getr ( start_row + j - 1 ) end do if ( this % with_headers ) then call new_df % append ( real_slice , this % headers ( i )) else call new_df % append ( real_slice ) end if deallocate ( real_slice ) case ( INTEGER_NUM ) allocate ( int_slice ( new_size )) do j = 1 , new_size int_slice ( j ) = this % data_cols ( i )% geti ( start_row + j - 1 ) end do if ( this % with_headers ) then call new_df % append ( int_slice , this % headers ( i )) else call new_df % append ( int_slice ) end if deallocate ( int_slice ) case ( LOGICAL_NUM ) allocate ( logical_slice ( new_size )) do j = 1 , new_size logical_slice ( j ) = this % data_cols ( i )% getl ( start_row + j - 1 ) end do if ( this % with_headers ) then call new_df % append ( logical_slice , this % headers ( i )) else call new_df % append ( logical_slice ) end if deallocate ( logical_slice ) case ( CHARACTER_NUM ) allocate ( character ( len = len ( this % data_cols ( i )% getch ( 1 ))) :: char_slice ( new_size )) do j = 1 , new_size char_slice ( j ) = this % data_cols ( i )% getch ( start_row + j - 1 ) end do if ( this % with_headers ) then call new_df % append ( char_slice , this % headers ( i )) else call new_df % append ( char_slice ) end if deallocate ( char_slice ) case ( COMPLEX_NUM ) allocate ( complex_slice ( new_size )) do j = 1 , new_size complex_slice ( j ) = this % data_cols ( i )% getc ( start_row + j - 1 ) end do if ( this % with_headers ) then call new_df % append ( complex_slice , this % headers ( i )) else call new_df % append ( complex_slice ) end if deallocate ( complex_slice ) end select end do end function slice_rows","tags":"","url":"proc/slice_rows.html"},{"title":"std_integer – DataFort","text":"private  function std_integer(this, col_index) result(stddev) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function std_integer ( this , col_index ) result ( stddev ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ) :: stddev integer ( ik ), dimension (:), allocatable :: col real ( rk ) :: avg col = this % geti ( col_index ) avg = this % mean_integer ( col_index ) stddev = sqrt ( sum (( real ( col , rk ) - avg ) ** 2 ) / real ( size ( col ) - 1 , rk )) end function std_integer","tags":"","url":"proc/std_integer.html"},{"title":"std_real – DataFort","text":"private  function std_real(this, col_index) result(stddev) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function std_real ( this , col_index ) result ( stddev ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ) :: stddev real ( rk ), dimension (:), allocatable :: col real ( rk ) :: avg col = this % getr ( col_index ) avg = this % mean_real ( col_index ) stddev = sqrt ( sum (( col - avg ) ** 2 ) / real ( size ( col ) - 1 , rk )) end function std_real","tags":"","url":"proc/std_real.html"},{"title":"sum_integer – DataFort","text":"private  function sum_integer(this, col_index) result(total) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik) Source Code function sum_integer ( this , col_index ) result ( total ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index integer ( ik ) :: total integer ( ik ), dimension (:), allocatable :: col col = this % geti ( col_index ) total = sum ( col ) end function sum_integer","tags":"","url":"proc/sum_integer.html"},{"title":"sum_real – DataFort","text":"private  function sum_real(this, col_index) result(total) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function sum_real ( this , col_index ) result ( total ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ) :: total real ( rk ), dimension (:), allocatable :: col col = this % getr ( col_index ) total = sum ( col ) end function sum_real","tags":"","url":"proc/sum_real.html"},{"title":"tail – DataFort","text":"private  function tail(this, n) result(tail_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: n Return Value type( data_frame ) Source Code function tail ( this , n ) result ( tail_df ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ), optional :: n type ( data_frame ) :: tail_df integer :: num_rows , start_row if ( present ( n )) then num_rows = min ( n , this % nrows ()) else num_rows = min ( 6 , this % nrows ()) ! Default to 6 rows like pandas end if if ( num_rows == 0 . or . this % nrows () == 0 ) then call tail_df % new ( this % max_char_len ) return end if start_row = this % nrows () - num_rows + 1 tail_df = this % slice_rows ( start_row , this % nrows ()) end function tail","tags":"","url":"proc/tail.html"},{"title":"transpose – DataFort","text":"private  function transpose(this) result(transposed_df) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value type( data_frame ) Source Code function transpose ( this ) result ( transposed_df ) class ( data_frame ), intent ( in ) :: this type ( data_frame ) :: transposed_df integer :: i , j character ( len = 50 ), dimension (:), allocatable :: row_data character ( len = 20 ) :: temp_str call transposed_df % new () ! Add headers as first column if present if ( this % with_headers ) then call transposed_df % append ( this % headers , \"Headers\" ) end if ! Add each row as a column do i = 1 , this % nrows () allocate ( row_data ( this % num_cols )) do j = 1 , this % num_cols select case ( this % data_cols ( j )% get_type ()) case ( REAL_NUM ) write ( temp_str , '(f0.6)' ) this % data_cols ( j )% getr ( i ) row_data ( j ) = trim ( temp_str ) case ( INTEGER_NUM ) write ( temp_str , '(i0)' ) this % data_cols ( j )% geti ( i ) row_data ( j ) = trim ( temp_str ) case ( LOGICAL_NUM ) if ( this % data_cols ( j )% getl ( i )) then row_data ( j ) = \"T\" else row_data ( j ) = \"F\" end if case ( CHARACTER_NUM ) row_data ( j ) = this % data_cols ( j )% getch ( i ) case ( COMPLEX_NUM ) write ( temp_str , '(\"(\",f0.3,\",\",f0.3,\")\")' ) this % data_cols ( j )% getc ( i ) row_data ( j ) = trim ( temp_str ) end select end do write ( temp_str , '(\"Row_\",i0)' ) i call transposed_df % append ( row_data , trim ( temp_str )) deallocate ( row_data ) end do end function transpose","tags":"","url":"proc/transpose.html"},{"title":"unique_character – DataFort","text":"private  function unique_character(this, col_index) result(unique_vals) Get unique values from a character column Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value character(len=:), allocatable, (:) Source Code function unique_character ( this , col_index ) result ( unique_vals ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index character ( len = :), allocatable :: unique_vals (:) character ( len = :), allocatable :: col (:), temp_unique (:) integer :: i , j , n_unique logical :: is_unique col = this % getch ( col_index ) allocate ( character ( len = len ( col )) :: temp_unique ( size ( col ))) n_unique = 0 do i = 1 , size ( col ) is_unique = . true . do j = 1 , n_unique if ( trim ( col ( i )) == trim ( temp_unique ( j ))) then is_unique = . false . exit end if end do if ( is_unique ) then n_unique = n_unique + 1 temp_unique ( n_unique ) = col ( i ) end if end do allocate ( character ( len = len ( col )) :: unique_vals ( n_unique )) unique_vals = temp_unique ( 1 : n_unique ) deallocate ( temp_unique ) end function unique_character","tags":"","url":"proc/unique_character.html"},{"title":"unique_integer – DataFort","text":"private  function unique_integer(this, col_index) result(unique_vals) Get unique values from an integer column Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik), dimension(:), allocatable Source Code function unique_integer ( this , col_index ) result ( unique_vals ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index integer ( ik ), dimension (:), allocatable :: unique_vals integer ( ik ), dimension (:), allocatable :: col , temp_unique integer :: i , j , n_unique logical :: is_unique col = this % geti ( col_index ) allocate ( temp_unique ( size ( col ))) n_unique = 0 do i = 1 , size ( col ) is_unique = . true . do j = 1 , n_unique if ( col ( i ) == temp_unique ( j )) then is_unique = . false . exit end if end do if ( is_unique ) then n_unique = n_unique + 1 temp_unique ( n_unique ) = col ( i ) end if end do allocate ( unique_vals ( n_unique )) unique_vals = temp_unique ( 1 : n_unique ) ! Sort unique values call quick_sort_integer ( unique_vals , 1 , n_unique ) deallocate ( temp_unique ) end function unique_integer","tags":"","url":"proc/unique_integer.html"},{"title":"unique_real – DataFort","text":"private  function unique_real(this, col_index) result(unique_vals) Get unique values from a real column @param[in] this The data frame instance\n@param[in] col_index Column index\n@return Array of unique values (sorted) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk), dimension(:), allocatable Source Code function unique_real ( this , col_index ) result ( unique_vals ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: unique_vals real ( rk ), dimension (:), allocatable :: col , temp_unique integer :: i , j , n_unique logical :: is_unique col = this % getr ( col_index ) allocate ( temp_unique ( size ( col ))) n_unique = 0 do i = 1 , size ( col ) is_unique = . true . do j = 1 , n_unique if ( abs ( col ( i ) - temp_unique ( j )) < 1.0e-10_rk ) then is_unique = . false . exit end if end do if ( is_unique ) then n_unique = n_unique + 1 temp_unique ( n_unique ) = col ( i ) end if end do allocate ( unique_vals ( n_unique )) unique_vals = temp_unique ( 1 : n_unique ) ! Sort unique values call quick_sort_real ( unique_vals , 1 , n_unique ) deallocate ( temp_unique ) end function unique_real","tags":"","url":"proc/unique_real.html"},{"title":"value_counts_character – DataFort","text":"private  function value_counts_character(this, col_index) result(counts_df) Count occurrences of each value in a character column Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value type( data_frame ) Source Code function value_counts_character ( this , col_index ) result ( counts_df ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index type ( data_frame ) :: counts_df character ( len = :), allocatable :: col (:), unique_vals (:) integer ( ik ), dimension (:), allocatable :: counts integer :: i , j unique_vals = this % unique_character ( col_index ) allocate ( counts ( size ( unique_vals ))) counts = 0 col = this % getch ( col_index ) do i = 1 , size ( col ) do j = 1 , size ( unique_vals ) if ( trim ( col ( i )) == trim ( unique_vals ( j ))) then counts ( j ) = counts ( j ) + 1 exit end if end do end do call counts_df % new () call counts_df % append ( unique_vals , \"Value\" ) call counts_df % append ( counts , \"Count\" ) end function value_counts_character","tags":"","url":"proc/value_counts_character.html"},{"title":"value_counts_integer – DataFort","text":"private  function value_counts_integer(this, col_index) result(counts_df) Count occurrences of each value in an integer column Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value type( data_frame ) Source Code function value_counts_integer ( this , col_index ) result ( counts_df ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index type ( data_frame ) :: counts_df integer ( ik ), dimension (:), allocatable :: col , unique_vals , counts integer :: i , j unique_vals = this % unique_integer ( col_index ) allocate ( counts ( size ( unique_vals ))) counts = 0 col = this % geti ( col_index ) do i = 1 , size ( col ) do j = 1 , size ( unique_vals ) if ( col ( i ) == unique_vals ( j )) then counts ( j ) = counts ( j ) + 1 exit end if end do end do call counts_df % new () call counts_df % append ( unique_vals , \"Value\" ) call counts_df % append ( counts , \"Count\" ) end function value_counts_integer","tags":"","url":"proc/value_counts_integer.html"},{"title":"value_counts_real – DataFort","text":"private  function value_counts_real(this, col_index) result(counts_df) Count occurrences of each value in a real column Returns a dataframe with two columns: unique values and their counts Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value type( data_frame ) Source Code function value_counts_real ( this , col_index ) result ( counts_df ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index type ( data_frame ) :: counts_df real ( rk ), dimension (:), allocatable :: col , unique_vals integer ( ik ), dimension (:), allocatable :: counts integer :: i , j unique_vals = this % unique_real ( col_index ) allocate ( counts ( size ( unique_vals ))) counts = 0 col = this % getr ( col_index ) do i = 1 , size ( col ) do j = 1 , size ( unique_vals ) if ( abs ( col ( i ) - unique_vals ( j )) < 1.0e-10_rk ) then counts ( j ) = counts ( j ) + 1 exit end if end do end do call counts_df % new () call counts_df % append ( unique_vals , \"Value\" ) call counts_df % append ( counts , \"Count\" ) end function value_counts_real","tags":"","url":"proc/value_counts_real.html"},{"title":"variance_integer – DataFort","text":"private  function variance_integer(this, col_index) result(var) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function variance_integer ( this , col_index ) result ( var ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ) :: var integer ( ik ), dimension (:), allocatable :: col real ( rk ) :: avg col = this % geti ( col_index ) avg = this % mean_integer ( col_index ) var = sum (( real ( col , rk ) - avg ) ** 2 ) / real ( size ( col ) - 1 , rk ) end function variance_integer","tags":"","url":"proc/variance_integer.html"},{"title":"variance_real – DataFort","text":"private  function variance_real(this, col_index) result(var) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function variance_real ( this , col_index ) result ( var ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: col_index real ( rk ) :: var real ( rk ), dimension (:), allocatable :: col real ( rk ) :: avg col = this % getr ( col_index ) avg = this % mean_real ( col_index ) var = sum (( col - avg ) ** 2 ) / real ( size ( col ) - 1 , rk ) end function variance_real","tags":"","url":"proc/variance_real.html"},{"title":"abs_column_integer – DataFort","text":"private  subroutine abs_column_integer(this, col_index) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index Source Code subroutine abs_column_integer ( this , col_index ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index integer ( ik ), dimension (:), allocatable :: col col = this % geti ( col_index ) col = abs ( col ) call this % seti ( col_index , col ) end subroutine abs_column_integer","tags":"","url":"proc/abs_column_integer.html"},{"title":"abs_column_real – DataFort","text":"private  subroutine abs_column_real(this, col_index) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index Source Code subroutine abs_column_real ( this , col_index ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col col = this % getr ( col_index ) col = abs ( col ) call this % setr ( col_index , col ) end subroutine abs_column_real","tags":"","url":"proc/abs_column_real.html"},{"title":"add_col_character – DataFort","text":"private  subroutine add_col_character(this, col, header) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header Source Code subroutine add_col_character ( this , col , header ) class ( data_frame ), intent ( inout ) :: this character ( len =* ), dimension (:), intent ( in ) :: col character ( len =* ), intent ( in ), optional :: header call this % validate_column_addition ( header , size ( col )) call this % resize_storage () this % num_cols = this % num_cols + 1 call this % data_cols ( this % num_cols )% new ( col ) if ( present ( header )) then this % headers ( this % num_cols ) = header end if end subroutine add_col_character","tags":"","url":"proc/add_col_character.html"},{"title":"add_col_complex – DataFort","text":"private  subroutine add_col_complex(this, col, header) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header Source Code subroutine add_col_complex ( this , col , header ) class ( data_frame ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: col character ( len =* ), intent ( in ), optional :: header call this % validate_column_addition ( header , size ( col )) call this % resize_storage () this % num_cols = this % num_cols + 1 call this % data_cols ( this % num_cols )% new ( col ) if ( present ( header )) then this % headers ( this % num_cols ) = header end if end subroutine add_col_complex","tags":"","url":"proc/add_col_complex.html"},{"title":"add_col_integer – DataFort","text":"private  subroutine add_col_integer(this, col, header) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header Source Code subroutine add_col_integer ( this , col , header ) class ( data_frame ), intent ( inout ) :: this integer ( ik ), dimension (:), intent ( in ) :: col character ( len =* ), intent ( in ), optional :: header call this % validate_column_addition ( header , size ( col )) call this % resize_storage () this % num_cols = this % num_cols + 1 call this % data_cols ( this % num_cols )% new ( col ) if ( present ( header )) then this % headers ( this % num_cols ) = header end if end subroutine add_col_integer","tags":"","url":"proc/add_col_integer.html"},{"title":"add_col_logical – DataFort","text":"private  subroutine add_col_logical(this, col, header) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this logical, intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header Source Code subroutine add_col_logical ( this , col , header ) class ( data_frame ), intent ( inout ) :: this logical , dimension (:), intent ( in ) :: col character ( len =* ), intent ( in ), optional :: header call this % validate_column_addition ( header , size ( col )) call this % resize_storage () this % num_cols = this % num_cols + 1 call this % data_cols ( this % num_cols )% new ( col ) if ( present ( header )) then this % headers ( this % num_cols ) = header end if end subroutine add_col_logical","tags":"","url":"proc/add_col_logical.html"},{"title":"add_col_real – DataFort","text":"private  subroutine add_col_real(this, col, header) Append a real-valued column to the data frame Adds a new column of real numbers to the data frame with optional header @param[in,out] this The data frame instance\n@param[in] col Array of real values to append\n@param[in] header Optional column name (if not provided, no header is set) Warning All columns must have the same number of rows Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header Source Code subroutine add_col_real ( this , col , header ) class ( data_frame ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: col character ( len =* ), intent ( in ), optional :: header call this % validate_column_addition ( header , size ( col )) call this % resize_storage () this % num_cols = this % num_cols + 1 call this % data_cols ( this % num_cols )% new ( col ) if ( present ( header )) then this % headers ( this % num_cols ) = header end if end subroutine add_col_real","tags":"","url":"proc/add_col_real.html"},{"title":"add_csv_column – DataFort","text":"private  subroutine add_csv_column(df, data_strings, headers, col_index, has_headers) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: df character(len=*), intent(in), dimension(:) :: data_strings character(len=*), intent(in), optional, dimension(:) :: headers integer, intent(in) :: col_index logical, intent(in) :: has_headers Source Code subroutine add_csv_column ( df , data_strings , headers , col_index , has_headers ) class ( data_frame ), intent ( inout ) :: df character ( len =* ), dimension (:), intent ( in ) :: data_strings character ( len =* ), dimension (:), intent ( in ), optional :: headers integer , intent ( in ) :: col_index logical , intent ( in ) :: has_headers integer :: data_type , i , iostat real ( rk ), allocatable :: real_data (:) integer ( ik ), allocatable :: int_data (:) logical , allocatable :: logical_data (:) real ( rk ) :: real_val integer ( ik ) :: int_val logical :: logical_val character ( len = 100 ) :: trimmed_str ! Initialize NaN constant if needed call init_nan () ! Detect data type from first non-empty, non-NaN value data_type = CHARACTER_NUM do i = 1 , size ( data_strings ) trimmed_str = trim ( adjustl ( data_strings ( i ))) ! Skip empty strings and common NaN representations if ( len ( trim ( trimmed_str )) == 0 . or . & trimmed_str == \"NaN\" . or . trimmed_str == \"nan\" . or . & trimmed_str == \"NA\" . or . trimmed_str == \"na\" . or . & trimmed_str == \"NULL\" . or . trimmed_str == \"null\" . or . & trimmed_str == \"N/A\" . or . trimmed_str == \"n/a\" . or . & trimmed_str == \"-\" . or . trimmed_str == \"\" ) then cycle end if ! Try integer first read ( data_strings ( i ), * , iostat = iostat ) int_val if ( iostat == 0 ) then data_type = INTEGER_NUM exit end if ! Try real read ( data_strings ( i ), * , iostat = iostat ) real_val if ( iostat == 0 ) then data_type = REAL_NUM exit end if ! Try logical if ( trimmed_str == \"T\" . or . trimmed_str == \"F\" . or . & trimmed_str == \"true\" . or . trimmed_str == \"false\" . or . & trimmed_str == \".true.\" . or . trimmed_str == \".false.\" ) then data_type = LOGICAL_NUM exit end if ! Default to character exit end do ! Convert and add the column select case ( data_type ) case ( INTEGER_NUM ) allocate ( int_data ( size ( data_strings ))) do i = 1 , size ( data_strings ) trimmed_str = trim ( adjustl ( data_strings ( i ))) ! Check for NaN representations if ( len ( trim ( trimmed_str )) == 0 . or . & trimmed_str == \"NaN\" . or . trimmed_str == \"nan\" . or . & trimmed_str == \"NA\" . or . trimmed_str == \"na\" . or . & trimmed_str == \"NULL\" . or . trimmed_str == \"null\" . or . & trimmed_str == \"N/A\" . or . trimmed_str == \"n/a\" . or . & trimmed_str == \"-\" ) then int_data ( i ) = NaN_ik else read ( data_strings ( i ), * , iostat = iostat ) int_data ( i ) if ( iostat /= 0 ) int_data ( i ) = NaN_ik ! Use NaN for invalid data end if end do if ( has_headers . and . present ( headers )) then call df % append ( int_data , headers ( col_index )) else call df % append ( int_data ) end if case ( REAL_NUM ) allocate ( real_data ( size ( data_strings ))) do i = 1 , size ( data_strings ) trimmed_str = trim ( adjustl ( data_strings ( i ))) ! Check for NaN representations if ( len ( trim ( trimmed_str )) == 0 . or . & trimmed_str == \"NaN\" . or . trimmed_str == \"nan\" . or . & trimmed_str == \"NA\" . or . trimmed_str == \"na\" . or . & trimmed_str == \"NULL\" . or . trimmed_str == \"null\" . or . & trimmed_str == \"N/A\" . or . trimmed_str == \"n/a\" . or . & trimmed_str == \"-\" ) then real_data ( i ) = NaN_rk else read ( data_strings ( i ), * , iostat = iostat ) real_data ( i ) if ( iostat /= 0 ) real_data ( i ) = NaN_rk ! Use NaN for invalid data end if end do if ( has_headers . and . present ( headers )) then call df % append ( real_data , headers ( col_index )) else call df % append ( real_data ) end if case ( LOGICAL_NUM ) allocate ( logical_data ( size ( data_strings ))) do i = 1 , size ( data_strings ) select case ( trim ( adjustl ( data_strings ( i )))) case ( \"T\" , \"true\" , \".true.\" ) logical_data ( i ) = . true . case ( \"F\" , \"false\" , \".false.\" ) logical_data ( i ) = . false . case default logical_data ( i ) = . false . ! Default for invalid data end select end do if ( has_headers . and . present ( headers )) then call df % append ( logical_data , headers ( col_index )) else call df % append ( logical_data ) end if case default ! CHARACTER_NUM if ( has_headers . and . present ( headers )) then call df % append ( data_strings , headers ( col_index )) else call df % append ( data_strings ) end if end select end subroutine add_csv_column","tags":"","url":"proc/add_csv_column.html"},{"title":"build_joined_dataframe – DataFort","text":"private  subroutine build_joined_dataframe(df1, df2, indices1, indices2, num_rows, result_df) Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in), dimension(:) :: indices1 integer, intent(in), dimension(:) :: indices2 integer, intent(in) :: num_rows type( data_frame ), intent(out) :: result_df Source Code subroutine build_joined_dataframe ( df1 , df2 , indices1 , indices2 , num_rows , result_df ) type ( data_frame ), intent ( in ) :: df1 , df2 integer , dimension (:), intent ( in ) :: indices1 , indices2 integer , intent ( in ) :: num_rows type ( data_frame ), intent ( out ) :: result_df integer :: i , j , row , col_idx , dtype real ( rk ), dimension (:), allocatable :: real_col integer ( ik ), dimension (:), allocatable :: int_col logical , dimension (:), allocatable :: log_col character ( len = :), allocatable :: char_col (:) complex ( rk ), dimension (:), allocatable :: cmplx_col character ( len = 100 ) :: header_name call result_df % new ( max ( df1 % max_char_len , df2 % max_char_len )) ! Add columns from df1 do i = 1 , df1 % ncols () dtype = df1 % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) allocate ( real_col ( num_rows )) do row = 1 , num_rows if ( indices1 ( row ) > 0 ) then real_col ( row ) = df1 % get_val_real ( i , indices1 ( row )) else real_col ( row ) = 0.0_rk ! NULL value end if end do if ( df1 % with_headers ) then header_name = df1 % header ( i ) call result_df % append ( real_col , trim ( header_name )) else call result_df % append ( real_col ) end if deallocate ( real_col ) case ( INTEGER_NUM ) allocate ( int_col ( num_rows )) do row = 1 , num_rows if ( indices1 ( row ) > 0 ) then int_col ( row ) = df1 % get_val_integer ( i , indices1 ( row )) else int_col ( row ) = 0_ik ! NULL value end if end do if ( df1 % with_headers ) then header_name = df1 % header ( i ) call result_df % append ( int_col , trim ( header_name )) else call result_df % append ( int_col ) end if deallocate ( int_col ) case ( LOGICAL_NUM ) allocate ( log_col ( num_rows )) do row = 1 , num_rows if ( indices1 ( row ) > 0 ) then log_col ( row ) = df1 % get_val_logical ( i , indices1 ( row )) else log_col ( row ) = . false . ! NULL value end if end do if ( df1 % with_headers ) then header_name = df1 % header ( i ) call result_df % append ( log_col , trim ( header_name )) else call result_df % append ( log_col ) end if deallocate ( log_col ) case ( CHARACTER_NUM ) allocate ( character ( len = df1 % max_char_len ) :: char_col ( num_rows )) do row = 1 , num_rows if ( indices1 ( row ) > 0 ) then char_col ( row ) = df1 % get_val_character ( i , indices1 ( row )) else char_col ( row ) = \"NULL\" end if end do if ( df1 % with_headers ) then header_name = df1 % header ( i ) call result_df % append ( char_col , trim ( header_name )) else call result_df % append ( char_col ) end if deallocate ( char_col ) case ( COMPLEX_NUM ) allocate ( cmplx_col ( num_rows )) do row = 1 , num_rows if ( indices1 ( row ) > 0 ) then cmplx_col ( row ) = df1 % get_val_complex ( i , indices1 ( row )) else cmplx_col ( row ) = cmplx ( 0.0_rk , 0.0_rk , rk ) end if end do if ( df1 % with_headers ) then header_name = df1 % header ( i ) call result_df % append ( cmplx_col , trim ( header_name )) else call result_df % append ( cmplx_col ) end if deallocate ( cmplx_col ) end select end do ! Add columns from df2 do i = 1 , df2 % ncols () dtype = df2 % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) allocate ( real_col ( num_rows )) do row = 1 , num_rows if ( indices2 ( row ) > 0 ) then real_col ( row ) = df2 % get_val_real ( i , indices2 ( row )) else real_col ( row ) = 0.0_rk end if end do if ( df2 % with_headers ) then header_name = df2 % header ( i ) call result_df % append ( real_col , trim ( header_name ) // \"_right\" ) else call result_df % append ( real_col ) end if deallocate ( real_col ) case ( INTEGER_NUM ) allocate ( int_col ( num_rows )) do row = 1 , num_rows if ( indices2 ( row ) > 0 ) then int_col ( row ) = df2 % get_val_integer ( i , indices2 ( row )) else int_col ( row ) = 0_ik end if end do if ( df2 % with_headers ) then header_name = df2 % header ( i ) call result_df % append ( int_col , trim ( header_name ) // \"_right\" ) else call result_df % append ( int_col ) end if deallocate ( int_col ) case ( LOGICAL_NUM ) allocate ( log_col ( num_rows )) do row = 1 , num_rows if ( indices2 ( row ) > 0 ) then log_col ( row ) = df2 % get_val_logical ( i , indices2 ( row )) else log_col ( row ) = . false . end if end do if ( df2 % with_headers ) then header_name = df2 % header ( i ) call result_df % append ( log_col , trim ( header_name ) // \"_right\" ) else call result_df % append ( log_col ) end if deallocate ( log_col ) case ( CHARACTER_NUM ) allocate ( character ( len = df2 % max_char_len ) :: char_col ( num_rows )) do row = 1 , num_rows if ( indices2 ( row ) > 0 ) then char_col ( row ) = df2 % get_val_character ( i , indices2 ( row )) else char_col ( row ) = \"NULL\" end if end do if ( df2 % with_headers ) then header_name = df2 % header ( i ) call result_df % append ( char_col , trim ( header_name ) // \"_right\" ) else call result_df % append ( char_col ) end if deallocate ( char_col ) case ( COMPLEX_NUM ) allocate ( cmplx_col ( num_rows )) do row = 1 , num_rows if ( indices2 ( row ) > 0 ) then cmplx_col ( row ) = df2 % get_val_complex ( i , indices2 ( row )) else cmplx_col ( row ) = cmplx ( 0.0_rk , 0.0_rk , rk ) end if end do if ( df2 % with_headers ) then header_name = df2 % header ( i ) call result_df % append ( cmplx_col , trim ( header_name ) // \"_right\" ) else call result_df % append ( cmplx_col ) end if deallocate ( cmplx_col ) end select end do end subroutine build_joined_dataframe","tags":"","url":"proc/build_joined_dataframe.html"},{"title":"clear – DataFort","text":"private  subroutine clear(this) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this Source Code subroutine clear ( this ) class ( data_frame ), intent ( inout ) :: this integer :: saved_char_len saved_char_len = this % max_char_len call this % destroy () call this % new ( saved_char_len ) end subroutine clear","tags":"","url":"proc/clear.html"},{"title":"clip_integer – DataFort","text":"private  subroutine clip_integer(this, col_index, min_val, max_val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in) :: min_val integer(kind=ik), intent(in) :: max_val Source Code subroutine clip_integer ( this , col_index , min_val , max_val ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index integer ( ik ), intent ( in ) :: min_val , max_val integer ( ik ), dimension (:), allocatable :: col integer :: i col = this % geti ( col_index ) do i = 1 , size ( col ) col ( i ) = max ( min_val , min ( max_val , col ( i ))) end do call this % seti ( col_index , col ) end subroutine clip_integer","tags":"","url":"proc/clip_integer.html"},{"title":"clip_real – DataFort","text":"private  subroutine clip_real(this, col_index, min_val, max_val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: min_val real(kind=rk), intent(in) :: max_val Source Code subroutine clip_real ( this , col_index , min_val , max_val ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: min_val , max_val real ( rk ), dimension (:), allocatable :: col integer :: i col = this % getr ( col_index ) do i = 1 , size ( col ) col ( i ) = max ( min_val , min ( max_val , col ( i ))) end do call this % setr ( col_index , col ) end subroutine clip_real","tags":"","url":"proc/clip_real.html"},{"title":"copy_filtered_column – DataFort","text":"private  subroutine copy_filtered_column(source_df, target_df, col_index, selected_rows) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: source_df class( data_frame ), intent(inout) :: target_df integer, intent(in) :: col_index integer, intent(in), dimension(:) :: selected_rows Source Code subroutine copy_filtered_column ( source_df , target_df , col_index , selected_rows ) class ( data_frame ), intent ( in ) :: source_df class ( data_frame ), intent ( inout ) :: target_df integer , intent ( in ) :: col_index integer , dimension (:), intent ( in ) :: selected_rows integer :: i , n_selected real ( rk ), allocatable :: real_filtered (:) integer ( ik ), allocatable :: int_filtered (:) logical , allocatable :: logical_filtered (:) character ( len = :), allocatable :: char_filtered (:) complex ( rk ), allocatable :: complex_filtered (:) n_selected = size ( selected_rows ) select case ( source_df % data_cols ( col_index )% get_type ()) case ( REAL_NUM ) allocate ( real_filtered ( n_selected )) do i = 1 , n_selected real_filtered ( i ) = source_df % data_cols ( col_index )% getr ( selected_rows ( i )) end do if ( source_df % with_headers ) then call target_df % append ( real_filtered , source_df % headers ( col_index )) else call target_df % append ( real_filtered ) end if deallocate ( real_filtered ) case ( INTEGER_NUM ) allocate ( int_filtered ( n_selected )) do i = 1 , n_selected int_filtered ( i ) = source_df % data_cols ( col_index )% geti ( selected_rows ( i )) end do if ( source_df % with_headers ) then call target_df % append ( int_filtered , source_df % headers ( col_index )) else call target_df % append ( int_filtered ) end if deallocate ( int_filtered ) case ( LOGICAL_NUM ) allocate ( logical_filtered ( n_selected )) do i = 1 , n_selected logical_filtered ( i ) = source_df % data_cols ( col_index )% getl ( selected_rows ( i )) end do if ( source_df % with_headers ) then call target_df % append ( logical_filtered , source_df % headers ( col_index )) else call target_df % append ( logical_filtered ) end if deallocate ( logical_filtered ) case ( CHARACTER_NUM ) allocate ( character ( len = len ( source_df % data_cols ( col_index )% getch ( 1 ))) :: char_filtered ( n_selected )) do i = 1 , n_selected char_filtered ( i ) = source_df % data_cols ( col_index )% getch ( selected_rows ( i )) end do if ( source_df % with_headers ) then call target_df % append ( char_filtered , source_df % headers ( col_index )) else call target_df % append ( char_filtered ) end if deallocate ( char_filtered ) case ( COMPLEX_NUM ) allocate ( complex_filtered ( n_selected )) do i = 1 , n_selected complex_filtered ( i ) = source_df % data_cols ( col_index )% getc ( selected_rows ( i )) end do if ( source_df % with_headers ) then call target_df % append ( complex_filtered , source_df % headers ( col_index )) else call target_df % append ( complex_filtered ) end if deallocate ( complex_filtered ) end select end subroutine copy_filtered_column","tags":"","url":"proc/copy_filtered_column.html"},{"title":"cumsum_integer – DataFort","text":"private  subroutine cumsum_integer(this, col_index) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index Source Code subroutine cumsum_integer ( this , col_index ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index integer ( ik ), dimension (:), allocatable :: col integer :: i col = this % geti ( col_index ) do i = 2 , size ( col ) col ( i ) = col ( i ) + col ( i - 1 ) end do call this % seti ( col_index , col ) end subroutine cumsum_integer","tags":"","url":"proc/cumsum_integer.html"},{"title":"cumsum_real – DataFort","text":"private  subroutine cumsum_real(this, col_index) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index Source Code subroutine cumsum_real ( this , col_index ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col integer :: i col = this % getr ( col_index ) do i = 2 , size ( col ) col ( i ) = col ( i ) + col ( i - 1 ) end do call this % setr ( col_index , col ) end subroutine cumsum_real","tags":"","url":"proc/cumsum_real.html"},{"title":"describe_numeric – DataFort","text":"private  subroutine describe_numeric(this, unit) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: unit Source Code subroutine describe_numeric ( this , unit ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ), optional :: unit integer :: out_unit , i , dtype character ( len = 25 ) :: col_name if ( present ( unit )) then out_unit = unit else out_unit = 6 ! stdout end if write ( out_unit , '(a)' ) \"\" write ( out_unit , '(a)' ) repeat ( '=' , 80 ) write ( out_unit , '(a)' ) \"Numeric Column Statistics\" write ( out_unit , '(a)' ) repeat ( '=' , 80 ) write ( out_unit , '(a)' ) \"\" do i = 1 , this % num_cols dtype = this % data_cols ( i )% get_type () ! Only process real and integer columns if ( dtype == REAL_NUM . or . dtype == INTEGER_NUM ) then if ( this % with_headers ) then col_name = trim ( this % headers ( i )) else write ( col_name , '(a,i0)' ) \"Column \" , i end if write ( out_unit , '(a)' ) trim ( col_name ) write ( out_unit , '(a)' ) repeat ( '-' , len ( trim ( col_name ))) if ( dtype == REAL_NUM ) then write ( out_unit , '(a,f12.4)' ) \"  Count:       \" , real ( this % nrows (), rk ) write ( out_unit , '(a,f12.4)' ) \"  Mean:        \" , this % mean_real ( i ) write ( out_unit , '(a,f12.4)' ) \"  Std Dev:     \" , this % std_real ( i ) write ( out_unit , '(a,f12.4)' ) \"  Min:         \" , this % min_real ( i ) write ( out_unit , '(a,f12.4)' ) \"  25%:         \" , this % percentile_real ( i , 2 5.0_rk ) write ( out_unit , '(a,f12.4)' ) \"  Median (50%):\" , this % median_real ( i ) write ( out_unit , '(a,f12.4)' ) \"  75%:         \" , this % percentile_real ( i , 7 5.0_rk ) write ( out_unit , '(a,f12.4)' ) \"  Max:         \" , this % max_real ( i ) else ! INTEGER_NUM write ( out_unit , '(a,i12)' ) \"  Count:       \" , this % nrows () write ( out_unit , '(a,f12.2)' ) \"  Mean:        \" , this % mean_integer ( i ) write ( out_unit , '(a,f12.2)' ) \"  Std Dev:     \" , this % std_integer ( i ) write ( out_unit , '(a,i12)' ) \"  Min:         \" , this % min_integer ( i ) write ( out_unit , '(a,f12.2)' ) \"  25%:         \" , this % percentile_integer ( i , 2 5.0_rk ) write ( out_unit , '(a,f12.2)' ) \"  Median (50%):\" , this % median_integer ( i ) write ( out_unit , '(a,f12.2)' ) \"  75%:         \" , this % percentile_integer ( i , 7 5.0_rk ) write ( out_unit , '(a,i12)' ) \"  Max:         \" , this % max_integer ( i ) end if write ( out_unit , '(a)' ) \"\" end if end do write ( out_unit , '(a)' ) repeat ( '=' , 80 ) end subroutine describe_numeric","tags":"","url":"proc/describe_numeric.html"},{"title":"df_constructor – DataFort","text":"private  subroutine df_constructor(this, char_len) Initialize a new data frame Creates a new empty data frame with optional character length specification @param[in,out] this The data frame instance\n@param[in] char_len Optional maximum character length for string columns (default: 100) Note If the data frame is already initialized, it will be destroyed first Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), optional :: char_len Source Code subroutine df_constructor ( this , char_len ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ), optional :: char_len if ( this % initialized ) call this % destroy () this % num_cols = 0 this % with_headers = . false . if ( present ( char_len )) then this % max_char_len = char_len else this % max_char_len = MAX_CHAR_LEN_DEFAULT end if this % initialized = . true . end subroutine df_constructor","tags":"","url":"proc/df_constructor.html"},{"title":"df_destructor – DataFort","text":"private  subroutine df_destructor(this) Destroy a data frame and free all memory Deallocates all columns and resets the data frame to uninitialized state @param[in,out] this The data frame instance Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this Source Code subroutine df_destructor ( this ) class ( data_frame ), intent ( inout ) :: this integer :: i if ( allocated ( this % data_cols )) then do i = 1 , size ( this % data_cols ) call this % data_cols ( i )% destroy () end do deallocate ( this % data_cols ) end if if ( allocated ( this % headers )) deallocate ( this % headers ) this % num_cols = 0 this % with_headers = . false . this % initialized = . false . end subroutine df_destructor","tags":"","url":"proc/df_destructor.html"},{"title":"drop_column – DataFort","text":"private  subroutine drop_column(this, col_index) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index Source Code subroutine drop_column ( this , col_index ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index integer :: i type ( column ), dimension (:), allocatable :: temp_cols character ( len = :), dimension (:), allocatable :: temp_headers if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" ! Create temporary arrays without the dropped column allocate ( temp_cols ( this % num_cols - 1 )) if ( this % with_headers ) allocate ( character ( len = len ( this % headers )) :: temp_headers ( this % num_cols - 1 )) ! Copy columns before the dropped one do i = 1 , col_index - 1 temp_cols ( i ) = this % data_cols ( i ) if ( this % with_headers ) temp_headers ( i ) = this % headers ( i ) end do ! Copy columns after the dropped one do i = col_index + 1 , this % num_cols temp_cols ( i - 1 ) = this % data_cols ( i ) if ( this % with_headers ) temp_headers ( i - 1 ) = this % headers ( i ) end do ! Destroy the dropped column call this % data_cols ( col_index )% destroy () ! Replace arrays deallocate ( this % data_cols ) this % data_cols = temp_cols this % num_cols = this % num_cols - 1 if ( this % with_headers ) then deallocate ( this % headers ) this % headers = temp_headers end if end subroutine drop_column","tags":"","url":"proc/drop_column.html"},{"title":"exp_column – DataFort","text":"private  subroutine exp_column(this, col_index) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index Source Code subroutine exp_column ( this , col_index ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col col = this % getr ( col_index ) col = exp ( col ) call this % setr ( col_index , col ) end subroutine exp_column","tags":"","url":"proc/exp_column.html"},{"title":"fillna_integer – DataFort","text":"private  subroutine fillna_integer(this, col_index, fill_value) Replace NaN values in an integer column with a fill value Replaces all NaN sentinel values in the specified column with the given value @param[in,out] this The data frame instance\n@param[in] col_index Column index to fill\n@param[in] fill_value Value to replace NaN with Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in) :: fill_value Source Code subroutine fillna_integer ( this , col_index , fill_value ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index integer ( ik ), intent ( in ) :: fill_value integer ( ik ), dimension (:), allocatable :: col integer :: i col = this % geti ( col_index ) do i = 1 , size ( col ) if ( is_nan_integer ( col ( i ))) then col ( i ) = fill_value end if end do call this % seti ( col_index , col ) end subroutine fillna_integer","tags":"","url":"proc/fillna_integer.html"},{"title":"fillna_real – DataFort","text":"private  subroutine fillna_real(this, col_index, fill_value) Replace NaN values in a real column with a fill value Replaces all NaN values in the specified column with the given value @param[in,out] this The data frame instance\n@param[in] col_index Column index to fill\n@param[in] fill_value Value to replace NaN with Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: fill_value Source Code subroutine fillna_real ( this , col_index , fill_value ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: fill_value real ( rk ), dimension (:), allocatable :: col integer :: i col = this % getr ( col_index ) do i = 1 , size ( col ) if ( is_nan_real ( col ( i ))) then col ( i ) = fill_value end if end do call this % setr ( col_index , col ) end subroutine fillna_real","tags":"","url":"proc/fillna_real.html"},{"title":"info – DataFort","text":"private  subroutine info(this, unit) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: unit Source Code subroutine info ( this , unit ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ), optional :: unit integer :: out_unit , i , dtype character ( len = 20 ) :: type_name integer , dimension ( 2 ) :: dims if ( present ( unit )) then out_unit = unit else out_unit = 6 ! stdout end if dims = this % shape () write ( out_unit , '(a)' ) repeat ( '=' , 60 ) write ( out_unit , '(a)' ) 'DataFrame Information' write ( out_unit , '(a)' ) repeat ( '=' , 60 ) write ( out_unit , '(a,i0,a,i0,a)' ) 'Shape: (' , dims ( 1 ), ' rows, ' , dims ( 2 ), ' columns)' write ( out_unit , '(a,l1)' ) 'Has headers: ' , this % with_headers if ( this % num_cols > 0 ) then write ( out_unit , '(a)' ) '' write ( out_unit , '(a)' ) 'Columns:' write ( out_unit , '(a)' ) repeat ( '-' , 60 ) do i = 1 , this % num_cols dtype = this % data_cols ( i )% get_type () select case ( dtype ) case ( REAL_NUM ) type_name = 'real' case ( INTEGER_NUM ) type_name = 'integer' case ( LOGICAL_NUM ) type_name = 'logical' case ( CHARACTER_NUM ) type_name = 'character' case ( COMPLEX_NUM ) type_name = 'complex' case default type_name = 'unknown' end select if ( this % with_headers ) then write ( out_unit , '(i4,2a,t30,3a)' ) i , '. ' , trim ( this % headers ( i )), & '(' , trim ( type_name ), ')' else write ( out_unit , '(i4,2a,a)' ) i , '. Column (' , trim ( type_name ), ')' end if end do end if write ( out_unit , '(a)' ) repeat ( '=' , 60 ) end subroutine info","tags":"","url":"proc/info.html"},{"title":"log_column – DataFort","text":"private  subroutine log_column(this, col_index) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index Source Code subroutine log_column ( this , col_index ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col col = this % getr ( col_index ) col = log ( col ) call this % setr ( col_index , col ) end subroutine log_column","tags":"","url":"proc/log_column.html"},{"title":"normalize_column_real – DataFort","text":"private  subroutine normalize_column_real(this, col_index) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index Source Code subroutine normalize_column_real ( this , col_index ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col real ( rk ) :: min_val , max_val , range integer :: i col = this % getr ( col_index ) min_val = this % min_real ( col_index ) max_val = this % max_real ( col_index ) range = max_val - min_val if ( range > 0.0_rk ) then do i = 1 , size ( col ) col ( i ) = ( col ( i ) - min_val ) / range end do call this % setr ( col_index , col ) end if end subroutine normalize_column_real","tags":"","url":"proc/normalize_column_real.html"},{"title":"parse_csv_line – DataFort","text":"private  subroutine parse_csv_line(line, fields) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=100), intent(out), allocatable :: fields (:) Source Code subroutine parse_csv_line ( line , fields ) character ( len =* ), intent ( in ) :: line character ( len = 100 ), allocatable , intent ( out ) :: fields (:) integer :: i , start , field_count , len_line logical :: in_quotes , is_delimiter character ( len = 100 ) :: temp_fields ( 50 ) ! Max 50 fields character ( len = :), allocatable :: trimmed_line trimmed_line = trim ( line ) len_line = len ( trimmed_line ) if ( len_line == 0 ) then allocate ( fields ( 0 )) return end if field_count = 0 start = 1 in_quotes = . false . do i = 1 , len_line + 1 is_delimiter = . false . ! Check for quotes within bounds if ( i <= len_line ) then if ( trimmed_line ( i : i ) == '\"' ) then in_quotes = . not . in_quotes cycle end if ! Check if current character is a delimiter if ( trimmed_line ( i : i ) == ',' . and . . not . in_quotes ) then is_delimiter = . true . end if end if ! Process field if we hit a delimiter or end of line if ( i > len_line . or . is_delimiter ) then field_count = field_count + 1 if ( field_count > 50 ) error stop \"Too many fields in CSV line\" ! Extract the field if ( i == start . or . start > len_line ) then temp_fields ( field_count ) = \"\" else if ( i > len_line ) then temp_fields ( field_count ) = trim ( adjustl ( trimmed_line ( start : len_line ))) else temp_fields ( field_count ) = trim ( adjustl ( trimmed_line ( start : i - 1 ))) end if ! Remove surrounding quotes if present if ( len ( trim ( temp_fields ( field_count ))) >= 2 ) then if ( temp_fields ( field_count )( 1 : 1 ) == '\"' . and . & temp_fields ( field_count )( len ( trim ( temp_fields ( field_count ))): len ( trim ( temp_fields ( field_count )))) == '\"' ) then temp_fields ( field_count ) = temp_fields ( field_count )( 2 : len ( trim ( temp_fields ( field_count ))) - 1 ) end if end if end if start = i + 1 end if end do allocate ( fields ( field_count )) fields = temp_fields ( 1 : field_count ) end subroutine parse_csv_line","tags":"","url":"proc/parse_csv_line.html"},{"title":"pow_column – DataFort","text":"private  subroutine pow_column(this, col_index, power) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: power Source Code subroutine pow_column ( this , col_index , power ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: power real ( rk ), dimension (:), allocatable :: col col = this % getr ( col_index ) col = col ** power call this % setr ( col_index , col ) end subroutine pow_column","tags":"","url":"proc/pow_column.html"},{"title":"quicksort_indices_integer – DataFort","text":"private recursive subroutine quicksort_indices_integer(values, indices, low, high, ascending) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending Source Code recursive subroutine quicksort_indices_integer ( values , indices , low , high , ascending ) integer ( ik ), dimension (:), intent ( in ) :: values integer , dimension (:), intent ( inout ) :: indices integer , intent ( in ) :: low , high logical , intent ( in ) :: ascending integer :: pivot_idx if ( low < high ) then pivot_idx = partition_indices_integer ( values , indices , low , high , ascending ) call quicksort_indices_integer ( values , indices , low , pivot_idx - 1 , ascending ) call quicksort_indices_integer ( values , indices , pivot_idx + 1 , high , ascending ) end if end subroutine quicksort_indices_integer","tags":"","url":"proc/quicksort_indices_integer.html"},{"title":"quicksort_indices_real – DataFort","text":"private recursive subroutine quicksort_indices_real(values, indices, low, high, ascending) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending Source Code recursive subroutine quicksort_indices_real ( values , indices , low , high , ascending ) real ( rk ), dimension (:), intent ( in ) :: values integer , dimension (:), intent ( inout ) :: indices integer , intent ( in ) :: low , high logical , intent ( in ) :: ascending integer :: pivot_idx if ( low < high ) then pivot_idx = partition_indices_real ( values , indices , low , high , ascending ) call quicksort_indices_real ( values , indices , low , pivot_idx - 1 , ascending ) call quicksort_indices_real ( values , indices , pivot_idx + 1 , high , ascending ) end if end subroutine quicksort_indices_real","tags":"","url":"proc/quicksort_indices_real.html"},{"title":"read_csv – DataFort","text":"private  subroutine read_csv(this, filename, has_headers) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this character(len=*), intent(in) :: filename logical, intent(in) :: has_headers Source Code subroutine read_csv ( this , filename , has_headers ) class ( data_frame ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename logical , intent ( in ) :: has_headers integer :: unit , iostat , num_lines , num_cols , i , j character ( len = 1000 ) :: line character ( len = 100 ), allocatable :: fields (:), headers (:) character ( len = 100 ), allocatable :: all_data (:,:) ! Open file open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = iostat ) if ( iostat /= 0 ) error stop \"Cannot open CSV file\" ! Count lines num_lines = 0 do read ( unit , '(a)' , iostat = iostat ) line if ( iostat /= 0 ) exit num_lines = num_lines + 1 end do rewind ( unit ) if ( num_lines == 0 ) then close ( unit ) error stop \"Empty CSV file\" end if ! Read first line to determine number of columns read ( unit , '(a)' , iostat = iostat ) line if ( iostat /= 0 ) then close ( unit ) error stop \"Cannot read CSV file\" end if call parse_csv_line ( line , fields ) num_cols = size ( fields ) ! Allocate storage if ( has_headers ) then allocate ( headers ( num_cols )) allocate ( all_data ( num_lines - 1 , num_cols )) headers = fields else allocate ( all_data ( num_lines , num_cols )) all_data ( 1 , :) = fields rewind ( unit ) read ( unit , '(a)' ) line ! skip the line we already processed end if ! Read remaining data do i = 1 , size ( all_data , 1 ) read ( unit , '(a)' , iostat = iostat ) line if ( iostat /= 0 ) exit call parse_csv_line ( line , fields ) if ( size ( fields ) /= num_cols ) then close ( unit ) error stop \"Inconsistent number of columns in CSV\" end if all_data ( i , :) = fields end do close ( unit ) ! Initialize data frame call this % new () ! Add columns with automatic type detection do j = 1 , num_cols call add_csv_column ( this , all_data (:, j ), headers , j , has_headers ) end do deallocate ( fields , all_data ) if ( allocated ( headers )) deallocate ( headers ) end subroutine read_csv","tags":"","url":"proc/read_csv.html"},{"title":"rename_column – DataFort","text":"private  subroutine rename_column(this, col_index, new_name) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index character(len=*), intent(in) :: new_name Source Code subroutine rename_column ( this , col_index , new_name ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index character ( len =* ), intent ( in ) :: new_name if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if (. not . this % with_headers ) error stop \"data frame has no headers to rename\" this % headers ( col_index ) = new_name end subroutine rename_column","tags":"","url":"proc/rename_column.html"},{"title":"reorder_all_columns – DataFort","text":"private  subroutine reorder_all_columns(this, indices) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), dimension(:) :: indices Source Code subroutine reorder_all_columns ( this , indices ) class ( data_frame ), intent ( inout ) :: this integer , dimension (:), intent ( in ) :: indices integer :: i , j real ( rk ), allocatable :: real_temp (:) integer ( ik ), allocatable :: int_temp (:) logical , allocatable :: logical_temp (:) character ( len = :), allocatable :: char_temp (:) complex ( rk ), allocatable :: complex_temp (:) do i = 1 , this % num_cols select case ( this % data_cols ( i )% get_type ()) case ( REAL_NUM ) allocate ( real_temp ( this % nrows ())) do j = 1 , this % nrows () real_temp ( j ) = this % data_cols ( i )% getr ( indices ( j )) end do call this % data_cols ( i )% destroy () call this % data_cols ( i )% new ( real_temp ) deallocate ( real_temp ) case ( INTEGER_NUM ) allocate ( int_temp ( this % nrows ())) do j = 1 , this % nrows () int_temp ( j ) = this % data_cols ( i )% geti ( indices ( j )) end do call this % data_cols ( i )% destroy () call this % data_cols ( i )% new ( int_temp ) deallocate ( int_temp ) case ( LOGICAL_NUM ) allocate ( logical_temp ( this % nrows ())) do j = 1 , this % nrows () logical_temp ( j ) = this % data_cols ( i )% getl ( indices ( j )) end do call this % data_cols ( i )% destroy () call this % data_cols ( i )% new ( logical_temp ) deallocate ( logical_temp ) case ( CHARACTER_NUM ) allocate ( character ( len = len ( this % data_cols ( i )% getch ( 1 ))) :: char_temp ( this % nrows ())) do j = 1 , this % nrows () char_temp ( j ) = this % data_cols ( i )% getch ( indices ( j )) end do call this % data_cols ( i )% destroy () call this % data_cols ( i )% new ( char_temp ) deallocate ( char_temp ) case ( COMPLEX_NUM ) allocate ( complex_temp ( this % nrows ())) do j = 1 , this % nrows () complex_temp ( j ) = this % data_cols ( i )% getc ( indices ( j )) end do call this % data_cols ( i )% destroy () call this % data_cols ( i )% new ( complex_temp ) deallocate ( complex_temp ) end select end do end subroutine reorder_all_columns","tags":"","url":"proc/reorder_all_columns.html"},{"title":"reorder_columns – DataFort","text":"private  subroutine reorder_columns(this, new_order) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), dimension(:) :: new_order Source Code subroutine reorder_columns ( this , new_order ) class ( data_frame ), intent ( inout ) :: this integer , dimension (:), intent ( in ) :: new_order integer :: i type ( column ), dimension (:), allocatable :: temp_cols character ( len = :), dimension (:), allocatable :: temp_headers if ( size ( new_order ) /= this % num_cols ) error stop \"new_order size must equal number of columns\" ! Validate indices do i = 1 , size ( new_order ) if ( new_order ( i ) < 1 . or . new_order ( i ) > this % num_cols ) error stop \"invalid column index in new_order\" end do ! Create temporary arrays in new order allocate ( temp_cols ( this % num_cols )) if ( this % with_headers ) allocate ( character ( len = len ( this % headers )) :: temp_headers ( this % num_cols )) do i = 1 , this % num_cols temp_cols ( i ) = this % data_cols ( new_order ( i )) if ( this % with_headers ) temp_headers ( i ) = this % headers ( new_order ( i )) end do ! Replace arrays this % data_cols = temp_cols if ( this % with_headers ) this % headers = temp_headers end subroutine reorder_columns","tags":"","url":"proc/reorder_columns.html"},{"title":"replace_value_integer – DataFort","text":"private  subroutine replace_value_integer(this, col_index, old_value, new_value) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in) :: old_value integer(kind=ik), intent(in) :: new_value Source Code subroutine replace_value_integer ( this , col_index , old_value , new_value ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index integer ( ik ), intent ( in ) :: old_value , new_value integer ( ik ), dimension (:), allocatable :: col integer :: i col = this % geti ( col_index ) do i = 1 , size ( col ) if ( col ( i ) == old_value ) then col ( i ) = new_value end if end do call this % seti ( col_index , col ) end subroutine replace_value_integer","tags":"","url":"proc/replace_value_integer.html"},{"title":"replace_value_real – DataFort","text":"private  subroutine replace_value_real(this, col_index, old_value, new_value) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: old_value real(kind=rk), intent(in) :: new_value Source Code subroutine replace_value_real ( this , col_index , old_value , new_value ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: old_value , new_value real ( rk ), dimension (:), allocatable :: col integer :: i real ( rk ), parameter :: tol = 1.0e-10_rk col = this % getr ( col_index ) do i = 1 , size ( col ) if ( abs ( col ( i ) - old_value ) < tol ) then col ( i ) = new_value end if end do call this % setr ( col_index , col ) end subroutine replace_value_real","tags":"","url":"proc/replace_value_real.html"},{"title":"resize_storage – DataFort","text":"private  subroutine resize_storage(this) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this Source Code subroutine resize_storage ( this ) class ( data_frame ), intent ( inout ) :: this type ( column ), dimension (:), allocatable :: temp_cols character ( len = :), dimension (:), allocatable :: temp_headers integer :: new_size , i new_size = this % num_cols + 1 ! Resize columns array if ( allocated ( this % data_cols )) then allocate ( temp_cols ( size ( this % data_cols ))) do i = 1 , size ( this % data_cols ) temp_cols ( i ) = this % data_cols ( i ) end do deallocate ( this % data_cols ) end if allocate ( this % data_cols ( new_size )) if ( allocated ( temp_cols )) then do i = 1 , size ( temp_cols ) this % data_cols ( i ) = temp_cols ( i ) end do deallocate ( temp_cols ) end if ! Resize headers array if needed if ( this % with_headers ) then if ( allocated ( this % headers )) then allocate ( character ( len = this % max_char_len ) :: temp_headers ( size ( this % headers ))) temp_headers = this % headers deallocate ( this % headers ) end if allocate ( character ( len = this % max_char_len ) :: this % headers ( new_size )) if ( allocated ( temp_headers )) then this % headers ( 1 : size ( temp_headers )) = temp_headers deallocate ( temp_headers ) end if end if end subroutine resize_storage","tags":"","url":"proc/resize_storage.html"},{"title":"round_column – DataFort","text":"private  subroutine round_column(this, col_index, decimals) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: decimals Source Code subroutine round_column ( this , col_index , decimals ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index integer , intent ( in ) :: decimals real ( rk ), dimension (:), allocatable :: col real ( rk ) :: multiplier integer :: i col = this % getr ( col_index ) multiplier = 1 0.0_rk ** decimals do i = 1 , size ( col ) col ( i ) = nint ( col ( i ) * multiplier ) / multiplier end do call this % setr ( col_index , col ) end subroutine round_column","tags":"","url":"proc/round_column.html"},{"title":"set_col_character – DataFort","text":"private  subroutine set_col_character(this, col_index, col) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index character(len=*), intent(in), dimension(:) :: col Source Code subroutine set_col_character ( this , col_index , col ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index character ( len =* ), dimension (:), intent ( in ) :: col if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= CHARACTER_NUM ) error stop \"column is not character type\" if ( size ( col ) /= this % nrows ()) error stop \"column size mismatch\" call this % data_cols ( col_index )% destroy () call this % data_cols ( col_index )% new ( col ) end subroutine set_col_character","tags":"","url":"proc/set_col_character.html"},{"title":"set_col_complex – DataFort","text":"private  subroutine set_col_complex(this, col_index, col) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index complex(kind=rk), intent(in), dimension(:) :: col Source Code subroutine set_col_complex ( this , col_index , col ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index complex ( rk ), dimension (:), intent ( in ) :: col if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= COMPLEX_NUM ) error stop \"column is not complex type\" if ( size ( col ) /= this % nrows ()) error stop \"column size mismatch\" call this % data_cols ( col_index )% destroy () call this % data_cols ( col_index )% new ( col ) end subroutine set_col_complex","tags":"","url":"proc/set_col_complex.html"},{"title":"set_col_integer – DataFort","text":"private  subroutine set_col_integer(this, col_index, col) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in), dimension(:) :: col Source Code subroutine set_col_integer ( this , col_index , col ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index integer ( ik ), dimension (:), intent ( in ) :: col if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" if ( size ( col ) /= this % nrows ()) error stop \"column size mismatch\" call this % data_cols ( col_index )% destroy () call this % data_cols ( col_index )% new ( col ) end subroutine set_col_integer","tags":"","url":"proc/set_col_integer.html"},{"title":"set_col_logical – DataFort","text":"private  subroutine set_col_logical(this, col_index, col) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index logical, intent(in), dimension(:) :: col Source Code subroutine set_col_logical ( this , col_index , col ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index logical , dimension (:), intent ( in ) :: col if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= LOGICAL_NUM ) error stop \"column is not logical type\" if ( size ( col ) /= this % nrows ()) error stop \"column size mismatch\" call this % data_cols ( col_index )% destroy () call this % data_cols ( col_index )% new ( col ) end subroutine set_col_logical","tags":"","url":"proc/set_col_logical.html"},{"title":"set_col_real – DataFort","text":"private  subroutine set_col_real(this, col_index, col) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in), dimension(:) :: col Source Code subroutine set_col_real ( this , col_index , col ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index real ( rk ), dimension (:), intent ( in ) :: col if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= REAL_NUM ) error stop \"column is not real type\" if ( size ( col ) /= this % nrows ()) error stop \"column size mismatch\" call this % data_cols ( col_index )% destroy () call this % data_cols ( col_index )% new ( col ) end subroutine set_col_real","tags":"","url":"proc/set_col_real.html"},{"title":"set_val_character – DataFort","text":"private  subroutine set_val_character(this, col_index, row_index, val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index character(len=*), intent(in) :: val Source Code subroutine set_val_character ( this , col_index , row_index , val ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index , row_index character ( len =* ), intent ( in ) :: val if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= CHARACTER_NUM ) error stop \"column is not character type\" call this % data_cols ( col_index )% changech ( row_index , val ) end subroutine set_val_character","tags":"","url":"proc/set_val_character.html"},{"title":"set_val_complex – DataFort","text":"private  subroutine set_val_complex(this, col_index, row_index, val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index complex(kind=rk), intent(in) :: val Source Code subroutine set_val_complex ( this , col_index , row_index , val ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index , row_index complex ( rk ), intent ( in ) :: val if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= COMPLEX_NUM ) error stop \"column is not complex type\" call this % data_cols ( col_index )% changec ( row_index , val ) end subroutine set_val_complex","tags":"","url":"proc/set_val_complex.html"},{"title":"set_val_integer – DataFort","text":"private  subroutine set_val_integer(this, col_index, row_index, val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index integer(kind=ik), intent(in) :: val Source Code subroutine set_val_integer ( this , col_index , row_index , val ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index , row_index integer ( ik ), intent ( in ) :: val if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" call this % data_cols ( col_index )% changei ( row_index , val ) end subroutine set_val_integer","tags":"","url":"proc/set_val_integer.html"},{"title":"set_val_logical – DataFort","text":"private  subroutine set_val_logical(this, col_index, row_index, val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index logical, intent(in) :: val Source Code subroutine set_val_logical ( this , col_index , row_index , val ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index , row_index logical , intent ( in ) :: val if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= LOGICAL_NUM ) error stop \"column is not logical type\" call this % data_cols ( col_index )% changel ( row_index , val ) end subroutine set_val_logical","tags":"","url":"proc/set_val_logical.html"},{"title":"set_val_real – DataFort","text":"private  subroutine set_val_real(this, col_index, row_index, val) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index real(kind=rk), intent(in) :: val Source Code subroutine set_val_real ( this , col_index , row_index , val ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index , row_index real ( rk ), intent ( in ) :: val if ( col_index < 1 . or . col_index > this % num_cols ) error stop \"column index out of range\" if ( this % data_cols ( col_index )% get_type () /= REAL_NUM ) error stop \"column is not real type\" call this % data_cols ( col_index )% changer ( row_index , val ) end subroutine set_val_real","tags":"","url":"proc/set_val_real.html"},{"title":"shuffle – DataFort","text":"private  subroutine shuffle(this, seed) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), optional :: seed Source Code subroutine shuffle ( this , seed ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ), optional :: seed integer , dimension (:), allocatable :: indices , seed_array integer :: i , j , temp , seed_size real :: rand_val if ( this % nrows () < 2 ) return ! Initialize random seed if provided if ( present ( seed )) then call random_seed ( size = seed_size ) allocate ( seed_array ( seed_size )) seed_array = seed call random_seed ( put = seed_array ) deallocate ( seed_array ) end if ! Create array of indices allocate ( indices ( this % nrows ())) do i = 1 , this % nrows () indices ( i ) = i end do ! Fisher-Yates shuffle do i = this % nrows (), 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = indices ( i ) indices ( i ) = indices ( j ) indices ( j ) = temp end do ! Reorder all columns according to shuffled indices call reorder_all_columns ( this , indices ) deallocate ( indices ) end subroutine shuffle","tags":"","url":"proc/shuffle.html"},{"title":"sort_by_column – DataFort","text":"private  subroutine sort_by_column(this, col_index, ascending) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending Source Code subroutine sort_by_column ( this , col_index , ascending ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index logical , intent ( in ), optional :: ascending logical :: asc integer , allocatable :: indices (:) integer :: i asc = . true . if ( present ( ascending )) asc = ascending if ( col_index < 1 . or . col_index > this % num_cols ) then error stop \"Column index out of range in sort_by_column\" end if allocate ( indices ( this % nrows ())) do i = 1 , this % nrows () indices ( i ) = i end do select case ( this % data_cols ( col_index )% get_type ()) case ( REAL_NUM ) call sort_indices_real ( this % data_cols ( col_index )% getr (), indices , asc ) case ( INTEGER_NUM ) call sort_indices_integer ( this % data_cols ( col_index )% geti (), indices , asc ) case default error stop \"Sorting only supported for real and integer columns\" end select call reorder_all_columns ( this , indices ) deallocate ( indices ) end subroutine sort_by_column","tags":"","url":"proc/sort_by_column.html"},{"title":"sort_indices_integer – DataFort","text":"private  subroutine sort_indices_integer(values, indices, ascending) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices logical, intent(in) :: ascending Source Code subroutine sort_indices_integer ( values , indices , ascending ) integer ( ik ), dimension (:), intent ( in ) :: values integer , dimension (:), intent ( inout ) :: indices logical , intent ( in ) :: ascending if ( size ( values ) > 0 ) then call quicksort_indices_integer ( values , indices , 1 , size ( values ), ascending ) end if end subroutine sort_indices_integer","tags":"","url":"proc/sort_indices_integer.html"},{"title":"sort_indices_real – DataFort","text":"private  subroutine sort_indices_real(values, indices, ascending) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices logical, intent(in) :: ascending Source Code subroutine sort_indices_real ( values , indices , ascending ) real ( rk ), dimension (:), intent ( in ) :: values integer , dimension (:), intent ( inout ) :: indices logical , intent ( in ) :: ascending if ( size ( values ) > 0 ) then call quicksort_indices_real ( values , indices , 1 , size ( values ), ascending ) end if end subroutine sort_indices_real","tags":"","url":"proc/sort_indices_real.html"},{"title":"sqrt_column – DataFort","text":"private  subroutine sqrt_column(this, col_index) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index Source Code subroutine sqrt_column ( this , col_index ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col col = this % getr ( col_index ) col = sqrt ( col ) call this % setr ( col_index , col ) end subroutine sqrt_column","tags":"","url":"proc/sqrt_column.html"},{"title":"standardize_column_real – DataFort","text":"private  subroutine standardize_column_real(this, col_index) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index Source Code subroutine standardize_column_real ( this , col_index ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col real ( rk ) :: mean_val , std_val integer :: i col = this % getr ( col_index ) mean_val = this % mean_real ( col_index ) std_val = this % std_real ( col_index ) if ( std_val > 0.0_rk ) then do i = 1 , size ( col ) col ( i ) = ( col ( i ) - mean_val ) / std_val end do call this % setr ( col_index , col ) end if end subroutine standardize_column_real","tags":"","url":"proc/standardize_column_real.html"},{"title":"validate_column_addition – DataFort","text":"private  subroutine validate_column_addition(this, header, col_size) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this character(len=*), intent(in), optional :: header integer, intent(in) :: col_size Source Code subroutine validate_column_addition ( this , header , col_size ) class ( data_frame ), intent ( inout ) :: this character ( len =* ), intent ( in ), optional :: header integer , intent ( in ) :: col_size ! Check row size consistency if ( this % num_cols > 0 . and . col_size /= this % nrows ()) then error stop \"column size must match existing columns\" end if ! Handle headers if ( present ( header )) then if ( this % num_cols == 0 ) then this % with_headers = . true . allocate ( character ( len = this % max_char_len ) :: this % headers ( 0 )) else if (. not . this % with_headers ) then error stop \"cannot add header to data frame without headers\" end if if ( this % already_header ( header )) then error stop \"header already exists\" end if else if ( this % with_headers ) then error stop \"cannot add column without header to data frame with headers\" end if end if end subroutine validate_column_addition","tags":"","url":"proc/validate_column_addition.html"},{"title":"write_console – DataFort","text":"private  subroutine write_console(this, unit) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: unit Source Code subroutine write_console ( this , unit ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ), optional :: unit integer :: out_unit , i , j , dtype , col_width character ( len = 32 ) :: fmt_str if ( present ( unit )) then out_unit = unit else out_unit = 6 ! stdout end if if ( this % num_cols == 0 ) then write ( out_unit , '(a)' ) \"Empty data frame\" return end if col_width = 12 ! Fixed column width for formatting ! Write headers if present if ( this % with_headers ) then do i = 1 , this % num_cols write ( out_unit , '(a12)' , advance = 'no' ) this % headers ( i ) end do write ( out_unit , '(a)' ) '' ! Write separator line do i = 1 , this % num_cols write ( out_unit , '(a12)' , advance = 'no' ) repeat ( '-' , col_width ) end do write ( out_unit , '(a)' ) '' end if ! Write data do j = 1 , this % nrows () do i = 1 , this % num_cols dtype = this % data_cols ( i )% get_type () select case ( dtype ) case ( REAL_NUM ) write ( out_unit , '(g12.4)' , advance = 'no' ) this % data_cols ( i )% getr ( j ) case ( INTEGER_NUM ) write ( out_unit , '(i12)' , advance = 'no' ) this % data_cols ( i )% geti ( j ) case ( LOGICAL_NUM ) if ( this % data_cols ( i )% getl ( j )) then write ( out_unit , '(a12)' , advance = 'no' ) 'T' else write ( out_unit , '(a12)' , advance = 'no' ) 'F' end if case ( CHARACTER_NUM ) write ( out_unit , '(a12)' , advance = 'no' ) this % data_cols ( i )% getch ( j ) case ( COMPLEX_NUM ) write ( out_unit , '(\"(\",f5.2,\",\",f5.2,\")\")' , advance = 'no' ) this % data_cols ( i )% getc ( j ) end select end do write ( out_unit , '(a)' ) '' end do end subroutine write_console","tags":"","url":"proc/write_console.html"},{"title":"write_csv – DataFort","text":"private  subroutine write_csv(this, filename) Export data frame to a CSV file Writes the data frame to a CSV (Comma-Separated Values) file with headers @param[in] this The data frame instance\n@param[in] filename Path to the output CSV file Note All data types are automatically converted to appropriate string representations Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: filename Source Code subroutine write_csv ( this , filename ) class ( data_frame ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: unit , i , j , dtype character ( len = 32 ) :: fmt_str open ( newunit = unit , file = filename , status = 'replace' , action = 'write' ) ! Write headers if present if ( this % with_headers ) then do i = 1 , this % num_cols if ( i > 1 ) write ( unit , '(a)' , advance = 'no' ) ',' write ( unit , '(a)' , advance = 'no' ) trim ( this % headers ( i )) end do write ( unit , '(a)' ) '' end if ! Write data do j = 1 , this % nrows () do i = 1 , this % num_cols if ( i > 1 ) write ( unit , '(a)' , advance = 'no' ) ',' dtype = this % data_cols ( i )% get_type () select case ( dtype ) case ( REAL_NUM ) write ( unit , '(g0)' , advance = 'no' ) this % data_cols ( i )% getr ( j ) case ( INTEGER_NUM ) write ( unit , '(i0)' , advance = 'no' ) this % data_cols ( i )% geti ( j ) case ( LOGICAL_NUM ) write ( unit , '(l1)' , advance = 'no' ) this % data_cols ( i )% getl ( j ) case ( CHARACTER_NUM ) write ( unit , '(a)' , advance = 'no' ) '\"' // trim ( this % data_cols ( i )% getch ( j )) // '\"' case ( COMPLEX_NUM ) write ( unit , '(\"(\",g0,\",\",g0,\")\")' , advance = 'no' ) this % data_cols ( i )% getc ( j ) end select end do write ( unit , '(a)' ) '' end do close ( unit ) end subroutine write_csv","tags":"","url":"proc/write_csv.html"},{"title":"partition_integer – DataFort","text":"private  function partition_integer(arr, low, high) result(pivot_index) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high Return Value integer Source Code function partition_integer ( arr , low , high ) result ( pivot_index ) integer ( ik ), intent ( inout ) :: arr (:) integer , intent ( in ) :: low , high integer :: pivot_index integer ( ik ) :: pivot , temp integer :: i , j pivot = arr ( high ) i = low - 1 do j = low , high - 1 if ( arr ( j ) <= pivot ) then i = i + 1 temp = arr ( i ) arr ( i ) = arr ( j ) arr ( j ) = temp end if end do temp = arr ( i + 1 ) arr ( i + 1 ) = arr ( high ) arr ( high ) = temp pivot_index = i + 1 end function partition_integer","tags":"","url":"proc/partition_integer.html"},{"title":"partition_real – DataFort","text":"private  function partition_real(arr, low, high) result(pivot_index) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high Return Value integer Source Code function partition_real ( arr , low , high ) result ( pivot_index ) real ( rk ), intent ( inout ) :: arr (:) integer , intent ( in ) :: low , high integer :: pivot_index real ( rk ) :: pivot , temp integer :: i , j pivot = arr ( high ) i = low - 1 do j = low , high - 1 if ( arr ( j ) <= pivot ) then i = i + 1 temp = arr ( i ) arr ( i ) = arr ( j ) arr ( j ) = temp end if end do temp = arr ( i + 1 ) arr ( i + 1 ) = arr ( high ) arr ( high ) = temp pivot_index = i + 1 end function partition_real","tags":"","url":"proc/partition_real.html"},{"title":"quick_sort_integer – DataFort","text":"public recursive subroutine quick_sort_integer(arr, low, high) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high Source Code recursive subroutine quick_sort_integer ( arr , low , high ) integer ( ik ), intent ( inout ) :: arr (:) integer , intent ( in ) :: low , high integer :: pivot_index if ( low < high ) then pivot_index = partition_integer ( arr , low , high ) call quick_sort_integer ( arr , low , pivot_index - 1 ) call quick_sort_integer ( arr , pivot_index + 1 , high ) end if end subroutine quick_sort_integer","tags":"","url":"proc/quick_sort_integer.html"},{"title":"quick_sort_real – DataFort","text":"public recursive subroutine quick_sort_real(arr, low, high) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high Source Code recursive subroutine quick_sort_real ( arr , low , high ) real ( rk ), intent ( inout ) :: arr (:) integer , intent ( in ) :: low , high integer :: pivot_index if ( low < high ) then pivot_index = partition_real ( arr , low , high ) call quick_sort_real ( arr , low , pivot_index - 1 ) call quick_sort_real ( arr , pivot_index + 1 , high ) end if end subroutine quick_sort_real","tags":"","url":"proc/quick_sort_real.html"},{"title":"is_nan_integer – DataFort","text":"public elemental function is_nan_integer(x) result(is_nan) Check if an integer value is NaN (sentinel) @param[in] x Integer value to check\n@return True if x equals the integer NaN sentinel, false otherwise Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: x Return Value logical Source Code elemental function is_nan_integer ( x ) result ( is_nan ) integer ( ik ), intent ( in ) :: x logical :: is_nan is_nan = ( x == NaN_ik ) end function is_nan_integer","tags":"","url":"proc/is_nan_integer.html"},{"title":"is_nan_real – DataFort","text":"public elemental function is_nan_real(x) result(is_nan) Check if a real value is NaN @param[in] x Real value to check\n@return True if x is NaN, false otherwise Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical Source Code elemental function is_nan_real ( x ) result ( is_nan ) real ( rk ), intent ( in ) :: x logical :: is_nan is_nan = ieee_is_nan ( x ) end function is_nan_real","tags":"","url":"proc/is_nan_real.html"},{"title":"init_nan – DataFort","text":"public  subroutine init_nan() Initialize the NaN_rk constant Must be called before using NaN_rk. Automatically called by other functions. Arguments None Source Code subroutine init_nan () if (. not . nan_initialized ) then NaN_rk = ieee_value ( 0.0_rk , ieee_quiet_nan ) nan_initialized = . true . end if end subroutine init_nan","tags":"","url":"proc/init_nan.html"},{"title":"lower – DataFort","text":"private pure elemental function lower(str, begin, end) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character(len=len(str)) Source Code elemental pure function lower ( str , begin , end ) result ( string ) ! ident_25=\"@(#) M_strings lower(3f) Changes a string to lowercase over specified range\" character ( * ), intent ( in ) :: str character ( len ( str )) :: string integer , intent ( in ), optional :: begin , end integer :: i integer :: ibegin , iend integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str ibegin = 1 iend = len_trim ( str ) if ( present ( begin )) then ibegin = min ( max ( 1 , begin ), iend ) endif if ( present ( end )) then iend = max ( 1 , min ( iend , end )) endif do concurrent ( i = ibegin : iend ) ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'A' : 'Z' ) string ( i : i ) = achar ( iachar ( str ( i : i )) - diff ) ! change letter to miniscule case default end select enddo end function lower","tags":"","url":"proc/lower.html"},{"title":"split – DataFort","text":"public pure function split(input_line, delimiters, order, nulls) result(array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls Return Value character(len=:), allocatable, (:) Source Code pure function split ( input_line , delimiters , order , nulls ) result ( array ) !----------------------------------------------------------------------------------------------------------------------------------- ! ident_8=\"@(#) M_strings split(3f) parse string on delimiter characters and store tokens into an allocatable array\" !  John S. Urban !----------------------------------------------------------------------------------------------------------------------------------- intrinsic index , min , present , len !----------------------------------------------------------------------------------------------------------------------------------- !  given a line of structure \" par1 par2 par3 ... parn \" store each par(n) into a separate variable in array. !    o by default adjacent delimiters in the input string do not create an empty string in the output array !    o no quoting of delimiters is supported character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: order ! order of output array sequential|[reverse|right] character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable :: array (:) ! output array of tokens !----------------------------------------------------------------------------------------------------------------------------------- integer :: n ! max number of strings INPUT_LINE could split into if all delimiter integer , allocatable :: ibegin (:) ! positions in input string where tokens start integer , allocatable :: iterm (:) ! positions in input string where tokens end character ( len = :), allocatable :: dlim ! string containing delimiter characters character ( len = :), allocatable :: ordr ! string containing order keyword character ( len = :), allocatable :: nlls ! string containing nulls keyword integer :: ii , iiii ! loop parameters used to control print order integer :: icount ! number of tokens found integer :: lgth ! length of input string with trailing spaces trimmed integer :: i10 , i20 , i30 ! loop counters integer :: icol ! pointer into input string as it is being parsed integer :: idlim ! number of delimiter characters integer :: ifound ! where next delimiter character is found in remaining input string data integer :: inotnull ! count strings not composed of delimiters integer :: ireturn ! number of tokens returned integer :: imax ! length of longest token !----------------------------------------------------------------------------------------------------------------------------------- ! decide on value for optional DELIMITERS parameter if ( present ( delimiters )) then ! optional delimiter list was present if ( delimiters /= '' ) then ! if DELIMITERS was specified and not null use it dlim = delimiters else ! DELIMITERS was specified on call as empty string dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif else ! no delimiter value was specified dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif idlim = len ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( order )) then ; ordr = lower ( adjustl ( order )); else ; ordr = 'sequential' ; endif ! decide on value for optional ORDER parameter if ( present ( nulls )) then ; nlls = lower ( adjustl ( nulls )); else ; nlls = 'ignore' ; endif ! optional parameter !----------------------------------------------------------------------------------------------------------------------------------- n = len ( input_line ) + 1 ! max number of strings INPUT_LINE could split into if all delimiter if ( allocated ( ibegin )) deallocate ( ibegin ) !x! intel compiler says allocated already ? if ( allocated ( iterm )) deallocate ( iterm ) !x! intel compiler says allocated already ? allocate ( ibegin ( n )) ! allocate enough space to hold starting location of tokens if string all tokens allocate ( iterm ( n )) ! allocate enough space to hold ending location of tokens if string all tokens ibegin (:) = 1 iterm (:) = 1 !----------------------------------------------------------------------------------------------------------------------------------- lgth = len ( input_line ) ! lgth is the column position of the last non-blank character icount = 0 ! how many tokens found inotnull = 0 ! how many tokens found not composed of delimiters imax = 0 ! length of longest token found !----------------------------------------------------------------------------------------------------------------------------------- if ( lgth > 0 ) then ! there is at least one non-delimiter in INPUT_LINE if get here icol = 1 ! initialize pointer into input line INFINITE : do i30 = 1 , lgth , 1 ! store into each array element ibegin ( i30 ) = icol ! assume start new token on the character if ( index ( dlim ( 1 : idlim ), input_line ( icol : icol )) == 0 ) then ! if current character is not a delimiter iterm ( i30 ) = lgth ! initially assume no more tokens do i10 = 1 , idlim ! search for next delimiter ifound = index ( input_line ( ibegin ( i30 ): lgth ), dlim ( i10 : i10 )) IF ( ifound > 0 ) then iterm ( i30 ) = min ( iterm ( i30 ), ifound + ibegin ( i30 ) - 2 ) endif enddo icol = iterm ( i30 ) + 2 ! next place to look as found end of this token inotnull = inotnull + 1 ! increment count of number of tokens not composed of delimiters else ! character is a delimiter for a null string iterm ( i30 ) = icol - 1 ! record assumed end of string. Will be less than beginning icol = icol + 1 ! advance pointer into input string endif imax = max ( imax , iterm ( i30 ) - ibegin ( i30 ) + 1 ) icount = i30 ! increment count of number of tokens found if ( icol > lgth ) then ! no text left exit INFINITE endif enddo INFINITE endif !----------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) ireturn = inotnull case default ireturn = icount end select allocate ( character ( len = imax ) :: array ( ireturn )) ! allocate the array to return !allocate(array(ireturn))                                       ! allocate the array to return !----------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( ordr ))) ! decide which order to store tokens case ( 'reverse' , 'right' ) ; ii = ireturn ; iiii =- 1 ! last to first case default ; ii = 1 ; iiii = 1 ! first to last end select !----------------------------------------------------------------------------------------------------------------------------------- do i20 = 1 , icount ! fill the array with the tokens that were found if ( iterm ( i20 ) < ibegin ( i20 )) then select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) case default array ( ii ) = ' ' ii = ii + iiii end select else array ( ii ) = input_line ( ibegin ( i20 ): iterm ( i20 )) ii = ii + iiii endif enddo !----------------------------------------------------------------------------------------------------------------------------------- end function split","tags":"","url":"proc/split.html"},{"title":"column_class – DataFort","text":"Uses precision types Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_CHAR_LEN_DEFAULT = 100 Derived Types type, public :: column Components Type Visibility Attributes Name Initial complex(kind=rk), private, dimension(:), allocatable :: ccol character(len=:), private, dimension(:), allocatable :: charcol integer, public :: dtype = 0 integer(kind=ik), private, dimension(:), allocatable :: icol logical, private :: initialized = .false. logical, private, dimension(:), allocatable :: lcol integer, public :: n real(kind=rk), private, dimension(:), allocatable :: rcol Type-Bound Procedures procedure, public :: changec => change_col_complex procedure, public :: changech => change_col_character procedure, public :: changei => change_col_integer procedure, public :: changel => change_col_logical procedure, public :: changer => change_col_real procedure, private :: col_constructor_character procedure, private :: col_constructor_complex procedure, private :: col_constructor_integer procedure, private :: col_constructor_logical procedure, private :: col_constructor_real procedure, public :: destroy => col_destructor procedure, public :: emptyc => col_constructor_alloc_complex procedure, public :: emptych => col_constructor_alloc_character procedure, public :: emptyi => col_constructor_alloc_integer procedure, public :: emptyl => col_constructor_alloc_logical procedure, public :: emptyr => col_constructor_alloc_real procedure, private :: get_from_col_character procedure, private :: get_from_col_complex procedure, private :: get_from_col_integer procedure, private :: get_from_col_logical procedure, private :: get_from_col_real procedure, private :: get_single_col_character procedure, private :: get_single_col_complex procedure, private :: get_single_col_integer procedure, private :: get_single_col_logical procedure, private :: get_single_col_real procedure, public :: get_type => get_from_col_dtype generic, public :: getc => get_from_col_complex , get_single_col_complex generic, public :: getch => get_from_col_character , get_single_col_character generic, public :: geti => get_from_col_integer , get_single_col_integer generic, public :: getl => get_from_col_logical , get_single_col_logical generic, public :: getr => get_from_col_real , get_single_col_real generic, public :: new => col_constructor_real , col_constructor_integer , col_constructor_logical , col_constructor_character , col_constructor_complex Functions private pure function get_from_col_character (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value character(len=:), dimension(:), allocatable private pure function get_from_col_complex (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value complex(kind=rk), dimension(this%n) private pure function get_from_col_dtype (this) result(dtype) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer private pure function get_from_col_integer (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer(kind=ik), dimension(this%n) private pure function get_from_col_logical (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value logical, dimension(this%n) private pure function get_from_col_real (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value real(kind=rk), dimension(this%n) private pure function get_single_col_character (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value character(len=:), allocatable private pure function get_single_col_complex (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value complex(kind=rk) private pure function get_single_col_integer (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value integer(kind=ik) private pure function get_single_col_logical (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value logical private pure function get_single_col_real (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) Subroutines private  subroutine change_col_character (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i character(len=*), intent(in) :: val private  subroutine change_col_complex (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i complex(kind=rk), intent(in) :: val private  subroutine change_col_integer (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i integer(kind=ik), intent(in) :: val private  subroutine change_col_logical (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i logical, intent(in) :: val private  subroutine change_col_real (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i real(kind=rk), intent(in) :: val private  subroutine col_constructor_alloc_character (this, n, len) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n integer, intent(in), optional :: len private  subroutine col_constructor_alloc_complex (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n private  subroutine col_constructor_alloc_integer (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n private  subroutine col_constructor_alloc_logical (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n private  subroutine col_constructor_alloc_real (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n private  subroutine col_constructor_character (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: dcol private  subroutine col_constructor_complex (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: dcol private  subroutine col_constructor_integer (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: dcol private  subroutine col_constructor_logical (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this logical, intent(in), dimension(:) :: dcol private  subroutine col_constructor_real (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: dcol private  subroutine col_destructor (this) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this","tags":"","url":"module/column_class.html"},{"title":"types – DataFort","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: CHARACTER_NUM = 4 integer, public, parameter :: COMPLEX_NUM = 5 integer, public, parameter :: INTEGER_NUM = 2 integer, public, parameter :: LOGICAL_NUM = 3 integer, public, parameter :: REAL_NUM = 1","tags":"","url":"module/types.html"},{"title":"datafort – DataFort","text":"DataFort - Modern Data Frame Library for Fortran This module provides a comprehensive data frame implementation for Fortran,\noffering pandas-like functionality for scientific computing and data analysis. Features Mixed-type columns : real, integer, logical, character, complex Statistical operations : mean, std, median, percentile, variance, correlation Data manipulation : filter, sort, slice, transpose, join Mathematical functions : cumsum, diff, normalize, log, exp, sqrt I/O operations : CSV import/export, console display Convenience methods : head, tail, info, describe, sample, shuffle Example Usage use datafort use precision type ( data_frame ) :: df real ( rk ) :: temps ( 3 ) = [ 2 0.0_rk , 2 5.0_rk , 2 2.0_rk ] call df % new () call df % append ( temps , \"Temperature\" ) call df % write_console () print * , \"Mean:\" , df % mean_real ( 1 ) call df % destroy () Uses precision types column_class utilities Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_CHAR_LEN_DEFAULT = 100 Abstract Interfaces abstract interface private  function row_func_real(row_values, num_cols) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: row_values integer, intent(in) :: num_cols Return Value real(kind=rk) Derived Types type, public :: data_frame Main data frame type for storing heterogeneous tabular data Read more… Components Type Visibility Attributes Name Initial type( column ), private, dimension(:), allocatable :: data_cols character(len=:), private, dimension(:), allocatable :: headers logical, private :: initialized = .false. integer, private :: max_char_len = MAX_CHAR_LEN_DEFAULT integer, private :: num_cols = 0 logical, private :: with_headers = .false. Type-Bound Procedures procedure, public :: abs_column_integer procedure, public :: abs_column_real procedure, private :: add_col_character procedure, private :: add_col_complex procedure, private :: add_col_integer procedure, private :: add_col_logical procedure, private :: add_col_real procedure, private :: already_header generic, public :: append => add_col_real , add_col_integer , add_col_logical , add_col_character , add_col_complex procedure, public :: apply_to_all_rows_real procedure, public :: apply_to_row_real procedure, public :: clear procedure, public :: clip_integer procedure, public :: clip_real procedure, public :: concat procedure, public :: copy procedure, public :: correlation_real procedure, public :: cumsum_integer procedure, public :: cumsum_real procedure, public :: describe_numeric procedure, public :: destroy => df_destructor procedure, private :: df_get_col_type_header procedure, private :: df_get_col_type_index procedure, public :: diff_integer procedure, public :: diff_real procedure, public :: drop_column procedure, public :: drop_duplicates procedure, public :: drop_duplicates_subset procedure, public :: dropna generic, public :: dtype => df_get_col_type_header , df_get_col_type_index procedure, public :: duplicated procedure, public :: empty procedure, public :: exp_column procedure, public :: fillna_integer procedure, public :: fillna_real procedure, public :: filter_rows_integer_range procedure, public :: filter_rows_logical procedure, public :: filter_rows_real_range procedure, public :: filter_rows_string_pattern procedure, private :: find_header_index procedure, private :: get_col_character procedure, private :: get_col_complex procedure, private :: get_col_integer procedure, private :: get_col_logical procedure, private :: get_col_real procedure, public :: get_max_char_len => df_get_max_char_len procedure, public :: get_val_character procedure, public :: get_val_complex procedure, public :: get_val_integer procedure, public :: get_val_logical procedure, public :: get_val_real generic, public :: getc => get_col_complex generic, public :: getch => get_col_character generic, public :: geti => get_col_integer generic, public :: getl => get_col_logical generic, public :: getr => get_col_real procedure, public :: head procedure, public :: header => get_header procedure, public :: info procedure, public :: inner_join procedure, public :: is_initialized => df_is_initialized procedure, public :: is_sorted_integer procedure, public :: is_sorted_real procedure, public :: isna_integer procedure, public :: isna_real procedure, public :: left_join procedure, public :: log_column procedure, public :: max_integer procedure, public :: max_real procedure, public :: mean_integer procedure, public :: mean_real procedure, public :: median_integer procedure, public :: median_real procedure, public :: merge procedure, public :: min_integer procedure, public :: min_real procedure, public :: ncols => df_get_num_cols procedure, public :: new => df_constructor procedure, public :: normalize_column_real procedure, public :: nrows => df_get_num_rows procedure, public :: outer_join procedure, public :: percentile_integer procedure, public :: percentile_real procedure, public :: pow_column procedure, public :: rank_integer procedure, public :: rank_real procedure, public :: read_csv procedure, public :: rename_column procedure, public :: reorder_columns procedure, public :: replace_value_integer procedure, public :: replace_value_real procedure, private :: resize_storage procedure, public :: right_join procedure, public :: round_column procedure, public :: sample procedure, public :: select_columns procedure, private :: set_col_character procedure, private :: set_col_complex procedure, private :: set_col_integer procedure, private :: set_col_logical procedure, private :: set_col_real procedure, public :: set_val_character procedure, public :: set_val_complex procedure, public :: set_val_integer procedure, public :: set_val_logical procedure, public :: set_val_real generic, public :: setc => set_col_complex generic, public :: setch => set_col_character generic, public :: seti => set_col_integer generic, public :: setl => set_col_logical generic, public :: setr => set_col_real procedure, public :: shape procedure, public :: shuffle procedure, public :: slice_rows procedure, public :: sort_by_column procedure, public :: sqrt_column procedure, public :: standardize_column_real procedure, public :: std_integer procedure, public :: std_real procedure, public :: sum_integer procedure, public :: sum_real procedure, public :: tail procedure, public :: transpose procedure, public :: unique_character procedure, public :: unique_integer procedure, public :: unique_real procedure, private :: validate_column_addition procedure, public :: value_counts_character procedure, public :: value_counts_integer procedure, public :: value_counts_real procedure, public :: variance_integer procedure, public :: variance_real procedure, public :: write_console procedure, public :: write_csv Functions private  function already_header (this, header) result(exists) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value logical private  function apply_to_all_rows_real (this, func) result(outputs) Apply a function to all rows Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this procedure( row_func_real ) :: func Return Value real(kind=rk), dimension(:), allocatable private  function apply_to_row_real (this, row_idx, func) result(output) Apply a function to a single row Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: row_idx procedure( row_func_real ) :: func Return Value real(kind=rk) private  function concat (this, other, axis) result(result_df) Concatenate two dataframes vertically (rows) or horizontally (columns) Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: axis Return Value type( data_frame ) private  function copy (this) result(new_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value type( data_frame ) private  function correlation_real (this, col_index1, col_index2) result(corr) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index1 integer, intent(in) :: col_index2 Return Value real(kind=rk) private pure function df_get_col_type_header (this, header) result(dtype) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer private pure function df_get_col_type_index (this, index) result(dtype) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value integer private pure function df_get_max_char_len (this) result(max_len) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer private pure function df_get_num_cols (this) result(num_cols) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer private pure function df_get_num_rows (this) result(num_rows) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer private pure function df_is_initialized (this) result(is_init) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical private  function diff_integer (this, col_index) result(differences) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik), dimension(:), allocatable private  function diff_real (this, col_index) result(differences) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk), dimension(:), allocatable private  function drop_duplicates (this) result(unique_df) Remove duplicate rows Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value type( data_frame ) private  function drop_duplicates_subset (this, col_indices) result(unique_df) Drop duplicate rows based on specific columns (subset) Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_indices (:) Return Value type( data_frame ) private  function dropna (this) result(clean_df) Remove rows containing NaN values Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value type( data_frame ) private  function duplicated (this) result(is_dup) Check which rows are duplicates Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical, dimension(:), allocatable private pure function empty (this) result(is_empty) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical private  function filter_rows_integer_range (this, col_index, min_val, max_val) result(filtered_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in) :: min_val integer(kind=ik), intent(in) :: max_val Return Value type( data_frame ) private  function filter_rows_logical (this, logical_col_index) result(new_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: logical_col_index Return Value type( data_frame ) private  function filter_rows_real_range (this, col_index, min_val, max_val) result(filtered_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: min_val real(kind=rk), intent(in) :: max_val Return Value type( data_frame ) private  function filter_rows_string_pattern (this, col_index, pattern) result(filtered_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index character(len=*), intent(in) :: pattern Return Value type( data_frame ) private pure function find_header_index (this, header) result(index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer private  function get_col_character (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value character(len=:), dimension(:), allocatable private  function get_col_complex (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value complex(kind=rk), dimension(:), allocatable private  function get_col_integer (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value integer(kind=ik), dimension(:), allocatable private  function get_col_logical (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value logical, dimension(:), allocatable private  function get_col_real (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value real(kind=rk), dimension(:), allocatable private  function get_header (this, index) result(header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value character(len=:), allocatable private  function get_val_character (this, col_index, row_index) result(val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value character(len=:), allocatable private  function get_val_complex (this, col_index, row_index) result(val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value complex(kind=rk) private  function get_val_integer (this, col_index, row_index) result(val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value integer(kind=ik) private  function get_val_logical (this, col_index, row_index) result(val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value logical private  function get_val_real (this, col_index, row_index) result(val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index Return Value real(kind=rk) private  function head (this, n) result(head_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: n Return Value type( data_frame ) private  function inner_join (this, other, this_key_col, other_key_col) result(joined_df) Perform an inner join between two data frames Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: this_key_col integer, intent(in) :: other_key_col Return Value type( data_frame ) private  function is_sorted_integer (this, col_index, ascending) result(sorted) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value logical private  function is_sorted_real (this, col_index, ascending) result(sorted) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value logical private  function isna_integer (this, col_index) result(mask) Check for NaN values in an integer column Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value logical, dimension(:), allocatable private  function isna_real (this, col_index) result(mask) Check for NaN values in a real column Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value logical, dimension(:), allocatable private  function left_join (this, other, this_key_col, other_key_col) result(joined_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: this_key_col integer, intent(in) :: other_key_col Return Value type( data_frame ) private  function max_integer (this, col_index) result(max_val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik) private  function max_real (this, col_index) result(max_val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) private  function mean_integer (this, col_index) result(avg) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) private  function mean_real (this, col_index) result(avg) Calculate the arithmetic mean of a real column Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) private  function median_integer (this, col_index) result(med) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) private  function median_real (this, col_index) result(med) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) private  function merge (this, other, on_column, how) result(merged_df) Merge two dataframes on column names (similar to SQL join but using names) Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other character(len=*), intent(in) :: on_column character(len=*), intent(in) :: how Return Value type( data_frame ) private  function min_integer (this, col_index) result(min_val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik) private  function min_real (this, col_index) result(min_val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) private  function outer_join (this, other, this_key_col, other_key_col) result(joined_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: this_key_col integer, intent(in) :: other_key_col Return Value type( data_frame ) private  function partition_indices_integer (values, indices, low, high, ascending) result(pivot_idx) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending Return Value integer private  function partition_indices_real (values, indices, low, high, ascending) result(pivot_idx) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending Return Value integer private  function percentile_integer (this, col_index, percentile) result(perc) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: percentile Return Value real(kind=rk) private  function percentile_real (this, col_index, percentile) result(perc) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: percentile Return Value real(kind=rk) private  function rank_integer (this, col_index, ascending) result(ranks) Rank values in an integer column Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value integer(kind=ik), dimension(:), allocatable private  function rank_real (this, col_index, ascending) result(ranks) Rank values in a real column Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value integer(kind=ik), dimension(:), allocatable private  function right_join (this, other, this_key_col, other_key_col) result(joined_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this class( data_frame ), intent(in) :: other integer, intent(in) :: this_key_col integer, intent(in) :: other_key_col Return Value type( data_frame ) private  function sample (this, n, seed) result(sampled_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: n integer, intent(in), optional :: seed Return Value type( data_frame ) private  function select_columns (this, column_indices) result(new_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), dimension(:) :: column_indices Return Value type( data_frame ) private  function shape (this) result(dims) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer, dimension(2) private  function slice_rows (this, start_row, end_row) result(new_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: start_row integer, intent(in) :: end_row Return Value type( data_frame ) private  function std_integer (this, col_index) result(stddev) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) private  function std_real (this, col_index) result(stddev) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) private  function sum_integer (this, col_index) result(total) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik) private  function sum_real (this, col_index) result(total) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) private  function tail (this, n) result(tail_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: n Return Value type( data_frame ) private  function transpose (this) result(transposed_df) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value type( data_frame ) private  function unique_character (this, col_index) result(unique_vals) Get unique values from a character column Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value character(len=:), allocatable, (:) private  function unique_integer (this, col_index) result(unique_vals) Get unique values from an integer column Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value integer(kind=ik), dimension(:), allocatable private  function unique_real (this, col_index) result(unique_vals) Get unique values from a real column Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk), dimension(:), allocatable private  function value_counts_character (this, col_index) result(counts_df) Count occurrences of each value in a character column Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value type( data_frame ) private  function value_counts_integer (this, col_index) result(counts_df) Count occurrences of each value in an integer column Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value type( data_frame ) private  function value_counts_real (this, col_index) result(counts_df) Count occurrences of each value in a real column Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value type( data_frame ) private  function variance_integer (this, col_index) result(var) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) private  function variance_real (this, col_index) result(var) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: col_index Return Value real(kind=rk) Subroutines private  subroutine abs_column_integer (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index private  subroutine abs_column_real (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index private  subroutine add_col_character (this, col, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header private  subroutine add_col_complex (this, col, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header private  subroutine add_col_integer (this, col, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header private  subroutine add_col_logical (this, col, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this logical, intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header private  subroutine add_col_real (this, col, header) Append a real-valued column to the data frame Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header private  subroutine add_csv_column (df, data_strings, headers, col_index, has_headers) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: df character(len=*), intent(in), dimension(:) :: data_strings character(len=*), intent(in), optional, dimension(:) :: headers integer, intent(in) :: col_index logical, intent(in) :: has_headers private  subroutine build_joined_dataframe (df1, df2, indices1, indices2, num_rows, result_df) Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in), dimension(:) :: indices1 integer, intent(in), dimension(:) :: indices2 integer, intent(in) :: num_rows type( data_frame ), intent(out) :: result_df private  subroutine clear (this) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this private  subroutine clip_integer (this, col_index, min_val, max_val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in) :: min_val integer(kind=ik), intent(in) :: max_val private  subroutine clip_real (this, col_index, min_val, max_val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: min_val real(kind=rk), intent(in) :: max_val private  subroutine copy_filtered_column (source_df, target_df, col_index, selected_rows) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: source_df class( data_frame ), intent(inout) :: target_df integer, intent(in) :: col_index integer, intent(in), dimension(:) :: selected_rows private  subroutine cumsum_integer (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index private  subroutine cumsum_real (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index private  subroutine describe_numeric (this, unit) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: unit private  subroutine df_constructor (this, char_len) Initialize a new data frame Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), optional :: char_len private  subroutine df_destructor (this) Destroy a data frame and free all memory Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this private  subroutine drop_column (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index private  subroutine exp_column (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index private  subroutine fillna_integer (this, col_index, fill_value) Replace NaN values in an integer column with a fill value Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in) :: fill_value private  subroutine fillna_real (this, col_index, fill_value) Replace NaN values in a real column with a fill value Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: fill_value private  subroutine info (this, unit) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: unit private  subroutine log_column (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index private  subroutine normalize_column_real (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index private  subroutine parse_csv_line (line, fields) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=100), intent(out), allocatable :: fields (:) private  subroutine pow_column (this, col_index, power) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: power private recursive subroutine quicksort_indices_integer (values, indices, low, high, ascending) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending private recursive subroutine quicksort_indices_real (values, indices, low, high, ascending) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending private  subroutine read_csv (this, filename, has_headers) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this character(len=*), intent(in) :: filename logical, intent(in) :: has_headers private  subroutine rename_column (this, col_index, new_name) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index character(len=*), intent(in) :: new_name private  subroutine reorder_all_columns (this, indices) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), dimension(:) :: indices private  subroutine reorder_columns (this, new_order) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), dimension(:) :: new_order private  subroutine replace_value_integer (this, col_index, old_value, new_value) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in) :: old_value integer(kind=ik), intent(in) :: new_value private  subroutine replace_value_real (this, col_index, old_value, new_value) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in) :: old_value real(kind=rk), intent(in) :: new_value private  subroutine resize_storage (this) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this private  subroutine round_column (this, col_index, decimals) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: decimals private  subroutine set_col_character (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index character(len=*), intent(in), dimension(:) :: col private  subroutine set_col_complex (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index complex(kind=rk), intent(in), dimension(:) :: col private  subroutine set_col_integer (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer(kind=ik), intent(in), dimension(:) :: col private  subroutine set_col_logical (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index logical, intent(in), dimension(:) :: col private  subroutine set_col_real (this, col_index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index real(kind=rk), intent(in), dimension(:) :: col private  subroutine set_val_character (this, col_index, row_index, val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index character(len=*), intent(in) :: val private  subroutine set_val_complex (this, col_index, row_index, val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index complex(kind=rk), intent(in) :: val private  subroutine set_val_integer (this, col_index, row_index, val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index integer(kind=ik), intent(in) :: val private  subroutine set_val_logical (this, col_index, row_index, val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index logical, intent(in) :: val private  subroutine set_val_real (this, col_index, row_index, val) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index integer, intent(in) :: row_index real(kind=rk), intent(in) :: val private  subroutine shuffle (this, seed) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), optional :: seed private  subroutine sort_by_column (this, col_index, ascending) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index logical, intent(in), optional :: ascending private  subroutine sort_indices_integer (values, indices, ascending) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices logical, intent(in) :: ascending private  subroutine sort_indices_real (values, indices, ascending) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices logical, intent(in) :: ascending private  subroutine sqrt_column (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index private  subroutine standardize_column_real (this, col_index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: col_index private  subroutine validate_column_addition (this, header, col_size) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this character(len=*), intent(in), optional :: header integer, intent(in) :: col_size private  subroutine write_console (this, unit) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in), optional :: unit private  subroutine write_csv (this, filename) Export data frame to a CSV file Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: filename","tags":"","url":"module/datafort.html"},{"title":"utilities – DataFort","text":"Uses precision types column_class Functions private  function partition_integer (arr, low, high) result(pivot_index) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high Return Value integer private  function partition_real (arr, low, high) result(pivot_index) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high Return Value integer Subroutines public recursive subroutine quick_sort_integer (arr, low, high) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high public recursive subroutine quick_sort_real (arr, low, high) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high","tags":"","url":"module/utilities.html"},{"title":"precision – DataFort","text":"Precision and NaN handling module Defines precision parameters and NaN (Not-a-Number) constants for the library Uses iso_fortran_env ieee_arithmetic Variables Type Visibility Attributes Name Initial integer(kind=ik), public, parameter :: NaN_ik = -huge(0_ik)-1_ik real(kind=rk), public :: NaN_rk integer, public, parameter :: ik = i32 logical, public, save :: nan_initialized = .false. integer, public, parameter :: rk = r64 Functions public elemental function is_nan_integer (x) result(is_nan) Check if an integer value is NaN (sentinel) Read more… Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: x Return Value logical public elemental function is_nan_real (x) result(is_nan) Check if a real value is NaN Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical Subroutines public  subroutine init_nan () Initialize the NaN_rk constant Read more… Arguments None","tags":"","url":"module/precision.html"},{"title":"split_mod – DataFort","text":"Functions private pure elemental function lower (str, begin, end) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character(len=len(str)) public pure function split (input_line, delimiters, order, nulls) result(array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls Return Value character(len=:), allocatable, (:)","tags":"","url":"module/split_mod.html"},{"title":"Documentation – DataFort","text":"DataFort Guide Reading and Writing Data Load CSV with Headers type ( data_frame ) :: df call df % read_csv ( \"data.csv\" , . true .) ! .true. = has headers call df % write_console () Write to CSV call df % write_csv ( \"output.csv\" ) Data Exploration Display First/Last Rows type ( data_frame ) :: head_df , tail_df head_df = df % head ( 5 ) ! First 5 rows tail_df = df % tail ( 10 ) ! Last 10 rows call head_df % write_console () Get DataFrame Info call df % info () ! Print structure and types call df % describe_numeric () ! Statistical summary print * , \"Shape:\" , df % shape () print * , \"Rows:\" , df % nrows () print * , \"Cols:\" , df % ncols () Access Individual Elements Get a Single Value real ( rk ) :: value_r integer ( ik ) :: value_i character ( len = :), allocatable :: value_c logical :: value_l ! Get value at row i, column j (by index) call df % get_val_real ( j , i , value_r ) ! For real columns call df % get_val_integer ( j , i , value_i ) ! For integer columns call df % get_val_character ( j , i , value_c ) ! For character columns call df % get_val_logical ( j , i , value_l ) ! For logical columns ! Example: Get value at row 5, column 2 call df % get_val_real ( 2 , 5 , value_r ) print * , \"Value at [5,2]:\" , value_r Get Value by Column Name character ( len = :), allocatable :: col_name real ( rk ) :: temperature integer :: row_idx , col_idx row_idx = 10 col_name = \"Temperature\" ! First find column index col_idx = df % find_header_index ( col_name ) ! Then get the value call df % get_val_real ( col_idx , row_idx , temperature ) print * , \"Temperature at row\" , row_idx , \":\" , temperature Set a Single Value ! Set value at row i, column j call df % set_val_real ( j , i , 4 2.5_rk ) ! For real columns call df % set_val_integer ( j , i , 100_ik ) ! For integer columns call df % set_val_character ( j , i , \"NewVal\" ) ! For character columns call df % set_val_logical ( j , i , . true .) ! For logical columns ! Example: Set value at row 3, column 1 call df % set_val_real ( 1 , 3 , 9 9.9_rk ) Access by Header Name character ( len = :), allocatable :: header integer :: col_index ! Get column index from header name header = \"Age\" col_index = df % find_header_index ( header ) if ( col_index > 0 ) then ! Use the column index to access data call df % get_val_integer ( col_index , 5 , value_i ) print * , \"Age at row 5:\" , value_i else print * , \"Column not found\" end if Data Selection and Filtering Select Columns type ( data_frame ) :: subset integer , dimension ( 3 ) :: cols = [ 1 , 3 , 5 ] subset = df % select_columns ( cols ) Slice Rows type ( data_frame ) :: sliced sliced = df % slice_rows ( 10 , 20 ) ! Rows 10 to 20 Filter by Condition type ( data_frame ) :: filtered logical , dimension (:), allocatable :: mask ! Filter numeric range filtered = df % filter_rows_real_range ( 1 , 2 0.0_rk , 3 0.0_rk ) ! Filter by string pattern filtered = df % filter_rows_string_pattern ( 2 , \"Alice\" ) ! Custom logical mask allocate ( mask ( df % nrows ())) mask = temperatures > 2 5.0_rk filtered = df % filter_rows_logical ( mask ) Statistics and Aggregation Basic Statistics real ( rk ) :: avg , std_dev , var integer ( ik ) :: total ! Column 1 statistics avg = df % mean_real ( 1 ) std_dev = df % std_real ( 1 ) var = df % variance_real ( 1 ) total = df % sum_integer ( 2 ) print * , \"Mean:\" , avg print * , \"Std Dev:\" , std_dev Percentiles and Quantiles real ( rk ) :: median , q25 , q75 median = df % median_real ( 1 ) q25 = df % percentile_real ( 1 , 2 5.0_rk ) q75 = df % percentile_real ( 1 , 7 5.0_rk ) print * , \"Median:\" , median print * , \"IQR:\" , q75 - q25 Correlation real ( rk ) :: corr corr = df % correlation_real ( 1 , 2 ) ! Between columns 1 and 2 print * , \"Correlation:\" , corr Data Transformation Normalize Data call df % normalize_column_real ( 1 ) ! Scale to [0, 1] Standardize Data call df % standardize_column_real ( 1 ) ! z-score normalization Mathematical Operations ! Apply functions to entire columns call df % abs_column_real ( 1 ) call df % log_column ( 1 ) call df % exp_column ( 1 ) call df % sqrt_column ( 1 ) call df % pow_column ( 1 , 2.0_rk ) ! Raise to power call df % round_column ( 1 , 2 ) ! Round to 2 decimals Cumulative and Differencing real ( rk ), dimension (:), allocatable :: cumulative , differences cumulative = df % cumsum_real ( 1 ) differences = df % diff_real ( 1 ) Sorting and Ranking Sort by Column call df % sort_by_column ( 1 , ascending = . true .) Get Ranks real ( rk ), dimension (:), allocatable :: ranks ranks = df % rank_real ( 1 ) Check if Sorted logical :: sorted sorted = df % is_sorted_real ( 1 ) Missing Data (NaN) Handling Check for Missing Values logical , dimension (:), allocatable :: na_mask na_mask = df % isna_real ( 1 ) ! Count missing values print * , \"Missing values:\" , count ( na_mask ) Fill Missing Values call df % fillna_real ( 1 , 0.0_rk ) ! Fill with 0 Drop Missing Values type ( data_frame ) :: cleaned cleaned = df % dropna () Column Operations Add Column real ( rk ), dimension ( 100 ) :: new_data call df % append ( new_data , \"NewColumn\" ) Drop Column call df % drop_column ( 3 ) ! Drop column 3 Rename Column call df % rename_column ( 1 , \"Temperature_C\" ) Reorder Columns integer , dimension ( 4 ) :: new_order = [ 3 , 1 , 4 , 2 ] call df % reorder_columns ( new_order ) Get Column Type integer :: col_type col_type = df % get_col_type ( 1 ) ! Returns: 1=Real, 2=Integer, 3=Logical, 4=Character, 5=Complex Joining and Merging Inner Join type ( data_frame ) :: df1 , df2 , result result = df1 % inner_join ( df2 , 1 , 1 ) ! Join on column 1 of both Left Join result = df1 % left_join ( df2 , 1 , 1 ) Right Join result = df1 % right_join ( df2 , 1 , 1 ) Outer Join result = df1 % outer_join ( df2 , 1 , 1 ) Concatenate DataFrames type ( data_frame ) :: combined combined = df1 % concat ( df2 ) ! Stack vertically Duplicates Find Duplicates logical , dimension (:), allocatable :: is_dup is_dup = df % duplicated ( 1 ) ! Check column 1 Drop Duplicates type ( data_frame ) :: unique_df unique_df = df % drop_duplicates ( 1 ) ! Based on column 1 Get Unique Values real ( rk ), dimension (:), allocatable :: unique_vals unique_vals = df % unique_real ( 1 ) Value Counts type ( data_frame ) :: counts counts = df % value_counts_real ( 1 ) call counts % write_console () Row Operations Apply Function to Row ! Define a function that operates on a row function row_sum ( row_values , num_cols ) result ( output ) use precision real ( rk ), dimension (:), intent ( in ) :: row_values integer , intent ( in ) :: num_cols real ( rk ) :: output output = sum ( row_values ) end function row_sum ! Apply to a single row real ( rk ) :: result result = df % apply_to_row_real ( 5 , row_sum ) ! Apply to row 5 Apply Function to All Rows real ( rk ), dimension (:), allocatable :: results results = df % apply_to_all_rows_real ( row_sum ) ! Apply to all rows Other Operations Transpose type ( data_frame ) :: transposed transposed = df % transpose () Sample Rows type ( data_frame ) :: sample_df sample_df = df % sample ( 10 ) ! Random 10 rows Shuffle call df % shuffle () ! Randomize row order Copy type ( data_frame ) :: df_copy df_copy = df % copy () Clear call df % clear () ! Empty the dataframe Complete Example program datafort_example use datafort use precision implicit none type ( data_frame ) :: df , filtered , stats real ( rk ), dimension ( 5 ) :: temps = [ 2 3.1_rk , 2 5.3_rk , 2 4.8_rk , 2 2.5_rk , 2 6.0_rk ] integer ( ik ), dimension ( 5 ) :: ids = [ 1_ik , 2_ik , 3_ik , 4_ik , 5_ik ] ! Create dataframe call df % new () call df % append ( ids , \"ID\" ) call df % append ( temps , \"Temperature\" ) ! Basic info call df % info () call df % describe_numeric () ! Statistics print * , \"Mean temp:\" , df % mean_real ( 2 ) print * , \"Max temp:\" , df % max_real ( 2 ) ! Filter filtered = df % filter_rows_real_range ( 2 , 2 4.0_rk , 2 6.0_rk ) call filtered % write_console () ! Transform call df % normalize_column_real ( 2 ) ! Export call df % write_csv ( \"output.csv\" ) ! Cleanup call df % destroy () call filtered % destroy () end program datafort_example","tags":"","url":"page/index.html"}]}