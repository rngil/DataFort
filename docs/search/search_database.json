var tipuesearch = {"pages":[{"title":" DataFort ","text":"DataFort DataFort DataFort is a dataframes library for Fortran, providing pandas/polars/dplyr-like functionality for scientific computing and data analysis. ⚠️ Warning: Project is very much a WIP. Don't use in production. Installation Using fpm [dependencies] DataFort = { git = \"https://github.com/rngil/DataFort\" } From Source git clone https://github.com/rngil/DataFort.git cd DataFort\nfpm build To run tests: fpm test Quick Start program example use datafort use precision implicit none type ( data_frame ) :: df real ( rk ), dimension ( 3 ) :: temps = [ 2 3.1_rk , 2 5.3_rk , 2 4.8_rk ] integer ( ik ), dimension ( 3 ) :: pressures = [ 1013_ik , 1015_ik , 1012_ik ] ! Create and populate call df % new () call df_append_real ( df , temps , \"Temperature\" ) call df_append_integer ( df , pressures , \"Pressure\" ) ! Display call df_write_console ( df ) ! Statistics print * , \"Mean temperature:\" , df_mean_real ( df , 1 ) ! Export call df_write_csv ( df , \"data.csv\" ) ! Cleanup call df % destroy () end program example Development make help # Show all available commands make build # Build the library make test # Run all tests make docs # Generate documentation make format # Format code make clean # Clean build artifacts Acknowledgments DataFort is built upon the initial work from fortranDF by Joshua Aiken. While the project has been significantly extended and refactored with new features, the original skeleton provided a valuable foundation. Developer Info Renee Gil","tags":"home","url":"index.html"},{"title":"column – DataFort ","text":"type, public :: column Components Type Visibility Attributes Name Initial complex(kind=rk), private, dimension(:), allocatable :: ccol character(len=:), private, dimension(:), allocatable :: charcol integer, public :: dtype = 0 integer(kind=ik), private, dimension(:), allocatable :: icol logical, private :: initialized = .false. logical, private, dimension(:), allocatable :: lcol integer, public :: n real(kind=rk), private, dimension(:), allocatable :: rcol Type-Bound Procedures procedure, public :: changec => change_col_complex private  subroutine change_col_complex (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i complex(kind=rk), intent(in) :: val procedure, public :: changech => change_col_character private  subroutine change_col_character (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i character(len=*), intent(in) :: val procedure, public :: changei => change_col_integer private  subroutine change_col_integer (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i integer(kind=ik), intent(in) :: val procedure, public :: changel => change_col_logical private  subroutine change_col_logical (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i logical, intent(in) :: val procedure, public :: changer => change_col_real private  subroutine change_col_real (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i real(kind=rk), intent(in) :: val procedure, private :: col_constructor_character private  subroutine col_constructor_character (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: dcol procedure, private :: col_constructor_complex private  subroutine col_constructor_complex (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: dcol procedure, private :: col_constructor_integer private  subroutine col_constructor_integer (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: dcol procedure, private :: col_constructor_logical private  subroutine col_constructor_logical (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this logical, intent(in), dimension(:) :: dcol procedure, private :: col_constructor_real private  subroutine col_constructor_real (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: dcol procedure, public :: destroy => col_destructor private  subroutine col_destructor (this) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this procedure, public :: emptyc => col_constructor_alloc_complex private  subroutine col_constructor_alloc_complex (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n procedure, public :: emptych => col_constructor_alloc_character private  subroutine col_constructor_alloc_character (this, n, len) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n integer, intent(in), optional :: len procedure, public :: emptyi => col_constructor_alloc_integer private  subroutine col_constructor_alloc_integer (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n procedure, public :: emptyl => col_constructor_alloc_logical private  subroutine col_constructor_alloc_logical (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n procedure, public :: emptyr => col_constructor_alloc_real private  subroutine col_constructor_alloc_real (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n procedure, private :: get_from_col_character private pure function get_from_col_character (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value character(len=:), dimension(:), allocatable procedure, private :: get_from_col_complex private pure function get_from_col_complex (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value complex(kind=rk), dimension(this % n) procedure, private :: get_from_col_integer private pure function get_from_col_integer (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer(kind=ik), dimension(this % n) procedure, private :: get_from_col_logical private pure function get_from_col_logical (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value logical, dimension(this % n) procedure, private :: get_from_col_real private pure function get_from_col_real (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value real(kind=rk), dimension(this % n) procedure, private :: get_single_col_character private pure function get_single_col_character (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value character(len=:), allocatable procedure, private :: get_single_col_complex private pure function get_single_col_complex (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value complex(kind=rk) procedure, private :: get_single_col_integer private pure function get_single_col_integer (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value integer(kind=ik) procedure, private :: get_single_col_logical private pure function get_single_col_logical (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value logical procedure, private :: get_single_col_real private pure function get_single_col_real (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) procedure, public :: get_type => get_from_col_dtype private pure function get_from_col_dtype (this) result(dtype) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer generic, public :: getc => get_from_col_complex , get_single_col_complex private pure function get_from_col_complex (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value complex(kind=rk), dimension(this % n) private pure function get_single_col_complex (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value complex(kind=rk) generic, public :: getch => get_from_col_character , get_single_col_character private pure function get_from_col_character (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value character(len=:), dimension(:), allocatable private pure function get_single_col_character (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value character(len=:), allocatable generic, public :: geti => get_from_col_integer , get_single_col_integer private pure function get_from_col_integer (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer(kind=ik), dimension(this % n) private pure function get_single_col_integer (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value integer(kind=ik) generic, public :: getl => get_from_col_logical , get_single_col_logical private pure function get_from_col_logical (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value logical, dimension(this % n) private pure function get_single_col_logical (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value logical generic, public :: getr => get_from_col_real , get_single_col_real private pure function get_from_col_real (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value real(kind=rk), dimension(this % n) private pure function get_single_col_real (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) generic, public :: new => col_constructor_real , col_constructor_integer , col_constructor_logical , col_constructor_character , col_constructor_complex private  subroutine col_constructor_real (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: dcol private  subroutine col_constructor_integer (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: dcol private  subroutine col_constructor_logical (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this logical, intent(in), dimension(:) :: dcol private  subroutine col_constructor_character (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: dcol private  subroutine col_constructor_complex (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: dcol Source Code type :: column private integer , public :: dtype = 0 ! no type integer , public :: n ! elements in column ! arrays to hold data ! only one (associated with dtype) will ever be allocated real ( rk ), dimension (:), allocatable :: rcol integer ( ik ), dimension (:), allocatable :: icol logical , dimension (:), allocatable :: lcol character ( len = :), dimension (:), allocatable :: charcol complex ( rk ), dimension (:), allocatable :: ccol logical :: initialized = . false . contains private ! empty constructors procedure , public :: emptyr => col_constructor_alloc_real procedure , public :: emptyi => col_constructor_alloc_integer procedure , public :: emptyl => col_constructor_alloc_logical procedure , public :: emptych => col_constructor_alloc_character procedure , public :: emptyc => col_constructor_alloc_complex ! constructor/setter combo procedure :: col_constructor_real , & col_constructor_integer , & col_constructor_logical , & col_constructor_character , & col_constructor_complex generic , public :: new => col_constructor_real , & col_constructor_integer , & col_constructor_logical , & col_constructor_character , & col_constructor_complex ! destructor procedure , public :: destroy => col_destructor ! get data type procedure , public :: get_type => get_from_col_dtype ! get either whole column as array or single value procedure :: get_from_col_real , & get_from_col_integer , & get_from_col_logical , & get_from_col_character , & get_from_col_complex procedure :: get_single_col_real , & get_single_col_integer , & get_single_col_logical , & get_single_col_character , & get_single_col_complex generic , public :: getr => get_from_col_real , get_single_col_real generic , public :: geti => get_from_col_integer , get_single_col_integer generic , public :: getl => get_from_col_logical , get_single_col_logical generic , public :: getch => get_from_col_character , get_single_col_character generic , public :: getc => get_from_col_complex , get_single_col_complex ! Give element new value (setter) procedure , public :: changer => change_col_real procedure , public :: changei => change_col_integer procedure , public :: changel => change_col_logical procedure , public :: changech => change_col_character procedure , public :: changec => change_col_complex end type column","tags":"","url":"type/column.html"},{"title":"data_frame – DataFort ","text":"type, public :: data_frame Main data frame type for storing heterogeneous tabular data A data frame consists of columns of potentially different types,\nsimilar to a spreadsheet or database table. Each column must have\nthe same number of rows. Type-bound Procedures Constructor/Destructor new([char_len]) - Initialize data frame destroy() - Free memory Basic Info ncols() - Get number of columns nrows() - Get number of rows get_max_char_len() - Get maximum character length header(index) - Get column header by index dtype(index or header) - Get column data type is_initialized() - Check if data frame is initialized Components Type Visibility Attributes Name Initial type( column ), private, dimension(:), allocatable :: data_cols character(len=:), private, dimension(:), allocatable :: headers logical, private :: initialized = .false. integer, private :: max_char_len = MAX_CHAR_LEN_DEFAULT integer, private :: num_cols = 0 logical, private :: with_headers = .false. Type-Bound Procedures procedure, public :: already_header private  function already_header (this, header) result(exists) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value logical procedure, public :: destroy => df_destructor private  subroutine df_destructor (this) Destroy a data frame and free all memory Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this procedure, private :: df_get_col_type_header private pure function df_get_col_type_header (this, header) result(dtype) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer procedure, private :: df_get_col_type_index private pure function df_get_col_type_index (this, index) result(dtype) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value integer generic, public :: dtype => df_get_col_type_header , df_get_col_type_index private pure function df_get_col_type_header (this, header) result(dtype) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer private pure function df_get_col_type_index (this, index) result(dtype) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value integer procedure, public :: find_header_index private pure function find_header_index (this, header) result(index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer procedure, public :: get_data_col private  function get_data_col (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value type( column ) procedure, public :: get_max_char_len => df_get_max_char_len private pure function df_get_max_char_len (this) result(max_len) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer procedure, public :: get_with_headers private pure function get_with_headers (this) result(has_headers) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical procedure, public :: header => get_header private  function get_header (this, index) result(header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value character(len=:), allocatable procedure, public :: increment_num_cols private  subroutine increment_num_cols (this) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this procedure, public :: is_initialized => df_is_initialized private pure function df_is_initialized (this) result(is_init) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical procedure, public :: ncols => df_get_num_cols private pure function df_get_num_cols (this) result(num_cols) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer procedure, public :: new => df_constructor private  subroutine df_constructor (this, char_len) Initialize a new data frame Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), optional :: char_len procedure, public :: nrows => df_get_num_rows private pure function df_get_num_rows (this) result(num_rows) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer procedure, public :: resize_storage private  subroutine resize_storage (this) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this procedure, public :: set_data_col private  subroutine set_data_col (this, index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: index type( column ), intent(in) :: col procedure, public :: set_header_at_index private  subroutine set_header_at_index (this, index, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: index character(len=*), intent(in) :: header procedure, public :: set_with_headers private  subroutine set_with_headers (this, has_headers) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this logical, intent(in) :: has_headers procedure, public :: validate_column_addition private  subroutine validate_column_addition (this, header, col_size) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this character(len=*), intent(in), optional :: header integer, intent(in) :: col_size Source Code type :: data_frame private integer :: num_cols = 0 , max_char_len = MAX_CHAR_LEN_DEFAULT logical :: with_headers = . false . character ( len = :), dimension (:), allocatable :: headers type ( column ), dimension (:), allocatable :: data_cols logical :: initialized = . false . contains private ! Constructor/Destructor procedure , public :: new => df_constructor procedure , public :: destroy => df_destructor procedure , public :: is_initialized => df_is_initialized ! Basic info procedure , public :: ncols => df_get_num_cols procedure , public :: nrows => df_get_num_rows procedure , public :: get_max_char_len => df_get_max_char_len procedure , public :: header => get_header procedure :: df_get_col_type_header , df_get_col_type_index generic , public :: dtype => df_get_col_type_header , df_get_col_type_index ! Internal utility procedures (public for use by other datafort modules) procedure , public :: already_header procedure , public :: resize_storage procedure , public :: validate_column_addition procedure , public :: find_header_index procedure , public :: get_data_col ! Access to internal column object procedure , public :: set_data_col ! Set internal column object procedure , public :: get_with_headers ! Check if has headers procedure , public :: set_with_headers ! Set headers flag procedure , public :: set_header_at_index ! Set header at specific index procedure , public :: increment_num_cols ! Increment column count end type data_frame","tags":"","url":"type/data_frame.html"},{"title":"transform_func – DataFort","text":"interface public pure function transform_func(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk)","tags":"","url":"interface/transform_func.html"},{"title":"row_func_real – DataFort","text":"interface public  function row_func_real(row_values, num_cols) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: row_values integer, intent(in) :: num_cols Return Value real(kind=rk)","tags":"","url":"interface/row_func_real.html"},{"title":"get_from_col_character – DataFort","text":"private pure function get_from_col_character(this) result(col) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value character(len=:), dimension(:), allocatable Source Code pure function get_from_col_character ( this ) result ( col ) class ( column ), intent ( in ) :: this character ( len = :), dimension (:), allocatable :: col integer :: arr_size , elem_len if ( this % dtype /= CHARACTER_NUM ) error stop 'column is not of type character' ! will cause segfault if col not char type arr_size = size ( this % charcol , dim = 1 ) elem_len = len ( this % charcol ( 1 )) allocate ( character ( elem_len ) :: col ( arr_size )) col = this % charcol end function get_from_col_character","tags":"","url":"proc/get_from_col_character.html"},{"title":"get_from_col_complex – DataFort","text":"private pure function get_from_col_complex(this) result(col) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value complex(kind=rk), dimension(this % n) Source Code pure function get_from_col_complex ( this ) result ( col ) class ( column ), intent ( in ) :: this complex ( rk ), dimension ( this % n ) :: col if ( this % dtype /= COMPLEX_NUM ) error stop 'column is not of type complex' col = this % ccol end function get_from_col_complex","tags":"","url":"proc/get_from_col_complex.html"},{"title":"get_from_col_dtype – DataFort","text":"private pure function get_from_col_dtype(this) result(dtype) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer Source Code pure function get_from_col_dtype ( this ) result ( dtype ) class ( column ), intent ( in ) :: this integer :: dtype dtype = this % dtype end function get_from_col_dtype","tags":"","url":"proc/get_from_col_dtype.html"},{"title":"get_from_col_integer – DataFort","text":"private pure function get_from_col_integer(this) result(col) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer(kind=ik), dimension(this % n) Source Code pure function get_from_col_integer ( this ) result ( col ) class ( column ), intent ( in ) :: this integer ( ik ), dimension ( this % n ) :: col if ( this % dtype /= INTEGER_NUM ) error stop 'column is not of type integer' col = this % icol end function get_from_col_integer","tags":"","url":"proc/get_from_col_integer.html"},{"title":"get_from_col_logical – DataFort","text":"private pure function get_from_col_logical(this) result(col) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value logical, dimension(this % n) Source Code pure function get_from_col_logical ( this ) result ( col ) class ( column ), intent ( in ) :: this logical , dimension ( this % n ) :: col if ( this % dtype /= LOGICAL_NUM ) error stop 'column is not of type logical' col = this % lcol end function get_from_col_logical","tags":"","url":"proc/get_from_col_logical.html"},{"title":"get_from_col_real – DataFort","text":"private pure function get_from_col_real(this) result(col) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value real(kind=rk), dimension(this % n) Source Code pure function get_from_col_real ( this ) result ( col ) class ( column ), intent ( in ) :: this real ( rk ), dimension ( this % n ) :: col if ( this % dtype /= REAL_NUM ) error stop 'column is not of type real' col = this % rcol end function get_from_col_real","tags":"","url":"proc/get_from_col_real.html"},{"title":"get_single_col_character – DataFort","text":"private pure function get_single_col_character(this, i) result(val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value character(len=:), allocatable Source Code pure function get_single_col_character ( this , i ) result ( val ) class ( column ), intent ( in ) :: this integer , intent ( in ) :: i character ( len = :), allocatable :: val if ( this % dtype /= CHARACTER_NUM ) error stop 'column is not of type character' if ( i > this % n ) error stop 'out of bounds attempt on data column' val = this % charcol ( i ) end function get_single_col_character","tags":"","url":"proc/get_single_col_character.html"},{"title":"get_single_col_complex – DataFort","text":"private pure function get_single_col_complex(this, i) result(val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value complex(kind=rk) Source Code pure function get_single_col_complex ( this , i ) result ( val ) class ( column ), intent ( in ) :: this integer , intent ( in ) :: i complex ( rk ) :: val if ( this % dtype /= COMPLEX_NUM ) error stop 'column is not of type complex' if ( i > this % n ) error stop 'out of bounds attempt on data column' val = this % ccol ( i ) end function get_single_col_complex","tags":"","url":"proc/get_single_col_complex.html"},{"title":"get_single_col_integer – DataFort","text":"private pure function get_single_col_integer(this, i) result(val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value integer(kind=ik) Source Code pure function get_single_col_integer ( this , i ) result ( val ) class ( column ), intent ( in ) :: this integer , intent ( in ) :: i integer ( ik ) :: val if ( this % dtype /= INTEGER_NUM ) error stop 'column is not of type integer' if ( i > this % n ) error stop 'out of bounds attempt on data column' val = this % icol ( i ) end function get_single_col_integer","tags":"","url":"proc/get_single_col_integer.html"},{"title":"get_single_col_logical – DataFort","text":"private pure function get_single_col_logical(this, i) result(val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value logical Source Code pure function get_single_col_logical ( this , i ) result ( val ) class ( column ), intent ( in ) :: this integer , intent ( in ) :: i logical :: val if ( this % dtype /= LOGICAL_NUM ) error stop 'column is not of type logical' if ( i > this % n ) error stop 'out of bounds attempt on data column' val = this % lcol ( i ) end function get_single_col_logical","tags":"","url":"proc/get_single_col_logical.html"},{"title":"get_single_col_real – DataFort","text":"private pure function get_single_col_real(this, i) result(val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) Source Code pure function get_single_col_real ( this , i ) result ( val ) class ( column ), intent ( in ) :: this integer , intent ( in ) :: i real ( rk ) :: val if ( this % dtype /= REAL_NUM ) error stop 'column is not of type real' if ( i > this % n ) error stop 'out of bounds attempt on data column' val = this % rcol ( i ) end function get_single_col_real","tags":"","url":"proc/get_single_col_real.html"},{"title":"change_col_character – DataFort","text":"private  subroutine change_col_character(this, i, val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i character(len=*), intent(in) :: val Source Code subroutine change_col_character ( this , i , val ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: i character ( len =* ), intent ( in ) :: val if ( this % dtype /= CHARACTER_NUM ) error stop 'column is not of type character' this % charcol ( i ) = val end subroutine change_col_character","tags":"","url":"proc/change_col_character.html"},{"title":"change_col_complex – DataFort","text":"private  subroutine change_col_complex(this, i, val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i complex(kind=rk), intent(in) :: val Source Code subroutine change_col_complex ( this , i , val ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: i complex ( rk ), intent ( in ) :: val if ( this % dtype /= COMPLEX_NUM ) error stop 'column is not of type complex' this % ccol ( i ) = val end subroutine change_col_complex","tags":"","url":"proc/change_col_complex.html"},{"title":"change_col_integer – DataFort","text":"private  subroutine change_col_integer(this, i, val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i integer(kind=ik), intent(in) :: val Source Code subroutine change_col_integer ( this , i , val ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: i integer ( ik ), intent ( in ) :: val if ( this % dtype /= INTEGER_NUM ) error stop 'column is not of type integer' this % icol ( i ) = val end subroutine change_col_integer","tags":"","url":"proc/change_col_integer.html"},{"title":"change_col_logical – DataFort","text":"private  subroutine change_col_logical(this, i, val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i logical, intent(in) :: val Source Code subroutine change_col_logical ( this , i , val ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: i logical , intent ( in ) :: val if ( this % dtype /= LOGICAL_NUM ) error stop 'column is not of type logical' this % lcol ( i ) = val end subroutine change_col_logical","tags":"","url":"proc/change_col_logical.html"},{"title":"change_col_real – DataFort","text":"private  subroutine change_col_real(this, i, val) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i real(kind=rk), intent(in) :: val Source Code subroutine change_col_real ( this , i , val ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: i real ( rk ), intent ( in ) :: val if ( this % dtype /= REAL_NUM ) error stop 'column is not of type real' this % rcol ( i ) = val end subroutine change_col_real","tags":"","url":"proc/change_col_real.html"},{"title":"col_constructor_alloc_character – DataFort","text":"private  subroutine col_constructor_alloc_character(this, n, len) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n integer, intent(in), optional :: len Source Code subroutine col_constructor_alloc_character ( this , n , len ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: n integer , intent ( in ), optional :: len integer :: char_len if ( present ( len )) then char_len = len else char_len = MAX_CHAR_LEN_DEFAULT end if if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = CHARACTER_NUM this % n = n allocate ( character ( len = char_len ) :: this % charcol ( n )) end subroutine col_constructor_alloc_character","tags":"","url":"proc/col_constructor_alloc_character.html"},{"title":"col_constructor_alloc_complex – DataFort","text":"private  subroutine col_constructor_alloc_complex(this, n) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n Source Code subroutine col_constructor_alloc_complex ( this , n ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: n if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = COMPLEX_NUM this % n = n allocate ( this % ccol ( n )) end subroutine col_constructor_alloc_complex","tags":"","url":"proc/col_constructor_alloc_complex.html"},{"title":"col_constructor_alloc_integer – DataFort","text":"private  subroutine col_constructor_alloc_integer(this, n) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n Source Code subroutine col_constructor_alloc_integer ( this , n ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: n if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = INTEGER_NUM this % n = n allocate ( this % icol ( n )) end subroutine col_constructor_alloc_integer","tags":"","url":"proc/col_constructor_alloc_integer.html"},{"title":"col_constructor_alloc_logical – DataFort","text":"private  subroutine col_constructor_alloc_logical(this, n) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n Source Code subroutine col_constructor_alloc_logical ( this , n ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: n if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = LOGICAL_NUM this % n = n allocate ( this % lcol ( n )) end subroutine col_constructor_alloc_logical","tags":"","url":"proc/col_constructor_alloc_logical.html"},{"title":"col_constructor_alloc_real – DataFort","text":"private  subroutine col_constructor_alloc_real(this, n) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n Source Code subroutine col_constructor_alloc_real ( this , n ) class ( column ), intent ( inout ) :: this integer , intent ( in ) :: n if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = REAL_NUM this % n = n allocate ( this % rcol ( n )) end subroutine col_constructor_alloc_real","tags":"","url":"proc/col_constructor_alloc_real.html"},{"title":"col_constructor_character – DataFort","text":"private  subroutine col_constructor_character(this, dcol) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: dcol Source Code subroutine col_constructor_character ( this , dcol ) class ( column ), intent ( inout ) :: this character ( len =* ), dimension (:), intent ( in ) :: dcol integer :: elem_len if ( this % initialized ) call this % destroy () this % initialized = . true . this % n = size ( dcol , dim = 1 ) elem_len = len ( dcol ( 1 )) this % dtype = CHARACTER_NUM allocate ( character ( elem_len ) :: this % charcol ( this % n )) this % charcol = dcol end subroutine col_constructor_character","tags":"","url":"proc/col_constructor_character.html"},{"title":"col_constructor_complex – DataFort","text":"private  subroutine col_constructor_complex(this, dcol) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: dcol Source Code subroutine col_constructor_complex ( this , dcol ) class ( column ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: dcol if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = COMPLEX_NUM this % n = size ( dcol , dim = 1 ) allocate ( this % ccol ( this % n )) this % ccol = dcol end subroutine col_constructor_complex","tags":"","url":"proc/col_constructor_complex.html"},{"title":"col_constructor_integer – DataFort","text":"private  subroutine col_constructor_integer(this, dcol) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: dcol Source Code subroutine col_constructor_integer ( this , dcol ) class ( column ), intent ( inout ) :: this integer ( ik ), dimension (:), intent ( in ) :: dcol if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = INTEGER_NUM this % n = size ( dcol , dim = 1 ) allocate ( this % icol ( this % n )) this % icol = dcol end subroutine col_constructor_integer","tags":"","url":"proc/col_constructor_integer.html"},{"title":"col_constructor_logical – DataFort","text":"private  subroutine col_constructor_logical(this, dcol) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this logical, intent(in), dimension(:) :: dcol Source Code subroutine col_constructor_logical ( this , dcol ) class ( column ), intent ( inout ) :: this logical , dimension (:), intent ( in ) :: dcol if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = LOGICAL_NUM this % n = size ( dcol , dim = 1 ) allocate ( this % lcol ( this % n )) this % lcol = dcol end subroutine col_constructor_logical","tags":"","url":"proc/col_constructor_logical.html"},{"title":"col_constructor_real – DataFort","text":"private  subroutine col_constructor_real(this, dcol) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: dcol Source Code subroutine col_constructor_real ( this , dcol ) class ( column ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: dcol if ( this % initialized ) call this % destroy () this % initialized = . true . this % dtype = REAL_NUM this % n = size ( dcol , dim = 1 ) allocate ( this % rcol ( this % n )) this % rcol = dcol end subroutine col_constructor_real","tags":"","url":"proc/col_constructor_real.html"},{"title":"col_destructor – DataFort","text":"private  subroutine col_destructor(this) Type Bound column Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this Source Code subroutine col_destructor ( this ) class ( column ), intent ( inout ) :: this if ( allocated ( this % rcol )) deallocate ( this % rcol ) if ( allocated ( this % icol )) deallocate ( this % icol ) if ( allocated ( this % lcol )) deallocate ( this % lcol ) if ( allocated ( this % ccol )) deallocate ( this % ccol ) if ( allocated ( this % charcol )) deallocate ( this % charcol ) end subroutine col_destructor","tags":"","url":"proc/col_destructor.html"},{"title":"add_csv_column – DataFort","text":"private  subroutine add_csv_column(df, data_strings, headers, col_index, has_headers) Add a column with automatic type detection Helper subroutine that detects the data type from string data and\nadds the appropriate typed column to the data frame. @param[in,out] df The data frame to add the column to\n@param[in] data_strings Array of string values to convert and add\n@param[in] headers Optional array of header names\n@param[in] col_index Index of the column being added\n@param[in] has_headers Whether the data frame has headers Note Type detection priority: integer -> real -> logical -> character Note NaN values are preserved for numeric types Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df character(len=*), intent(in), dimension(:) :: data_strings character(len=*), intent(in), optional, dimension(:) :: headers integer, intent(in) :: col_index logical, intent(in) :: has_headers Source Code subroutine add_csv_column ( df , data_strings , headers , col_index , has_headers ) type ( data_frame ), intent ( inout ) :: df character ( len =* ), dimension (:), intent ( in ) :: data_strings character ( len =* ), dimension (:), intent ( in ), optional :: headers integer , intent ( in ) :: col_index logical , intent ( in ) :: has_headers integer :: data_type , i , iostat real ( rk ), allocatable :: real_data (:) integer ( ik ), allocatable :: int_data (:) logical , allocatable :: logical_data (:) real ( rk ) :: real_val integer ( ik ) :: int_val character ( len = 100 ) :: trimmed_str ! Initialize NaN constant if needed call init_nan () ! Detect data type from first non-empty, non-NaN value data_type = CHARACTER_NUM do i = 1 , size ( data_strings ) trimmed_str = trim ( adjustl ( data_strings ( i ))) ! Skip empty strings and common NaN representations if ( len ( trim ( trimmed_str )) == 0 . or . & trimmed_str == \"NaN\" . or . trimmed_str == \"nan\" . or . & trimmed_str == \"NA\" . or . trimmed_str == \"na\" . or . & trimmed_str == \"NULL\" . or . trimmed_str == \"null\" . or . & trimmed_str == \"N/A\" . or . trimmed_str == \"n/a\" . or . & trimmed_str == \"-\" . or . trimmed_str == \"\" ) then cycle end if ! Try integer first read ( data_strings ( i ), * , iostat = iostat ) int_val if ( iostat == 0 ) then data_type = INTEGER_NUM exit end if ! Try real read ( data_strings ( i ), * , iostat = iostat ) real_val if ( iostat == 0 ) then data_type = REAL_NUM exit end if ! Try logical if ( trimmed_str == \"T\" . or . trimmed_str == \"F\" . or . & trimmed_str == \"true\" . or . trimmed_str == \"false\" . or . & trimmed_str == \".true.\" . or . trimmed_str == \".false.\" ) then data_type = LOGICAL_NUM exit end if ! Default to character exit end do ! Convert and add the column select case ( data_type ) case ( INTEGER_NUM ) allocate ( int_data ( size ( data_strings ))) do i = 1 , size ( data_strings ) trimmed_str = trim ( adjustl ( data_strings ( i ))) ! Check for NaN representations if ( len ( trim ( trimmed_str )) == 0 . or . & trimmed_str == \"NaN\" . or . trimmed_str == \"nan\" . or . & trimmed_str == \"NA\" . or . trimmed_str == \"na\" . or . & trimmed_str == \"NULL\" . or . trimmed_str == \"null\" . or . & trimmed_str == \"N/A\" . or . trimmed_str == \"n/a\" . or . & trimmed_str == \"-\" ) then int_data ( i ) = NaN_ik else read ( data_strings ( i ), * , iostat = iostat ) int_data ( i ) if ( iostat /= 0 ) int_data ( i ) = NaN_ik ! Use NaN for invalid data end if end do if ( has_headers . and . present ( headers )) then call df_append_integer ( df , int_data , headers ( col_index )) else call df_append_integer ( df , int_data ) end if case ( REAL_NUM ) allocate ( real_data ( size ( data_strings ))) do i = 1 , size ( data_strings ) trimmed_str = trim ( adjustl ( data_strings ( i ))) ! Check for NaN representations if ( len ( trim ( trimmed_str )) == 0 . or . & trimmed_str == \"NaN\" . or . trimmed_str == \"nan\" . or . & trimmed_str == \"NA\" . or . trimmed_str == \"na\" . or . & trimmed_str == \"NULL\" . or . trimmed_str == \"null\" . or . & trimmed_str == \"N/A\" . or . trimmed_str == \"n/a\" . or . & trimmed_str == \"-\" ) then real_data ( i ) = NaN_rk else read ( data_strings ( i ), * , iostat = iostat ) real_data ( i ) if ( iostat /= 0 ) real_data ( i ) = NaN_rk ! Use NaN for invalid data end if end do if ( has_headers . and . present ( headers )) then call df_append_real ( df , real_data , headers ( col_index )) else call df_append_real ( df , real_data ) end if case ( LOGICAL_NUM ) allocate ( logical_data ( size ( data_strings ))) do i = 1 , size ( data_strings ) select case ( trim ( adjustl ( data_strings ( i )))) case ( \"T\" , \"true\" , \".true.\" ) logical_data ( i ) = . true . case ( \"F\" , \"false\" , \".false.\" ) logical_data ( i ) = . false . case default logical_data ( i ) = . false . ! Default for invalid data end select end do if ( has_headers . and . present ( headers )) then call df_append_logical ( df , logical_data , headers ( col_index )) else call df_append_logical ( df , logical_data ) end if case default ! CHARACTER_NUM if ( has_headers . and . present ( headers )) then call df_append_character ( df , data_strings , headers ( col_index )) else call df_append_character ( df , data_strings ) end if end select end subroutine add_csv_column","tags":"","url":"proc/add_csv_column.html"},{"title":"df_read_csv – DataFort","text":"public  subroutine df_read_csv(df, filename, has_headers) Import CSV file into data frame Reads a CSV file and populates the data frame with automatic type detection.\nSupports integer, real, logical, and character data types. @param[in,out] df The data frame to populate (will be initialized)\n@param[in] filename Path to the input CSV file\n@param[in] has_headers Whether the first row contains column headers Note The data frame will be reinitialized (destroyed and recreated) Note Type detection occurs on the first non-empty, non-NaN value Note Supported NaN representations: NaN, NA, NULL, N/A, -, (empty) Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df character(len=*), intent(in) :: filename logical, intent(in) :: has_headers Source Code subroutine df_read_csv ( df , filename , has_headers ) type ( data_frame ), intent ( inout ) :: df character ( len =* ), intent ( in ) :: filename logical , intent ( in ) :: has_headers integer :: unit , iostat , num_lines , num_cols , i , j character ( len = 1000 ) :: line character ( len = 100 ), allocatable :: fields (:), headers (:) character ( len = 100 ), allocatable :: all_data (:, :) ! Open file open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = iostat ) if ( iostat /= 0 ) error stop \"Cannot open CSV file\" ! Count lines num_lines = 0 do read ( unit , '(a)' , iostat = iostat ) line if ( iostat /= 0 ) exit num_lines = num_lines + 1 end do rewind ( unit ) if ( num_lines == 0 ) then close ( unit ) error stop \"Empty CSV file\" end if ! Read first line to determine number of columns read ( unit , '(a)' , iostat = iostat ) line if ( iostat /= 0 ) then close ( unit ) error stop \"Cannot read CSV file\" end if call parse_csv_line ( line , fields ) num_cols = size ( fields ) ! Allocate storage if ( has_headers ) then allocate ( headers ( num_cols )) allocate ( all_data ( num_lines - 1 , num_cols )) headers = fields else allocate ( all_data ( num_lines , num_cols )) all_data ( 1 , :) = fields rewind ( unit ) read ( unit , '(a)' ) line ! skip the line we already processed end if ! Read remaining data do i = 1 , size ( all_data , 1 ) read ( unit , '(a)' , iostat = iostat ) line if ( iostat /= 0 ) exit call parse_csv_line ( line , fields ) if ( size ( fields ) /= num_cols ) then close ( unit ) error stop \"Inconsistent number of columns in CSV\" end if all_data ( i , :) = fields end do close ( unit ) ! Initialize data frame call df % new () ! Add columns with automatic type detection do j = 1 , num_cols call add_csv_column ( df , all_data (:, j ), headers , j , has_headers ) end do deallocate ( fields , all_data ) if ( allocated ( headers )) deallocate ( headers ) end subroutine df_read_csv","tags":"","url":"proc/df_read_csv.html"},{"title":"df_write_console – DataFort","text":"public  subroutine df_write_console(df, unit) Display data frame in console Prints the data frame in a formatted table to the console or specified unit.\nIncludes headers (if present) and a separator line. @param[in] df The data frame to display\n@param[in] unit Optional output unit (default: 6 for stdout) Note Column width is fixed at 12 characters Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in), optional :: unit Source Code subroutine df_write_console ( df , unit ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ), optional :: unit integer :: out_unit , i , j , dtype , col_width integer :: num_cols , num_rows type ( column ) :: data_col logical :: has_headers if ( present ( unit )) then out_unit = unit else out_unit = 6 ! stdout end if num_cols = df % ncols () num_rows = df % nrows () has_headers = df % get_with_headers () if ( num_cols == 0 ) then write ( out_unit , '(a)' ) \"Empty data frame\" return end if col_width = 12 ! Fixed column width for formatting ! Write headers if present if ( has_headers ) then do i = 1 , num_cols write ( out_unit , '(a12)' , advance = 'no' ) df % header ( i ) end do write ( out_unit , '(a)' ) '' ! Write separator line do i = 1 , num_cols write ( out_unit , '(a12)' , advance = 'no' ) repeat ( '-' , col_width ) end do write ( out_unit , '(a)' ) '' end if ! Write data do j = 1 , num_rows do i = 1 , num_cols data_col = df % get_data_col ( i ) dtype = data_col % get_type () select case ( dtype ) case ( REAL_NUM ) write ( out_unit , '(g12.4)' , advance = 'no' ) data_col % getr ( j ) case ( INTEGER_NUM ) write ( out_unit , '(i12)' , advance = 'no' ) data_col % geti ( j ) case ( LOGICAL_NUM ) if ( data_col % getl ( j )) then write ( out_unit , '(a12)' , advance = 'no' ) 'T' else write ( out_unit , '(a12)' , advance = 'no' ) 'F' end if case ( CHARACTER_NUM ) write ( out_unit , '(a12)' , advance = 'no' ) data_col % getch ( j ) case ( COMPLEX_NUM ) write ( out_unit , '(\"(\",f5.2,\",\",f5.2,\")\")' , advance = 'no' ) data_col % getc ( j ) end select end do write ( out_unit , '(a)' ) '' end do end subroutine df_write_console","tags":"","url":"proc/df_write_console.html"},{"title":"df_write_csv – DataFort","text":"public  subroutine df_write_csv(df, filename) Export data frame to CSV file Writes the data frame to a CSV file with optional headers.\nHandles all data types: real, integer, logical, character, and complex. @param[in] df The data frame to export\n@param[in] filename Path to the output CSV file Note Character values are quoted in the output Note Complex values are written as (real,imag) Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df character(len=*), intent(in) :: filename Source Code subroutine df_write_csv ( df , filename ) type ( data_frame ), intent ( in ) :: df character ( len =* ), intent ( in ) :: filename integer :: unit , i , j , dtype integer :: num_cols , num_rows type ( column ) :: data_col logical :: has_headers open ( newunit = unit , file = filename , status = 'replace' , action = 'write' ) num_cols = df % ncols () num_rows = df % nrows () has_headers = df % get_with_headers () ! Write headers if present if ( has_headers ) then do i = 1 , num_cols if ( i > 1 ) write ( unit , '(a)' , advance = 'no' ) ',' write ( unit , '(a)' , advance = 'no' ) trim ( df % header ( i )) end do write ( unit , '(a)' ) '' end if ! Write data do j = 1 , num_rows do i = 1 , num_cols if ( i > 1 ) write ( unit , '(a)' , advance = 'no' ) ',' data_col = df % get_data_col ( i ) dtype = data_col % get_type () select case ( dtype ) case ( REAL_NUM ) write ( unit , '(g0)' , advance = 'no' ) data_col % getr ( j ) case ( INTEGER_NUM ) write ( unit , '(i0)' , advance = 'no' ) data_col % geti ( j ) case ( LOGICAL_NUM ) write ( unit , '(l1)' , advance = 'no' ) data_col % getl ( j ) case ( CHARACTER_NUM ) write ( unit , '(a)' , advance = 'no' ) '\"' // trim ( data_col % getch ( j )) // '\"' case ( COMPLEX_NUM ) write ( unit , '(\"(\",g0,\",\",g0,\")\")' , advance = 'no' ) data_col % getc ( j ) end select end do write ( unit , '(a)' ) '' end do close ( unit ) end subroutine df_write_csv","tags":"","url":"proc/df_write_csv.html"},{"title":"parse_csv_line – DataFort","text":"private  subroutine parse_csv_line(line, fields) Parse a CSV line into fields Helper subroutine that splits a CSV line into individual fields,\nhandling quoted strings and commas within quotes. @param[in] line The CSV line to parse\n@param[out] fields Array of parsed field values Note Supports quoted fields with embedded commas Note Maximum 50 fields per line Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=100), intent(out), allocatable :: fields (:) Source Code subroutine parse_csv_line ( line , fields ) character ( len =* ), intent ( in ) :: line character ( len = 100 ), allocatable , intent ( out ) :: fields (:) integer :: i , start , field_count , len_line logical :: in_quotes , is_delimiter character ( len = 100 ) :: temp_fields ( 50 ) ! Max 50 fields character ( len = :), allocatable :: trimmed_line trimmed_line = trim ( line ) len_line = len ( trimmed_line ) if ( len_line == 0 ) then allocate ( fields ( 0 )) return end if field_count = 0 start = 1 in_quotes = . false . do i = 1 , len_line + 1 is_delimiter = . false . ! Check for quotes within bounds if ( i <= len_line ) then if ( trimmed_line ( i : i ) == '\"' ) then in_quotes = . not . in_quotes cycle end if ! Check if current character is a delimiter if ( trimmed_line ( i : i ) == ',' . and . . not . in_quotes ) then is_delimiter = . true . end if end if ! Process field if we hit a delimiter or end of line if ( i > len_line . or . is_delimiter ) then field_count = field_count + 1 if ( field_count > 50 ) error stop \"Too many fields in CSV line\" ! Extract the field if ( i == start . or . start > len_line ) then temp_fields ( field_count ) = \"\" else if ( i > len_line ) then temp_fields ( field_count ) = trim ( adjustl ( trimmed_line ( start : len_line ))) else temp_fields ( field_count ) = trim ( adjustl ( trimmed_line ( start : i - 1 ))) end if ! Remove surrounding quotes if present if ( len ( trim ( temp_fields ( field_count ))) >= 2 ) then if ( temp_fields ( field_count ) ( 1 : 1 ) == '\"' . and . & temp_fields ( field_count ) ( len ( trim ( temp_fields ( field_count ))): len ( trim ( temp_fields ( field_count )))) == '\"' ) then temp_fields ( field_count ) = temp_fields ( field_count ) ( 2 : len ( trim ( temp_fields ( field_count ))) - 1 ) end if end if end if start = i + 1 end if end do allocate ( fields ( field_count )) fields = temp_fields ( 1 : field_count ) end subroutine parse_csv_line","tags":"","url":"proc/parse_csv_line.html"},{"title":"already_header – DataFort","text":"private  function already_header(this, header) result(exists) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value logical Source Code function already_header ( this , header ) result ( exists ) class ( data_frame ), intent ( in ) :: this character ( len =* ), intent ( in ) :: header logical :: exists integer :: i character ( len = :), allocatable :: trimmed_header exists = . false . if (. not . this % with_headers ) return trimmed_header = trim ( adjustl ( header )) do i = 1 , this % num_cols if ( trim ( adjustl ( this % headers ( i ))) == trimmed_header ) then exists = . true . exit end if end do end function already_header","tags":"","url":"proc/already_header.html"},{"title":"df_get_col_type_header – DataFort","text":"private pure function df_get_col_type_header(this, header) result(dtype) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer Source Code pure function df_get_col_type_header ( this , header ) result ( dtype ) class ( data_frame ), intent ( in ) :: this character ( len =* ), intent ( in ) :: header integer :: dtype integer :: ind ind = this % find_header_index ( header ) dtype = this % data_cols ( ind ) % get_type () end function df_get_col_type_header","tags":"","url":"proc/df_get_col_type_header.html"},{"title":"df_get_col_type_index – DataFort","text":"private pure function df_get_col_type_index(this, index) result(dtype) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value integer Source Code pure function df_get_col_type_index ( this , index ) result ( dtype ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: index integer :: dtype if ( index < 1 . or . index > this % num_cols ) error stop \"column index out of range\" dtype = this % data_cols ( index ) % get_type () end function df_get_col_type_index","tags":"","url":"proc/df_get_col_type_index.html"},{"title":"df_get_max_char_len – DataFort","text":"private pure function df_get_max_char_len(this) result(max_len) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer Source Code pure function df_get_max_char_len ( this ) result ( max_len ) class ( data_frame ), intent ( in ) :: this integer :: max_len max_len = this % max_char_len end function df_get_max_char_len","tags":"","url":"proc/df_get_max_char_len.html"},{"title":"df_get_num_cols – DataFort","text":"private pure function df_get_num_cols(this) result(num_cols) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer Source Code pure function df_get_num_cols ( this ) result ( num_cols ) class ( data_frame ), intent ( in ) :: this integer :: num_cols num_cols = this % num_cols end function df_get_num_cols","tags":"","url":"proc/df_get_num_cols.html"},{"title":"df_get_num_rows – DataFort","text":"private pure function df_get_num_rows(this) result(num_rows) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer Source Code pure function df_get_num_rows ( this ) result ( num_rows ) class ( data_frame ), intent ( in ) :: this integer :: num_rows if ( this % num_cols == 0 ) then num_rows = 0 else num_rows = this % data_cols ( 1 ) % n end if end function df_get_num_rows","tags":"","url":"proc/df_get_num_rows.html"},{"title":"df_is_initialized – DataFort","text":"private pure function df_is_initialized(this) result(is_init) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical Source Code pure function df_is_initialized ( this ) result ( is_init ) class ( data_frame ), intent ( in ) :: this logical :: is_init is_init = this % initialized end function df_is_initialized","tags":"","url":"proc/df_is_initialized.html"},{"title":"find_header_index – DataFort","text":"private pure function find_header_index(this, header) result(index) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer Source Code pure function find_header_index ( this , header ) result ( index ) class ( data_frame ), intent ( in ) :: this character ( len =* ), intent ( in ) :: header integer :: index integer :: i character ( len = :), allocatable :: trimmed_header if (. not . this % with_headers ) error stop \"data frame has no headers\" trimmed_header = trim ( adjustl ( header )) index = - 1 do i = 1 , this % num_cols if ( trim ( adjustl ( this % headers ( i ))) == trimmed_header ) then index = i exit end if end do if ( index == - 1 ) error stop \"header not found\" end function find_header_index","tags":"","url":"proc/find_header_index.html"},{"title":"get_data_col – DataFort","text":"private  function get_data_col(this, index) result(col) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value type( column ) Source Code function get_data_col ( this , index ) result ( col ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: index type ( column ) :: col if ( index < 1 . or . index > this % num_cols ) error stop \"column index out of range\" col = this % data_cols ( index ) end function get_data_col","tags":"","url":"proc/get_data_col.html"},{"title":"get_header – DataFort","text":"private  function get_header(this, index) result(header) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value character(len=:), allocatable Source Code function get_header ( this , index ) result ( header ) class ( data_frame ), intent ( in ) :: this integer , intent ( in ) :: index character ( len = :), allocatable :: header if (. not . this % with_headers ) error stop \"data frame has no headers\" if ( index < 1 . or . index > this % num_cols ) error stop \"header index out of range\" header = trim ( this % headers ( index )) end function get_header","tags":"","url":"proc/get_header.html"},{"title":"get_with_headers – DataFort","text":"private pure function get_with_headers(this) result(has_headers) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical Source Code pure function get_with_headers ( this ) result ( has_headers ) class ( data_frame ), intent ( in ) :: this logical :: has_headers has_headers = this % with_headers end function get_with_headers","tags":"","url":"proc/get_with_headers.html"},{"title":"df_constructor – DataFort","text":"private  subroutine df_constructor(this, char_len) Initialize a new data frame Creates a new empty data frame with optional character length specification @param[in,out] this The data frame instance\n@param[in] char_len Optional maximum character length for string columns (default: 100) Note If the data frame is already initialized, it will be destroyed first Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), optional :: char_len Source Code subroutine df_constructor ( this , char_len ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ), optional :: char_len if ( this % initialized ) call this % destroy () this % num_cols = 0 this % with_headers = . false . if ( present ( char_len )) then this % max_char_len = char_len else this % max_char_len = MAX_CHAR_LEN_DEFAULT end if this % initialized = . true . end subroutine df_constructor","tags":"","url":"proc/df_constructor.html"},{"title":"df_destructor – DataFort","text":"private  subroutine df_destructor(this) Destroy a data frame and free all memory Deallocates all columns and resets the data frame to uninitialized state @param[in,out] this The data frame instance Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this Source Code subroutine df_destructor ( this ) class ( data_frame ), intent ( inout ) :: this integer :: i if ( allocated ( this % data_cols )) then do i = 1 , size ( this % data_cols ) call this % data_cols ( i ) % destroy () end do deallocate ( this % data_cols ) end if if ( allocated ( this % headers )) deallocate ( this % headers ) this % num_cols = 0 this % with_headers = . false . this % initialized = . false . end subroutine df_destructor","tags":"","url":"proc/df_destructor.html"},{"title":"increment_num_cols – DataFort","text":"private  subroutine increment_num_cols(this) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this Source Code subroutine increment_num_cols ( this ) class ( data_frame ), intent ( inout ) :: this this % num_cols = this % num_cols + 1 end subroutine increment_num_cols","tags":"","url":"proc/increment_num_cols.html"},{"title":"resize_storage – DataFort","text":"private  subroutine resize_storage(this) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this Source Code subroutine resize_storage ( this ) class ( data_frame ), intent ( inout ) :: this type ( column ), dimension (:), allocatable :: temp_cols character ( len = :), dimension (:), allocatable :: temp_headers integer :: new_size , i new_size = this % num_cols + 1 ! Resize columns array if ( allocated ( this % data_cols )) then allocate ( temp_cols ( size ( this % data_cols ))) do i = 1 , size ( this % data_cols ) temp_cols ( i ) = this % data_cols ( i ) end do deallocate ( this % data_cols ) end if allocate ( this % data_cols ( new_size )) if ( allocated ( temp_cols )) then do i = 1 , size ( temp_cols ) this % data_cols ( i ) = temp_cols ( i ) end do deallocate ( temp_cols ) end if ! Resize headers array if needed if ( this % with_headers ) then if ( allocated ( this % headers )) then allocate ( character ( len = this % max_char_len ) :: temp_headers ( size ( this % headers ))) temp_headers = this % headers deallocate ( this % headers ) end if allocate ( character ( len = this % max_char_len ) :: this % headers ( new_size )) if ( allocated ( temp_headers )) then this % headers ( 1 : size ( temp_headers )) = temp_headers deallocate ( temp_headers ) end if end if end subroutine resize_storage","tags":"","url":"proc/resize_storage.html"},{"title":"set_data_col – DataFort","text":"private  subroutine set_data_col(this, index, col) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: index type( column ), intent(in) :: col Source Code subroutine set_data_col ( this , index , col ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: index type ( column ), intent ( in ) :: col if ( index < 1 . or . index > this % num_cols ) error stop \"column index out of range\" this % data_cols ( index ) = col end subroutine set_data_col","tags":"","url":"proc/set_data_col.html"},{"title":"set_header_at_index – DataFort","text":"private  subroutine set_header_at_index(this, index, header) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: index character(len=*), intent(in) :: header Source Code subroutine set_header_at_index ( this , index , header ) class ( data_frame ), intent ( inout ) :: this integer , intent ( in ) :: index character ( len =* ), intent ( in ) :: header if (. not . this % with_headers ) error stop \"data frame has no headers\" if ( index < 1 . or . index > this % num_cols ) error stop \"header index out of range\" this % headers ( index ) = header end subroutine set_header_at_index","tags":"","url":"proc/set_header_at_index.html"},{"title":"set_with_headers – DataFort","text":"private  subroutine set_with_headers(this, has_headers) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this logical, intent(in) :: has_headers Source Code subroutine set_with_headers ( this , has_headers ) class ( data_frame ), intent ( inout ) :: this logical , intent ( in ) :: has_headers this % with_headers = has_headers end subroutine set_with_headers","tags":"","url":"proc/set_with_headers.html"},{"title":"validate_column_addition – DataFort","text":"private  subroutine validate_column_addition(this, header, col_size) Type Bound data_frame Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this character(len=*), intent(in), optional :: header integer, intent(in) :: col_size Source Code subroutine validate_column_addition ( this , header , col_size ) class ( data_frame ), intent ( inout ) :: this character ( len =* ), intent ( in ), optional :: header integer , intent ( in ) :: col_size ! Check row size consistency if ( this % num_cols > 0 . and . col_size /= this % nrows ()) then error stop \"column size must match existing columns\" end if ! Handle headers if ( present ( header )) then if ( this % num_cols == 0 ) then this % with_headers = . true . allocate ( character ( len = this % max_char_len ) :: this % headers ( 0 )) else if (. not . this % with_headers ) then error stop \"cannot add header to data frame without headers\" end if if ( this % already_header ( header )) then error stop \"header already exists\" end if else if ( this % with_headers ) then error stop \"cannot add column without header to data frame with headers\" end if end if end subroutine validate_column_addition","tags":"","url":"proc/validate_column_addition.html"},{"title":"lower – DataFort","text":"private pure elemental function lower(str, begin, end) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character(len=len(str)) Source Code elemental pure function lower ( str , begin , end ) result ( string ) ! ident_25=\"@(#) M_strings lower(3f) Changes a string to lowercase over specified range\" character ( * ), intent ( in ) :: str character ( len ( str )) :: string integer , intent ( in ), optional :: begin , end integer :: i integer :: ibegin , iend integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str ibegin = 1 iend = len_trim ( str ) if ( present ( begin )) then ibegin = min ( max ( 1 , begin ), iend ) end if if ( present ( end )) then iend = max ( 1 , min ( iend , end )) end if do concurrent ( i = ibegin : iend ) ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'A' : 'Z' ) string ( i : i ) = achar ( iachar ( str ( i : i )) - diff ) ! change letter to miniscule case default end select end do end function lower","tags":"","url":"proc/lower.html"},{"title":"split – DataFort","text":"public pure function split(input_line, delimiters, order, nulls) result(array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls Return Value character(len=:), allocatable, (:) Source Code pure function split ( input_line , delimiters , order , nulls ) result ( array ) !----------------------------------------------------------------------------------------------------------------------------------- ! ident_8=\"@(#) M_strings split(3f) parse string on delimiter characters and store tokens into an allocatable array\" !  John S. Urban !----------------------------------------------------------------------------------------------------------------------------------- intrinsic index , min , present , len !----------------------------------------------------------------------------------------------------------------------------------- !  given a line of structure \" par1 par2 par3 ... parn \" store each par(n) into a separate variable in array. !    o by default adjacent delimiters in the input string do not create an empty string in the output array !    o no quoting of delimiters is supported character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: order ! order of output array sequential|[reverse|right] character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable :: array (:) ! output array of tokens !----------------------------------------------------------------------------------------------------------------------------------- integer :: n ! max number of strings INPUT_LINE could split into if all delimiter integer , allocatable :: ibegin (:) ! positions in input string where tokens start integer , allocatable :: iterm (:) ! positions in input string where tokens end character ( len = :), allocatable :: dlim ! string containing delimiter characters character ( len = :), allocatable :: ordr ! string containing order keyword character ( len = :), allocatable :: nlls ! string containing nulls keyword integer :: ii , iiii ! loop parameters used to control print order integer :: icount ! number of tokens found integer :: lgth ! length of input string with trailing spaces trimmed integer :: i10 , i20 , i30 ! loop counters integer :: icol ! pointer into input string as it is being parsed integer :: idlim ! number of delimiter characters integer :: ifound ! where next delimiter character is found in remaining input string data integer :: inotnull ! count strings not composed of delimiters integer :: ireturn ! number of tokens returned integer :: imax ! length of longest token !----------------------------------------------------------------------------------------------------------------------------------- ! decide on value for optional DELIMITERS parameter if ( present ( delimiters )) then ! optional delimiter list was present if ( delimiters /= '' ) then ! if DELIMITERS was specified and not null use it dlim = delimiters else ! DELIMITERS was specified on call as empty string dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified end if else ! no delimiter value was specified dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified end if idlim = len ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( order )) then ; ordr = lower ( adjustl ( order )); else ; ordr = 'sequential' ; end if ! decide on value for optional ORDER parameter if ( present ( nulls )) then ; nlls = lower ( adjustl ( nulls )); else ; nlls = 'ignore' ; end if ! optional parameter !----------------------------------------------------------------------------------------------------------------------------------- n = len ( input_line ) + 1 ! max number of strings INPUT_LINE could split into if all delimiter if ( allocated ( ibegin )) deallocate ( ibegin ) !x! intel compiler says allocated already ? if ( allocated ( iterm )) deallocate ( iterm ) !x! intel compiler says allocated already ? allocate ( ibegin ( n )) ! allocate enough space to hold starting location of tokens if string all tokens allocate ( iterm ( n )) ! allocate enough space to hold ending location of tokens if string all tokens ibegin (:) = 1 iterm (:) = 1 !----------------------------------------------------------------------------------------------------------------------------------- lgth = len ( input_line ) ! lgth is the column position of the last non-blank character icount = 0 ! how many tokens found inotnull = 0 ! how many tokens found not composed of delimiters imax = 0 ! length of longest token found !----------------------------------------------------------------------------------------------------------------------------------- if ( lgth > 0 ) then ! there is at least one non-delimiter in INPUT_LINE if get here icol = 1 ! initialize pointer into input line INFINITE : do i30 = 1 , lgth , 1 ! store into each array element ibegin ( i30 ) = icol ! assume start new token on the character if ( index ( dlim ( 1 : idlim ), input_line ( icol : icol )) == 0 ) then ! if current character is not a delimiter iterm ( i30 ) = lgth ! initially assume no more tokens do i10 = 1 , idlim ! search for next delimiter ifound = index ( input_line ( ibegin ( i30 ): lgth ), dlim ( i10 : i10 )) IF ( ifound > 0 ) then iterm ( i30 ) = min ( iterm ( i30 ), ifound + ibegin ( i30 ) - 2 ) end if end do icol = iterm ( i30 ) + 2 ! next place to look as found end of this token inotnull = inotnull + 1 ! increment count of number of tokens not composed of delimiters else ! character is a delimiter for a null string iterm ( i30 ) = icol - 1 ! record assumed end of string. Will be less than beginning icol = icol + 1 ! advance pointer into input string end if imax = max ( imax , iterm ( i30 ) - ibegin ( i30 ) + 1 ) icount = i30 ! increment count of number of tokens found if ( icol > lgth ) then ! no text left exit INFINITE end if end do INFINITE end if !----------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) ireturn = inotnull case default ireturn = icount end select allocate ( character ( len = imax ) :: array ( ireturn )) ! allocate the array to return !allocate(array(ireturn))                                       ! allocate the array to return !----------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( ordr ))) ! decide which order to store tokens case ( 'reverse' , 'right' ); ii = ireturn ; iiii = - 1 ! last to first case default ; ii = 1 ; iiii = 1 ! first to last end select !----------------------------------------------------------------------------------------------------------------------------------- do i20 = 1 , icount ! fill the array with the tokens that were found if ( iterm ( i20 ) < ibegin ( i20 )) then select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) case default array ( ii ) = ' ' ii = ii + iiii end select else array ( ii ) = input_line ( ibegin ( i20 ): iterm ( i20 )) ii = ii + iiii end if end do !----------------------------------------------------------------------------------------------------------------------------------- end function split","tags":"","url":"proc/split.html"},{"title":"df_correlation_real – DataFort","text":"public  function df_correlation_real(df, col_index1, col_index2) result(corr) Calculate Pearson correlation coefficient between two real columns Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index1 integer, intent(in) :: col_index2 Return Value real(kind=rk) Source Code function df_correlation_real ( df , col_index1 , col_index2 ) result ( corr ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index1 , col_index2 real ( rk ) :: corr real ( rk ), dimension (:), allocatable :: col1 , col2 real ( rk ) :: mean1 , mean2 , std1 , std2 , covariance integer :: i , n type ( column ) :: data_col1 , data_col2 if ( col_index1 < 1 . or . col_index1 > df % ncols ()) error stop \"column index 1 out of range\" if ( col_index2 < 1 . or . col_index2 > df % ncols ()) error stop \"column index 2 out of range\" data_col1 = df % get_data_col ( col_index1 ) data_col2 = df % get_data_col ( col_index2 ) if ( data_col1 % get_type () /= REAL_NUM ) error stop \"column 1 is not real type\" if ( data_col2 % get_type () /= REAL_NUM ) error stop \"column 2 is not real type\" col1 = data_col1 % getr () col2 = data_col2 % getr () n = size ( col1 ) if ( n /= size ( col2 )) error stop \"columns must have same length\" mean1 = df_mean_real ( df , col_index1 ) mean2 = df_mean_real ( df , col_index2 ) std1 = df_std_real ( df , col_index1 ) std2 = df_std_real ( df , col_index2 ) ! Calculate covariance covariance = 0.0_rk do i = 1 , n covariance = covariance + ( col1 ( i ) - mean1 ) * ( col2 ( i ) - mean2 ) end do covariance = covariance / real ( n - 1 , rk ) ! Pearson correlation = covariance / (std1 * std2) if ( std1 > 0.0_rk . and . std2 > 0.0_rk ) then corr = covariance / ( std1 * std2 ) else corr = 0.0_rk ! undefined if either std is zero end if end function df_correlation_real","tags":"","url":"proc/df_correlation_real.html"},{"title":"df_max_integer – DataFort","text":"public  function df_max_integer(df, col_index) result(max_val) Find maximum value in integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value integer(kind=ik) Source Code function df_max_integer ( df , col_index ) result ( max_val ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index integer ( ik ) :: max_val integer ( ik ), dimension (:), allocatable :: col type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" col = data_col % geti () max_val = maxval ( col ) end function df_max_integer","tags":"","url":"proc/df_max_integer.html"},{"title":"df_max_real – DataFort","text":"public  function df_max_real(df, col_index) result(max_val) Find maximum value in real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function df_max_real ( df , col_index ) result ( max_val ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: max_val real ( rk ), dimension (:), allocatable :: col type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= REAL_NUM ) error stop \"column is not real type\" col = data_col % getr () max_val = maxval ( col ) end function df_max_real","tags":"","url":"proc/df_max_real.html"},{"title":"df_mean_integer – DataFort","text":"public  function df_mean_integer(df, col_index) result(avg) Calculate the arithmetic mean of an integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function df_mean_integer ( df , col_index ) result ( avg ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: avg integer ( ik ), dimension (:), allocatable :: col type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" col = data_col % geti () avg = real ( sum ( col ), rk ) / real ( size ( col ), rk ) end function df_mean_integer","tags":"","url":"proc/df_mean_integer.html"},{"title":"df_mean_real – DataFort","text":"public  function df_mean_real(df, col_index) result(avg) Calculate the arithmetic mean of a real column Computes the average value of all elements in a real-valued column @param[in] df The data frame instance\n@param[in] col_index Index of the column (1-based)\n@return Mean value of the column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function df_mean_real ( df , col_index ) result ( avg ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: avg real ( rk ), dimension (:), allocatable :: col type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= REAL_NUM ) error stop \"column is not real type\" col = data_col % getr () avg = sum ( col ) / real ( size ( col ), rk ) end function df_mean_real","tags":"","url":"proc/df_mean_real.html"},{"title":"df_median_integer – DataFort","text":"public  function df_median_integer(df, col_index) result(med) Calculate median of integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function df_median_integer ( df , col_index ) result ( med ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: med integer ( ik ), dimension (:), allocatable :: col , sorted_col integer :: n , mid type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" col = data_col % geti () n = size ( col ) sorted_col = col call quick_sort_integer ( sorted_col , 1 , n ) if ( mod ( n , 2 ) == 1 ) then mid = ( n + 1 ) / 2 med = real ( sorted_col ( mid ), rk ) else mid = n / 2 med = ( real ( sorted_col ( mid ), rk ) + real ( sorted_col ( mid + 1 ), rk )) / 2.0_rk end if end function df_median_integer","tags":"","url":"proc/df_median_integer.html"},{"title":"df_median_real – DataFort","text":"public  function df_median_real(df, col_index) result(med) Calculate median of real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function df_median_real ( df , col_index ) result ( med ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: med real ( rk ), dimension (:), allocatable :: col , sorted_col integer :: n , mid type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= REAL_NUM ) error stop \"column is not real type\" col = data_col % getr () n = size ( col ) sorted_col = col ! Simple bubble sort for median calculation call quick_sort_real ( sorted_col , 1 , n ) if ( mod ( n , 2 ) == 1 ) then mid = ( n + 1 ) / 2 med = sorted_col ( mid ) else mid = n / 2 med = ( sorted_col ( mid ) + sorted_col ( mid + 1 )) / 2.0_rk end if end function df_median_real","tags":"","url":"proc/df_median_real.html"},{"title":"df_min_integer – DataFort","text":"public  function df_min_integer(df, col_index) result(min_val) Find minimum value in integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value integer(kind=ik) Source Code function df_min_integer ( df , col_index ) result ( min_val ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index integer ( ik ) :: min_val integer ( ik ), dimension (:), allocatable :: col type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" col = data_col % geti () min_val = minval ( col ) end function df_min_integer","tags":"","url":"proc/df_min_integer.html"},{"title":"df_min_real – DataFort","text":"public  function df_min_real(df, col_index) result(min_val) Find minimum value in real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function df_min_real ( df , col_index ) result ( min_val ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: min_val real ( rk ), dimension (:), allocatable :: col type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= REAL_NUM ) error stop \"column is not real type\" col = data_col % getr () min_val = minval ( col ) end function df_min_real","tags":"","url":"proc/df_min_real.html"},{"title":"df_percentile_integer – DataFort","text":"public  function df_percentile_integer(df, col_index, percentile) result(perc) Calculate percentile of integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: percentile Return Value real(kind=rk) Source Code function df_percentile_integer ( df , col_index , percentile ) result ( perc ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: percentile real ( rk ) :: perc integer ( ik ), dimension (:), allocatable :: col , sorted_col integer :: n , idx real ( rk ) :: pos type ( column ) :: data_col if ( percentile < 0.0_rk . or . percentile > 10 0.0_rk ) error stop \"percentile must be between 0 and 100\" if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" col = data_col % geti () n = size ( col ) sorted_col = col call quick_sort_integer ( sorted_col , 1 , n ) pos = ( percentile / 10 0.0_rk ) * real ( n - 1 , rk ) + 1.0_rk idx = int ( pos ) if ( idx >= n ) then perc = real ( sorted_col ( n ), rk ) else if ( idx < 1 ) then perc = real ( sorted_col ( 1 ), rk ) else ! Linear interpolation perc = real ( sorted_col ( idx ), rk ) + ( pos - real ( idx , rk )) * & ( real ( sorted_col ( idx + 1 ), rk ) - real ( sorted_col ( idx ), rk )) end if end function df_percentile_integer","tags":"","url":"proc/df_percentile_integer.html"},{"title":"df_percentile_real – DataFort","text":"public  function df_percentile_real(df, col_index, percentile) result(perc) Calculate percentile of real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: percentile Return Value real(kind=rk) Source Code function df_percentile_real ( df , col_index , percentile ) result ( perc ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: percentile real ( rk ) :: perc real ( rk ), dimension (:), allocatable :: col , sorted_col integer :: n , idx real ( rk ) :: pos type ( column ) :: data_col if ( percentile < 0.0_rk . or . percentile > 10 0.0_rk ) error stop \"percentile must be between 0 and 100\" if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= REAL_NUM ) error stop \"column is not real type\" col = data_col % getr () n = size ( col ) sorted_col = col call quick_sort_real ( sorted_col , 1 , n ) pos = ( percentile / 10 0.0_rk ) * real ( n - 1 , rk ) + 1.0_rk idx = int ( pos ) if ( idx >= n ) then perc = sorted_col ( n ) else if ( idx < 1 ) then perc = sorted_col ( 1 ) else ! Linear interpolation perc = sorted_col ( idx ) + ( pos - real ( idx , rk )) * ( sorted_col ( idx + 1 ) - sorted_col ( idx )) end if end function df_percentile_real","tags":"","url":"proc/df_percentile_real.html"},{"title":"df_std_integer – DataFort","text":"public  function df_std_integer(df, col_index) result(stddev) Calculate standard deviation of integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function df_std_integer ( df , col_index ) result ( stddev ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: stddev integer ( ik ), dimension (:), allocatable :: col real ( rk ) :: avg type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" col = data_col % geti () avg = df_mean_integer ( df , col_index ) stddev = sqrt ( sum (( real ( col , rk ) - avg ) ** 2 ) / real ( size ( col ) - 1 , rk )) end function df_std_integer","tags":"","url":"proc/df_std_integer.html"},{"title":"df_std_real – DataFort","text":"public  function df_std_real(df, col_index) result(stddev) Calculate standard deviation of real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function df_std_real ( df , col_index ) result ( stddev ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: stddev real ( rk ), dimension (:), allocatable :: col real ( rk ) :: avg type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= REAL_NUM ) error stop \"column is not real type\" col = data_col % getr () avg = df_mean_real ( df , col_index ) stddev = sqrt ( sum (( col - avg ) ** 2 ) / real ( size ( col ) - 1 , rk )) end function df_std_real","tags":"","url":"proc/df_std_real.html"},{"title":"df_sum_integer – DataFort","text":"public  function df_sum_integer(df, col_index) result(total) Calculate sum of integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value integer(kind=ik) Source Code function df_sum_integer ( df , col_index ) result ( total ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index integer ( ik ) :: total integer ( ik ), dimension (:), allocatable :: col type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" col = data_col % geti () total = sum ( col ) end function df_sum_integer","tags":"","url":"proc/df_sum_integer.html"},{"title":"df_sum_real – DataFort","text":"public  function df_sum_real(df, col_index) result(total) Calculate sum of real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function df_sum_real ( df , col_index ) result ( total ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: total real ( rk ), dimension (:), allocatable :: col type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= REAL_NUM ) error stop \"column is not real type\" col = data_col % getr () total = sum ( col ) end function df_sum_real","tags":"","url":"proc/df_sum_real.html"},{"title":"df_variance_integer – DataFort","text":"public  function df_variance_integer(df, col_index) result(var) Calculate variance of integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function df_variance_integer ( df , col_index ) result ( var ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: var integer ( ik ), dimension (:), allocatable :: col real ( rk ) :: avg type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" col = data_col % geti () avg = df_mean_integer ( df , col_index ) var = sum (( real ( col , rk ) - avg ) ** 2 ) / real ( size ( col ) - 1 , rk ) end function df_variance_integer","tags":"","url":"proc/df_variance_integer.html"},{"title":"df_variance_real – DataFort","text":"public  function df_variance_real(df, col_index) result(var) Calculate variance of real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function df_variance_real ( df , col_index ) result ( var ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: var real ( rk ), dimension (:), allocatable :: col real ( rk ) :: avg type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= REAL_NUM ) error stop \"column is not real type\" col = data_col % getr () avg = df_mean_real ( df , col_index ) var = sum (( col - avg ) ** 2 ) / real ( size ( col ) - 1 , rk ) end function df_variance_real","tags":"","url":"proc/df_variance_real.html"},{"title":"df_describe_numeric – DataFort","text":"public  subroutine df_describe_numeric(df, unit) Print summary statistics for all numeric columns Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in), optional :: unit Source Code subroutine df_describe_numeric ( df , unit ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ), optional :: unit integer :: out_unit , i , dtype character ( len = 25 ) :: col_name type ( column ) :: data_col if ( present ( unit )) then out_unit = unit else out_unit = 6 ! stdout end if write ( out_unit , '(a)' ) \"\" write ( out_unit , '(a)' ) repeat ( '=' , 80 ) write ( out_unit , '(a)' ) \"Numeric Column Statistics\" write ( out_unit , '(a)' ) repeat ( '=' , 80 ) write ( out_unit , '(a)' ) \"\" do i = 1 , df % ncols () data_col = df % get_data_col ( i ) dtype = data_col % get_type () ! Only process real and integer columns if ( dtype == REAL_NUM . or . dtype == INTEGER_NUM ) then if ( df % get_with_headers ()) then col_name = trim ( df % header ( i )) else write ( col_name , '(a,i0)' ) \"Column \" , i end if write ( out_unit , '(a)' ) trim ( col_name ) write ( out_unit , '(a)' ) repeat ( '-' , len ( trim ( col_name ))) if ( dtype == REAL_NUM ) then write ( out_unit , '(a,f12.4)' ) \"  Count:       \" , real ( df % nrows (), rk ) write ( out_unit , '(a,f12.4)' ) \"  Mean:        \" , df_mean_real ( df , i ) write ( out_unit , '(a,f12.4)' ) \"  Std Dev:     \" , df_std_real ( df , i ) write ( out_unit , '(a,f12.4)' ) \"  Min:         \" , df_min_real ( df , i ) write ( out_unit , '(a,f12.4)' ) \"  25%:         \" , df_percentile_real ( df , i , 2 5.0_rk ) write ( out_unit , '(a,f12.4)' ) \"  Median (50%):\" , df_median_real ( df , i ) write ( out_unit , '(a,f12.4)' ) \"  75%:         \" , df_percentile_real ( df , i , 7 5.0_rk ) write ( out_unit , '(a,f12.4)' ) \"  Max:         \" , df_max_real ( df , i ) else ! INTEGER_NUM write ( out_unit , '(a,i12)' ) \"  Count:       \" , df % nrows () write ( out_unit , '(a,f12.2)' ) \"  Mean:        \" , df_mean_integer ( df , i ) write ( out_unit , '(a,f12.2)' ) \"  Std Dev:     \" , df_std_integer ( df , i ) write ( out_unit , '(a,i12)' ) \"  Min:         \" , df_min_integer ( df , i ) write ( out_unit , '(a,f12.2)' ) \"  25%:         \" , df_percentile_integer ( df , i , 2 5.0_rk ) write ( out_unit , '(a,f12.2)' ) \"  Median (50%):\" , df_median_integer ( df , i ) write ( out_unit , '(a,f12.2)' ) \"  75%:         \" , df_percentile_integer ( df , i , 7 5.0_rk ) write ( out_unit , '(a,i12)' ) \"  Max:         \" , df_max_integer ( df , i ) end if write ( out_unit , '(a)' ) \"\" end if end do write ( out_unit , '(a)' ) repeat ( '=' , 80 ) end subroutine df_describe_numeric","tags":"","url":"proc/df_describe_numeric.html"},{"title":"df_inner_join – DataFort","text":"public  function df_inner_join(df1, df2, key_col1, key_col2) result(joined_df) Perform an inner join between two data frames Returns a new data frame containing only rows where the key columns match\nin both data frames. Similar to SQL INNER JOIN. @param[in] df1 The left data frame\n@param[in] df2 The right data frame\n@param[in] key_col1 Column index for join key in left data frame\n@param[in] key_col2 Column index for join key in right data frame\n@return A new data frame with matched rows from both tables Note Key columns must have the same data type (integer, real, or character) Note Right table columns are suffixed with “_right” to avoid name conflicts Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in) :: key_col1 integer, intent(in) :: key_col2 Return Value type( data_frame ) Source Code function df_inner_join ( df1 , df2 , key_col1 , key_col2 ) result ( joined_df ) type ( data_frame ), intent ( in ) :: df1 , df2 integer , intent ( in ) :: key_col1 , key_col2 type ( data_frame ) :: joined_df integer :: i , j , dtype1 , dtype2 , num_matches integer , dimension (:), allocatable :: match_indices_this , match_indices_other logical :: match_found ! Check if key columns are compatible types dtype1 = df1 % dtype ( key_col1 ) dtype2 = df2 % dtype ( key_col2 ) if ( dtype1 /= dtype2 ) then print * , \"Error: Key columns must have the same data type\" call joined_df % new () return end if ! Count matches first num_matches = 0 do i = 1 , df1 % nrows () do j = 1 , df2 % nrows () match_found = . false . select case ( dtype1 ) case ( INTEGER_NUM ) if ( df_get_val_integer ( df1 , i , key_col1 ) == df_get_val_integer ( df2 , j , key_col2 )) then match_found = . true . end if case ( REAL_NUM ) if ( abs ( df_get_val_real ( df1 , i , key_col1 ) - df_get_val_real ( df2 , j , key_col2 )) < 1.0e-10_rk ) then match_found = . true . end if case ( CHARACTER_NUM ) if ( trim ( df_get_val_character ( df1 , i , key_col1 )) == trim ( df_get_val_character ( df2 , j , key_col2 ))) then match_found = . true . end if end select if ( match_found ) then num_matches = num_matches + 1 end if end do end do if ( num_matches == 0 ) then call joined_df % new () return end if ! Allocate arrays to store matching indices allocate ( match_indices_this ( num_matches )) allocate ( match_indices_other ( num_matches )) ! Find all matching pairs num_matches = 0 do i = 1 , df1 % nrows () do j = 1 , df2 % nrows () match_found = . false . select case ( dtype1 ) case ( INTEGER_NUM ) if ( df_get_val_integer ( df1 , i , key_col1 ) == df_get_val_integer ( df2 , j , key_col2 )) then match_found = . true . end if case ( REAL_NUM ) if ( abs ( df_get_val_real ( df1 , i , key_col1 ) - df_get_val_real ( df2 , j , key_col2 )) < 1.0e-10_rk ) then match_found = . true . end if case ( CHARACTER_NUM ) if ( trim ( df_get_val_character ( df1 , i , key_col1 )) == trim ( df_get_val_character ( df2 , j , key_col2 ))) then match_found = . true . end if end select if ( match_found ) then num_matches = num_matches + 1 match_indices_this ( num_matches ) = i match_indices_other ( num_matches ) = j end if end do end do ! Build the joined dataframe call build_joined_dataframe ( df1 , df2 , match_indices_this , match_indices_other , & num_matches , joined_df ) deallocate ( match_indices_this ) deallocate ( match_indices_other ) end function df_inner_join","tags":"","url":"proc/df_inner_join.html"},{"title":"df_left_join – DataFort","text":"public  function df_left_join(df1, df2, key_col1, key_col2) result(joined_df) Perform a left join between two data frames Returns all rows from left df, with matching rows from right df (or NULL) @param[in] df1 The left data frame\n@param[in] df2 The right data frame\n@param[in] key_col1 Column index for join key in left data frame\n@param[in] key_col2 Column index for join key in right data frame\n@return A new data frame with all rows from left and matching rows from right Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in) :: key_col1 integer, intent(in) :: key_col2 Return Value type( data_frame ) Source Code function df_left_join ( df1 , df2 , key_col1 , key_col2 ) result ( joined_df ) type ( data_frame ), intent ( in ) :: df1 , df2 integer , intent ( in ) :: key_col1 , key_col2 type ( data_frame ) :: joined_df integer :: i , j , dtype1 , dtype2 integer , dimension (:), allocatable :: match_indices_this , match_indices_other logical :: match_found integer :: num_rows dtype1 = df1 % dtype ( key_col1 ) dtype2 = df2 % dtype ( key_col2 ) if ( dtype1 /= dtype2 ) then print * , \"Error: Key columns must have the same data type\" call joined_df % new () return end if ! For left join, we need one row for each row in 'df1', possibly more if multiple matches num_rows = 0 allocate ( match_indices_this ( df1 % nrows () * max ( 1 , df2 % nrows ()))) allocate ( match_indices_other ( df1 % nrows () * max ( 1 , df2 % nrows ()))) do i = 1 , df1 % nrows () match_found = . false . do j = 1 , df2 % nrows () select case ( dtype1 ) case ( INTEGER_NUM ) if ( df_get_val_integer ( df1 , i , key_col1 ) == df_get_val_integer ( df2 , j , key_col2 )) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = j match_found = . true . end if case ( REAL_NUM ) if ( abs ( df_get_val_real ( df1 , i , key_col1 ) - df_get_val_real ( df2 , j , key_col2 )) < 1.0e-10_rk ) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = j match_found = . true . end if case ( CHARACTER_NUM ) if ( trim ( df_get_val_character ( df1 , i , key_col1 )) == trim ( df_get_val_character ( df2 , j , key_col2 ))) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = j match_found = . true . end if end select end do ! If no match found, still include the row from 'df1' with NULL for 'df2' if (. not . match_found ) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = - 1 ! -1 indicates no match end if end do call build_joined_dataframe ( df1 , df2 , match_indices_this ( 1 : num_rows ), & match_indices_other ( 1 : num_rows ), num_rows , joined_df ) deallocate ( match_indices_this ) deallocate ( match_indices_other ) end function df_left_join","tags":"","url":"proc/df_left_join.html"},{"title":"df_merge – DataFort","text":"public  function df_merge(df1, df2, on_column, how) result(merged_df) Merge two dataframes on column names (similar to SQL join but using names) @param[in] df1 Left dataframe\n@param[in] df2 Right dataframe\n@param[in] on_column Name of column to join on\n@param[in] how Type of join: “inner”, “left”, “right”, “outer”\n@return Merged dataframe Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 character(len=*), intent(in) :: on_column character(len=*), intent(in) :: how Return Value type( data_frame ) Source Code function df_merge ( df1 , df2 , on_column , how ) result ( merged_df ) type ( data_frame ), intent ( in ) :: df1 , df2 character ( len =* ), intent ( in ) :: on_column , how type ( data_frame ) :: merged_df integer :: col_idx1 , col_idx2 ! Find column indices col_idx1 = df1 % find_header_index ( on_column ) col_idx2 = df2 % find_header_index ( on_column ) if ( col_idx1 == - 1 . or . col_idx2 == - 1 ) then print * , \"Error: Column '\" , trim ( on_column ), \"' not found in one or both dataframes\" call merged_df % new () return end if ! Perform appropriate join based on 'how' select case ( trim ( how )) case ( \"inner\" ) merged_df = df_inner_join ( df1 , df2 , col_idx1 , col_idx2 ) case ( \"left\" ) merged_df = df_left_join ( df1 , df2 , col_idx1 , col_idx2 ) case ( \"right\" ) merged_df = df_right_join ( df1 , df2 , col_idx1 , col_idx2 ) case ( \"outer\" ) merged_df = df_outer_join ( df1 , df2 , col_idx1 , col_idx2 ) case default print * , \"Error: 'how' must be 'inner', 'left', 'right', or 'outer'\" call merged_df % new () end select end function df_merge","tags":"","url":"proc/df_merge.html"},{"title":"df_outer_join – DataFort","text":"public  function df_outer_join(df1, df2, key_col1, key_col2) result(joined_df) Perform an outer join between two data frames Returns all rows from both dataframes @param[in] df1 The left data frame\n@param[in] df2 The right data frame\n@param[in] key_col1 Column index for join key in left data frame\n@param[in] key_col2 Column index for join key in right data frame\n@return A new data frame with all rows from both tables Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in) :: key_col1 integer, intent(in) :: key_col2 Return Value type( data_frame ) Source Code function df_outer_join ( df1 , df2 , key_col1 , key_col2 ) result ( joined_df ) type ( data_frame ), intent ( in ) :: df1 , df2 integer , intent ( in ) :: key_col1 , key_col2 type ( data_frame ) :: joined_df integer :: i , j , dtype1 , dtype2 integer , dimension (:), allocatable :: match_indices_this , match_indices_other logical , dimension (:), allocatable :: other_matched integer :: num_rows logical :: found_match dtype1 = df1 % dtype ( key_col1 ) dtype2 = df2 % dtype ( key_col2 ) if ( dtype1 /= dtype2 ) then print * , \"Error: Key columns must have the same data type\" call joined_df % new () return end if allocate ( other_matched ( df2 % nrows ())) other_matched = . false . num_rows = 0 allocate ( match_indices_this (( df1 % nrows () + df2 % nrows ()) * max ( 1 , max ( df1 % nrows (), df2 % nrows ())))) allocate ( match_indices_other (( df1 % nrows () + df2 % nrows ()) * max ( 1 , max ( df1 % nrows (), df2 % nrows ())))) ! First pass: all rows from 'df1' with matches from 'df2' do i = 1 , df1 % nrows () found_match = . false . do j = 1 , df2 % nrows () select case ( dtype1 ) case ( INTEGER_NUM ) if ( df_get_val_integer ( df1 , i , key_col1 ) == df_get_val_integer ( df2 , j , key_col2 )) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = j other_matched ( j ) = . true . found_match = . true . end if case ( REAL_NUM ) if ( abs ( df_get_val_real ( df1 , i , key_col1 ) - df_get_val_real ( df2 , j , key_col2 )) < 1.0e-10_rk ) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = j other_matched ( j ) = . true . found_match = . true . end if case ( CHARACTER_NUM ) if ( trim ( df_get_val_character ( df1 , i , key_col1 )) == trim ( df_get_val_character ( df2 , j , key_col2 ))) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = j other_matched ( j ) = . true . found_match = . true . end if end select end do if (. not . found_match ) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = i match_indices_other ( num_rows ) = - 1 end if end do ! Second pass: unmatched rows from 'df2' do j = 1 , df2 % nrows () if (. not . other_matched ( j )) then num_rows = num_rows + 1 match_indices_this ( num_rows ) = - 1 match_indices_other ( num_rows ) = j end if end do call build_joined_dataframe ( df1 , df2 , match_indices_this ( 1 : num_rows ), & match_indices_other ( 1 : num_rows ), num_rows , joined_df ) deallocate ( match_indices_this ) deallocate ( match_indices_other ) deallocate ( other_matched ) end function df_outer_join","tags":"","url":"proc/df_outer_join.html"},{"title":"df_right_join – DataFort","text":"public  function df_right_join(df1, df2, key_col1, key_col2) result(joined_df) Perform a right join between two data frames Returns all rows from right df, with matching rows from left df (or NULL) @param[in] df1 The left data frame\n@param[in] df2 The right data frame\n@param[in] key_col1 Column index for join key in left data frame\n@param[in] key_col2 Column index for join key in right data frame\n@return A new data frame with all rows from right and matching rows from left Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in) :: key_col1 integer, intent(in) :: key_col2 Return Value type( data_frame ) Source Code function df_right_join ( df1 , df2 , key_col1 , key_col2 ) result ( joined_df ) type ( data_frame ), intent ( in ) :: df1 , df2 integer , intent ( in ) :: key_col1 , key_col2 type ( data_frame ) :: joined_df ! Right join is just a left join with arguments swapped joined_df = df_left_join ( df2 , df1 , key_col2 , key_col1 ) end function df_right_join","tags":"","url":"proc/df_right_join.html"},{"title":"build_joined_dataframe – DataFort","text":"private  subroutine build_joined_dataframe(df1, df2, indices1, indices2, num_rows, result_df) Helper subroutine to build joined dataframe from match indices @param[in] df1 First dataframe\n@param[in] df2 Second dataframe\n@param[in] indices1 Row indices from df1 (-1 means no match)\n@param[in] indices2 Row indices from df2 (-1 means no match)\n@param[in] num_rows Number of rows in result\n@param[out] result_df Resulting joined dataframe Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in), dimension(:) :: indices1 integer, intent(in), dimension(:) :: indices2 integer, intent(in) :: num_rows type( data_frame ), intent(out) :: result_df Source Code subroutine build_joined_dataframe ( df1 , df2 , indices1 , indices2 , num_rows , result_df ) type ( data_frame ), intent ( in ) :: df1 , df2 integer , dimension (:), intent ( in ) :: indices1 , indices2 integer , intent ( in ) :: num_rows type ( data_frame ), intent ( out ) :: result_df integer :: i , j , row , col_idx , dtype real ( rk ), dimension (:), allocatable :: real_col integer ( ik ), dimension (:), allocatable :: int_col logical , dimension (:), allocatable :: log_col character ( len = :), allocatable :: char_col (:) complex ( rk ), dimension (:), allocatable :: cmplx_col character ( len = 100 ) :: header_name call result_df % new ( max ( df1 % get_max_char_len (), df2 % get_max_char_len ())) ! Add columns from df1 do i = 1 , df1 % ncols () dtype = df1 % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) allocate ( real_col ( num_rows )) do row = 1 , num_rows if ( indices1 ( row ) > 0 ) then real_col ( row ) = df_get_val_real ( df1 , indices1 ( row ), i ) else real_col ( row ) = 0.0_rk ! NULL value end if end do if ( df1 % get_with_headers ()) then header_name = df1 % header ( i ) call df_append_real ( result_df , real_col , trim ( header_name )) else call df_append_real ( result_df , real_col ) end if deallocate ( real_col ) case ( INTEGER_NUM ) allocate ( int_col ( num_rows )) do row = 1 , num_rows if ( indices1 ( row ) > 0 ) then int_col ( row ) = df_get_val_integer ( df1 , indices1 ( row ), i ) else int_col ( row ) = 0_ik ! NULL value end if end do if ( df1 % get_with_headers ()) then header_name = df1 % header ( i ) call df_append_integer ( result_df , int_col , trim ( header_name )) else call df_append_integer ( result_df , int_col ) end if deallocate ( int_col ) case ( LOGICAL_NUM ) allocate ( log_col ( num_rows )) do row = 1 , num_rows if ( indices1 ( row ) > 0 ) then log_col ( row ) = df_get_val_logical ( df1 , indices1 ( row ), i ) else log_col ( row ) = . false . ! NULL value end if end do if ( df1 % get_with_headers ()) then header_name = df1 % header ( i ) call df_append_logical ( result_df , log_col , trim ( header_name )) else call df_append_logical ( result_df , log_col ) end if deallocate ( log_col ) case ( CHARACTER_NUM ) allocate ( character ( len = df1 % get_max_char_len ()) :: char_col ( num_rows )) do row = 1 , num_rows if ( indices1 ( row ) > 0 ) then char_col ( row ) = df_get_val_character ( df1 , indices1 ( row ), i ) else char_col ( row ) = \"NULL\" end if end do if ( df1 % get_with_headers ()) then header_name = df1 % header ( i ) call df_append_character ( result_df , char_col , trim ( header_name )) else call df_append_character ( result_df , char_col ) end if deallocate ( char_col ) case ( COMPLEX_NUM ) allocate ( cmplx_col ( num_rows )) do row = 1 , num_rows if ( indices1 ( row ) > 0 ) then cmplx_col ( row ) = df_get_val_complex ( df1 , indices1 ( row ), i ) else cmplx_col ( row ) = cmplx ( 0.0_rk , 0.0_rk , rk ) end if end do if ( df1 % get_with_headers ()) then header_name = df1 % header ( i ) call df_append_complex ( result_df , cmplx_col , trim ( header_name )) else call df_append_complex ( result_df , cmplx_col ) end if deallocate ( cmplx_col ) end select end do ! Add columns from df2 do i = 1 , df2 % ncols () dtype = df2 % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) allocate ( real_col ( num_rows )) do row = 1 , num_rows if ( indices2 ( row ) > 0 ) then real_col ( row ) = df_get_val_real ( df2 , indices2 ( row ), i ) else real_col ( row ) = 0.0_rk end if end do if ( df2 % get_with_headers ()) then header_name = df2 % header ( i ) call df_append_real ( result_df , real_col , trim ( header_name ) // \"_right\" ) else call df_append_real ( result_df , real_col ) end if deallocate ( real_col ) case ( INTEGER_NUM ) allocate ( int_col ( num_rows )) do row = 1 , num_rows if ( indices2 ( row ) > 0 ) then int_col ( row ) = df_get_val_integer ( df2 , indices2 ( row ), i ) else int_col ( row ) = 0_ik end if end do if ( df2 % get_with_headers ()) then header_name = df2 % header ( i ) call df_append_integer ( result_df , int_col , trim ( header_name ) // \"_right\" ) else call df_append_integer ( result_df , int_col ) end if deallocate ( int_col ) case ( LOGICAL_NUM ) allocate ( log_col ( num_rows )) do row = 1 , num_rows if ( indices2 ( row ) > 0 ) then log_col ( row ) = df_get_val_logical ( df2 , indices2 ( row ), i ) else log_col ( row ) = . false . end if end do if ( df2 % get_with_headers ()) then header_name = df2 % header ( i ) call df_append_logical ( result_df , log_col , trim ( header_name ) // \"_right\" ) else call df_append_logical ( result_df , log_col ) end if deallocate ( log_col ) case ( CHARACTER_NUM ) allocate ( character ( len = df2 % get_max_char_len ()) :: char_col ( num_rows )) do row = 1 , num_rows if ( indices2 ( row ) > 0 ) then char_col ( row ) = df_get_val_character ( df2 , indices2 ( row ), i ) else char_col ( row ) = \"NULL\" end if end do if ( df2 % get_with_headers ()) then header_name = df2 % header ( i ) call df_append_character ( result_df , char_col , trim ( header_name ) // \"_right\" ) else call df_append_character ( result_df , char_col ) end if deallocate ( char_col ) case ( COMPLEX_NUM ) allocate ( cmplx_col ( num_rows )) do row = 1 , num_rows if ( indices2 ( row ) > 0 ) then cmplx_col ( row ) = df_get_val_complex ( df2 , indices2 ( row ), i ) else cmplx_col ( row ) = cmplx ( 0.0_rk , 0.0_rk , rk ) end if end do if ( df2 % get_with_headers ()) then header_name = df2 % header ( i ) call df_append_complex ( result_df , cmplx_col , trim ( header_name ) // \"_right\" ) else call df_append_complex ( result_df , cmplx_col ) end if deallocate ( cmplx_col ) end select end do end subroutine build_joined_dataframe","tags":"","url":"proc/build_joined_dataframe.html"},{"title":"calculate_max_real – DataFort","text":"private  function calculate_max_real(df, col_index) result(max_val) Calculate maximum of a real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function calculate_max_real ( df , col_index ) result ( max_val ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: max_val real ( rk ), dimension (:), allocatable :: col col = df_get_col_real ( df , col_index ) max_val = maxval ( col ) end function calculate_max_real","tags":"","url":"proc/calculate_max_real.html"},{"title":"calculate_mean_real – DataFort","text":"private  function calculate_mean_real(df, col_index) result(avg) Calculate mean of a real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function calculate_mean_real ( df , col_index ) result ( avg ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: avg real ( rk ), dimension (:), allocatable :: col col = df_get_col_real ( df , col_index ) avg = sum ( col ) / real ( size ( col ), rk ) end function calculate_mean_real","tags":"","url":"proc/calculate_mean_real.html"},{"title":"calculate_min_real – DataFort","text":"private  function calculate_min_real(df, col_index) result(min_val) Calculate minimum of a real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function calculate_min_real ( df , col_index ) result ( min_val ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: min_val real ( rk ), dimension (:), allocatable :: col col = df_get_col_real ( df , col_index ) min_val = minval ( col ) end function calculate_min_real","tags":"","url":"proc/calculate_min_real.html"},{"title":"calculate_std_real – DataFort","text":"private  function calculate_std_real(df, col_index) result(stddev) Calculate standard deviation of a real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function calculate_std_real ( df , col_index ) result ( stddev ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ) :: stddev real ( rk ), dimension (:), allocatable :: col real ( rk ) :: avg col = df_get_col_real ( df , col_index ) avg = calculate_mean_real ( df , col_index ) stddev = sqrt ( sum (( col - avg ) ** 2 ) / real ( size ( col ) - 1 , rk )) end function calculate_std_real","tags":"","url":"proc/calculate_std_real.html"},{"title":"df_diff_integer – DataFort","text":"public  function df_diff_integer(df, col_index) result(differences) Calculate differences between consecutive rows (result has n-1 elements) Returns an array where each element is the difference between consecutive values @param[in] df The data frame instance\n@param[in] col_index Index of the column\n@return Array of differences with n-1 elements Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value integer(kind=ik), dimension(:), allocatable Source Code function df_diff_integer ( df , col_index ) result ( differences ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index integer ( ik ), dimension (:), allocatable :: differences integer ( ik ), dimension (:), allocatable :: col integer :: i , n col = df_get_col_integer ( df , col_index ) n = size ( col ) if ( n < 2 ) then allocate ( differences ( 0 )) return end if allocate ( differences ( n - 1 )) do i = 1 , n - 1 differences ( i ) = col ( i + 1 ) - col ( i ) end do end function df_diff_integer","tags":"","url":"proc/df_diff_integer.html"},{"title":"df_diff_real – DataFort","text":"public  function df_diff_real(df, col_index) result(differences) Calculate differences between consecutive rows (result has n-1 elements) Returns an array where each element is the difference between consecutive values @param[in] df The data frame instance\n@param[in] col_index Index of the column\n@return Array of differences with n-1 elements Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk), dimension(:), allocatable Source Code function df_diff_real ( df , col_index ) result ( differences ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: differences real ( rk ), dimension (:), allocatable :: col integer :: i , n col = df_get_col_real ( df , col_index ) n = size ( col ) if ( n < 2 ) then allocate ( differences ( 0 )) return end if allocate ( differences ( n - 1 )) do i = 1 , n - 1 differences ( i ) = col ( i + 1 ) - col ( i ) end do end function df_diff_real","tags":"","url":"proc/df_diff_real.html"},{"title":"df_abs_column_integer – DataFort","text":"public  subroutine df_abs_column_integer(df, col_index) Take absolute value of all elements in an integer column @param[in,out] df The data frame instance\n@param[in] col_index Index of the column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index Source Code subroutine df_abs_column_integer ( df , col_index ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index integer ( ik ), dimension (:), allocatable :: col col = df_get_col_integer ( df , col_index ) col = abs ( col ) call df_set_col_integer ( df , col_index , col ) end subroutine df_abs_column_integer","tags":"","url":"proc/df_abs_column_integer.html"},{"title":"df_abs_column_real – DataFort","text":"public  subroutine df_abs_column_real(df, col_index) Take absolute value of all elements in a real column @param[in,out] df The data frame instance\n@param[in] col_index Index of the column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index Source Code subroutine df_abs_column_real ( df , col_index ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col col = df_get_col_real ( df , col_index ) col = abs ( col ) call df_set_col_real ( df , col_index , col ) end subroutine df_abs_column_real","tags":"","url":"proc/df_abs_column_real.html"},{"title":"df_apply_to_column – DataFort","text":"public  subroutine df_apply_to_column(df, col_index, func) Apply custom function to column Applies a user-defined transformation function to each element in the column @param[in,out] df The data frame instance\n@param[in] col_index Index of the column\n@param[in] func Function to apply (must match transform_func interface) Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index procedure( transform_func ) :: func Source Code subroutine df_apply_to_column ( df , col_index , func ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index procedure ( transform_func ) :: func real ( rk ), dimension (:), allocatable :: col integer :: i col = df_get_col_real ( df , col_index ) do i = 1 , size ( col ) col ( i ) = func ( col ( i )) end do call df_set_col_real ( df , col_index , col ) end subroutine df_apply_to_column","tags":"","url":"proc/df_apply_to_column.html"},{"title":"df_clip_integer – DataFort","text":"public  subroutine df_clip_integer(df, col_index, min_val, max_val) Clip (clamp) values in an integer column to [min_val, max_val] Values below min_val are set to min_val, values above max_val are set to max_val @param[in,out] df The data frame instance\n@param[in] col_index Index of the column\n@param[in] min_val Minimum allowed value\n@param[in] max_val Maximum allowed value Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index integer(kind=ik), intent(in) :: min_val integer(kind=ik), intent(in) :: max_val Source Code subroutine df_clip_integer ( df , col_index , min_val , max_val ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index integer ( ik ), intent ( in ) :: min_val , max_val integer ( ik ), dimension (:), allocatable :: col integer :: i col = df_get_col_integer ( df , col_index ) do i = 1 , size ( col ) col ( i ) = max ( min_val , min ( max_val , col ( i ))) end do call df_set_col_integer ( df , col_index , col ) end subroutine df_clip_integer","tags":"","url":"proc/df_clip_integer.html"},{"title":"df_clip_real – DataFort","text":"public  subroutine df_clip_real(df, col_index, min_val, max_val) Clip (clamp) values in a real column to [min_val, max_val] Values below min_val are set to min_val, values above max_val are set to max_val @param[in,out] df The data frame instance\n@param[in] col_index Index of the column\n@param[in] min_val Minimum allowed value\n@param[in] max_val Maximum allowed value Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: min_val real(kind=rk), intent(in) :: max_val Source Code subroutine df_clip_real ( df , col_index , min_val , max_val ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: min_val , max_val real ( rk ), dimension (:), allocatable :: col integer :: i col = df_get_col_real ( df , col_index ) do i = 1 , size ( col ) col ( i ) = max ( min_val , min ( max_val , col ( i ))) end do call df_set_col_real ( df , col_index , col ) end subroutine df_clip_real","tags":"","url":"proc/df_clip_real.html"},{"title":"df_cumsum_integer – DataFort","text":"public  subroutine df_cumsum_integer(df, col_index) Calculate cumulative sum for an integer column (modifies in place) Each element becomes the sum of all elements up to and including that position @param[in,out] df The data frame instance\n@param[in] col_index Index of the column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index Source Code subroutine df_cumsum_integer ( df , col_index ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index integer ( ik ), dimension (:), allocatable :: col integer :: i col = df_get_col_integer ( df , col_index ) do i = 2 , size ( col ) col ( i ) = col ( i ) + col ( i - 1 ) end do call df_set_col_integer ( df , col_index , col ) end subroutine df_cumsum_integer","tags":"","url":"proc/df_cumsum_integer.html"},{"title":"df_cumsum_real – DataFort","text":"public  subroutine df_cumsum_real(df, col_index) Calculate cumulative sum for a real column (modifies in place) Each element becomes the sum of all elements up to and including that position @param[in,out] df The data frame instance\n@param[in] col_index Index of the column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index Source Code subroutine df_cumsum_real ( df , col_index ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col integer :: i col = df_get_col_real ( df , col_index ) do i = 2 , size ( col ) col ( i ) = col ( i ) + col ( i - 1 ) end do call df_set_col_real ( df , col_index , col ) end subroutine df_cumsum_real","tags":"","url":"proc/df_cumsum_real.html"},{"title":"df_exp_column – DataFort","text":"public  subroutine df_exp_column(df, col_index) Apply exponential to column @param[in,out] df The data frame instance\n@param[in] col_index Index of the column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index Source Code subroutine df_exp_column ( df , col_index ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col col = df_get_col_real ( df , col_index ) col = exp ( col ) call df_set_col_real ( df , col_index , col ) end subroutine df_exp_column","tags":"","url":"proc/df_exp_column.html"},{"title":"df_log_column – DataFort","text":"public  subroutine df_log_column(df, col_index) Apply natural logarithm to column @param[in,out] df The data frame instance\n@param[in] col_index Index of the column Warning Values must be positive Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index Source Code subroutine df_log_column ( df , col_index ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col col = df_get_col_real ( df , col_index ) col = log ( col ) call df_set_col_real ( df , col_index , col ) end subroutine df_log_column","tags":"","url":"proc/df_log_column.html"},{"title":"df_normalize_column_real – DataFort","text":"public  subroutine df_normalize_column_real(df, col_index) Normalize a real column to [0, 1] range Applies min-max normalization: (x - min) / (max - min) @param[in,out] df The data frame instance\n@param[in] col_index Index of the column to normalize Note If all values are the same (range = 0), the column is not modified Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index Source Code subroutine df_normalize_column_real ( df , col_index ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col real ( rk ) :: min_val , max_val , range integer :: i col = df_get_col_real ( df , col_index ) min_val = calculate_min_real ( df , col_index ) max_val = calculate_max_real ( df , col_index ) range = max_val - min_val if ( range > 0.0_rk ) then do i = 1 , size ( col ) col ( i ) = ( col ( i ) - min_val ) / range end do call df_set_col_real ( df , col_index , col ) end if end subroutine df_normalize_column_real","tags":"","url":"proc/df_normalize_column_real.html"},{"title":"df_pow_column – DataFort","text":"public  subroutine df_pow_column(df, col_index, power) Raise column to a power @param[in,out] df The data frame instance\n@param[in] col_index Index of the column\n@param[in] power The exponent to raise each value to Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: power Source Code subroutine df_pow_column ( df , col_index , power ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: power real ( rk ), dimension (:), allocatable :: col col = df_get_col_real ( df , col_index ) col = col ** power call df_set_col_real ( df , col_index , col ) end subroutine df_pow_column","tags":"","url":"proc/df_pow_column.html"},{"title":"df_replace_value_integer – DataFort","text":"public  subroutine df_replace_value_integer(df, col_index, old_value, new_value) Replace all occurrences of a value in an integer column @param[in,out] df The data frame instance\n@param[in] col_index Index of the column\n@param[in] old_value Value to replace\n@param[in] new_value Replacement value Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index integer(kind=ik), intent(in) :: old_value integer(kind=ik), intent(in) :: new_value Source Code subroutine df_replace_value_integer ( df , col_index , old_value , new_value ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index integer ( ik ), intent ( in ) :: old_value , new_value integer ( ik ), dimension (:), allocatable :: col integer :: i col = df_get_col_integer ( df , col_index ) do i = 1 , size ( col ) if ( col ( i ) == old_value ) then col ( i ) = new_value end if end do call df_set_col_integer ( df , col_index , col ) end subroutine df_replace_value_integer","tags":"","url":"proc/df_replace_value_integer.html"},{"title":"df_replace_value_real – DataFort","text":"public  subroutine df_replace_value_real(df, col_index, old_value, new_value) Replace all occurrences of a value in a real column Uses tolerance-based comparison for real values @param[in,out] df The data frame instance\n@param[in] col_index Index of the column\n@param[in] old_value Value to replace\n@param[in] new_value Replacement value Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: old_value real(kind=rk), intent(in) :: new_value Source Code subroutine df_replace_value_real ( df , col_index , old_value , new_value ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: old_value , new_value real ( rk ), dimension (:), allocatable :: col integer :: i real ( rk ), parameter :: tol = 1.0e-10_rk col = df_get_col_real ( df , col_index ) do i = 1 , size ( col ) if ( abs ( col ( i ) - old_value ) < tol ) then col ( i ) = new_value end if end do call df_set_col_real ( df , col_index , col ) end subroutine df_replace_value_real","tags":"","url":"proc/df_replace_value_real.html"},{"title":"df_round_column – DataFort","text":"public  subroutine df_round_column(df, col_index, decimals) Round real column to specified number of decimal places @param[in,out] df The data frame instance\n@param[in] col_index Index of the column\n@param[in] decimals Number of decimal places Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index integer, intent(in) :: decimals Source Code subroutine df_round_column ( df , col_index , decimals ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index integer , intent ( in ) :: decimals real ( rk ), dimension (:), allocatable :: col real ( rk ) :: multiplier integer :: i col = df_get_col_real ( df , col_index ) multiplier = 1 0.0_rk ** decimals do i = 1 , size ( col ) col ( i ) = nint ( col ( i ) * multiplier ) / multiplier end do call df_set_col_real ( df , col_index , col ) end subroutine df_round_column","tags":"","url":"proc/df_round_column.html"},{"title":"df_sqrt_column – DataFort","text":"public  subroutine df_sqrt_column(df, col_index) Apply square root to column @param[in,out] df The data frame instance\n@param[in] col_index Index of the column Warning Values must be non-negative Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index Source Code subroutine df_sqrt_column ( df , col_index ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col col = df_get_col_real ( df , col_index ) col = sqrt ( col ) call df_set_col_real ( df , col_index , col ) end subroutine df_sqrt_column","tags":"","url":"proc/df_sqrt_column.html"},{"title":"df_standardize_column_real – DataFort","text":"public  subroutine df_standardize_column_real(df, col_index) Standardize a real column (z-score: mean=0, std=1) Applies z-score standardization: (x - mean) / std @param[in,out] df The data frame instance\n@param[in] col_index Index of the column to standardize Note If std = 0, the column is not modified Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index Source Code subroutine df_standardize_column_real ( df , col_index ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: col real ( rk ) :: mean_val , std_val integer :: i col = df_get_col_real ( df , col_index ) mean_val = calculate_mean_real ( df , col_index ) std_val = calculate_std_real ( df , col_index ) if ( std_val > 0.0_rk ) then do i = 1 , size ( col ) col ( i ) = ( col ( i ) - mean_val ) / std_val end do call df_set_col_real ( df , col_index , col ) end if end subroutine df_standardize_column_real","tags":"","url":"proc/df_standardize_column_real.html"},{"title":"df_apply_to_all_rows_real – DataFort","text":"public  function df_apply_to_all_rows_real(df, func) result(outputs) Apply a function to all rows Applies a user-defined function to each row in the data frame,\nreturning an array of results. @param[in] df The data frame\n@param[in] func Function to apply (must match row_func_real interface)\n@return Array of results, one per row Example real ( rk ), dimension (:), allocatable :: row_sums row_sums = df_apply_to_all_rows_real ( df , row_sum ) Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df procedure( row_func_real ) :: func Return Value real(kind=rk), dimension(:), allocatable Source Code function df_apply_to_all_rows_real ( df , func ) result ( outputs ) type ( data_frame ), intent ( in ) :: df procedure ( row_func_real ) :: func real ( rk ), dimension (:), allocatable :: outputs integer :: i , n_rows n_rows = df % nrows () allocate ( outputs ( n_rows )) do i = 1 , n_rows outputs ( i ) = df_apply_to_row_real ( df , i , func ) end do end function df_apply_to_all_rows_real","tags":"","url":"proc/df_apply_to_all_rows_real.html"},{"title":"df_apply_to_row_real – DataFort","text":"public  function df_apply_to_row_real(df, row_idx, func) result(output) Apply a function to a specific row Extracts all numeric values from a specified row and applies\na user-defined function to them. Non-numeric columns are skipped. @param[in] df The data frame\n@param[in] row_idx Row index to process\n@param[in] func Function to apply (must match row_func_real interface)\n@return Result of applying the function to the row Example ! Define a function that computes row sum function row_sum ( values , n ) result ( s ) real ( rk ), dimension (:), intent ( in ) :: values integer , intent ( in ) :: n real ( rk ) :: s s = sum ( values ( 1 : n )) end function ! Apply it result = df_apply_to_row_real ( df , 5 , row_sum ) Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: row_idx procedure( row_func_real ) :: func Return Value real(kind=rk) Source Code function df_apply_to_row_real ( df , row_idx , func ) result ( output ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: row_idx procedure ( row_func_real ) :: func real ( rk ) :: output real ( rk ), dimension (:), allocatable :: row_values integer :: i , n_numeric , col_type type ( column ) :: col ! Count numeric columns n_numeric = 0 do i = 1 , df % ncols () col = df % get_data_col ( i ) col_type = col % dtype if ( col_type == REAL_NUM . or . col_type == INTEGER_NUM ) then n_numeric = n_numeric + 1 end if end do ! Allocate and fill row values allocate ( row_values ( n_numeric )) n_numeric = 0 do i = 1 , df % ncols () col = df % get_data_col ( i ) col_type = col % dtype if ( col_type == REAL_NUM ) then n_numeric = n_numeric + 1 row_values ( n_numeric ) = col % getr ( row_idx ) else if ( col_type == INTEGER_NUM ) then n_numeric = n_numeric + 1 row_values ( n_numeric ) = real ( col % geti ( row_idx ), rk ) end if end do ! Apply function output = func ( row_values , n_numeric ) deallocate ( row_values ) end function df_apply_to_row_real","tags":"","url":"proc/df_apply_to_row_real.html"},{"title":"df_empty – DataFort","text":"public pure function df_empty(df) result(is_empty) Check if dataframe is empty (no rows or no columns) @param[in] df The data frame\n@return True if empty, false otherwise Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value logical Source Code pure function df_empty ( df ) result ( is_empty ) type ( data_frame ), intent ( in ) :: df logical :: is_empty is_empty = ( df % nrows () == 0 . or . df % ncols () == 0 ) end function df_empty","tags":"","url":"proc/df_empty.html"},{"title":"df_head – DataFort","text":"public  function df_head(df, n) result(head_df) Return first n rows as a new dataframe @param[in] df The data frame to extract from\n@param[in] n Optional number of rows (default: 6)\n@return New data frame containing first n rows Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in), optional :: n Return Value type( data_frame ) Source Code function df_head ( df , n ) result ( head_df ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ), optional :: n type ( data_frame ) :: head_df integer :: num_rows if ( present ( n )) then num_rows = min ( n , df % nrows ()) else num_rows = min ( 6 , df % nrows ()) ! Default to 6 rows like pandas end if if ( num_rows == 0 . or . df % nrows () == 0 ) then call head_df % new ( df % get_max_char_len ()) return end if head_df = df_slice_rows ( df , 1 , num_rows ) end function df_head","tags":"","url":"proc/df_head.html"},{"title":"df_sample – DataFort","text":"public  function df_sample(df, n, seed) result(sampled_df) Get n random rows from the dataframe @param[in] df The data frame to sample from\n@param[in] n Number of rows to sample\n@param[in] seed Optional random seed\n@return New data frame with sampled rows Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: n integer, intent(in), optional :: seed Return Value type( data_frame ) Source Code function df_sample ( df , n , seed ) result ( sampled_df ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: n integer , intent ( in ), optional :: seed type ( data_frame ) :: sampled_df integer , dimension (:), allocatable :: indices , selected_indices , seed_array integer :: i , j , temp , num_samples , seed_size real :: rand_val num_samples = min ( n , df % nrows ()) if ( num_samples == 0 ) then call sampled_df % new ( df % get_max_char_len ()) return end if ! Initialize random seed if provided if ( present ( seed )) then call random_seed ( size = seed_size ) allocate ( seed_array ( seed_size )) seed_array = seed call random_seed ( put = seed_array ) deallocate ( seed_array ) end if ! Create array of all indices allocate ( indices ( df % nrows ())) do i = 1 , df % nrows () indices ( i ) = i end do ! Fisher-Yates shuffle to get random sample do i = df % nrows (), 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = indices ( i ) indices ( i ) = indices ( j ) indices ( j ) = temp end do ! Take first n shuffled indices allocate ( selected_indices ( num_samples )) selected_indices = indices ( 1 : num_samples ) ! Create sampled dataframe call sampled_df % new ( df % get_max_char_len ()) do i = 1 , df % ncols () call copy_filtered_column ( df , sampled_df , i , selected_indices ) end do deallocate ( indices , selected_indices ) end function df_sample","tags":"","url":"proc/df_sample.html"},{"title":"df_shape – DataFort","text":"public  function df_shape(df) result(dims) Return shape as [nrows, ncols] @param[in] df The data frame\n@return Array of dimensions [nrows, ncols] Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value integer, dimension(2) Source Code function df_shape ( df ) result ( dims ) type ( data_frame ), intent ( in ) :: df integer , dimension ( 2 ) :: dims dims ( 1 ) = df % nrows () dims ( 2 ) = df % ncols () end function df_shape","tags":"","url":"proc/df_shape.html"},{"title":"df_slice_rows – DataFort","text":"private  function df_slice_rows(df, start_row, end_row) result(new_df) Internal: Slice rows to create a new data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: start_row integer, intent(in) :: end_row Return Value type( data_frame ) Source Code function df_slice_rows ( df , start_row , end_row ) result ( new_df ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: start_row , end_row type ( data_frame ) :: new_df integer :: i , j , new_size real ( rk ), allocatable :: real_slice (:) integer ( ik ), allocatable :: int_slice (:) logical , allocatable :: logical_slice (:) character ( len = :), allocatable :: char_slice (:) complex ( rk ), allocatable :: complex_slice (:) type ( column ) :: col if ( start_row < 1 . or . end_row > df % nrows () . or . start_row > end_row ) then error stop \"invalid row range for slicing\" end if new_size = end_row - start_row + 1 call new_df % new ( df % get_max_char_len ()) do i = 1 , df % ncols () col = df % get_data_col ( i ) select case ( col % get_type ()) case ( REAL_NUM ) allocate ( real_slice ( new_size )) do j = 1 , new_size real_slice ( j ) = col % getr ( start_row + j - 1 ) end do if ( df % get_with_headers ()) then call df_append_real ( new_df , real_slice , df % header ( i )) else call df_append_real ( new_df , real_slice ) end if deallocate ( real_slice ) case ( INTEGER_NUM ) allocate ( int_slice ( new_size )) do j = 1 , new_size int_slice ( j ) = col % geti ( start_row + j - 1 ) end do if ( df % get_with_headers ()) then call df_append_integer ( new_df , int_slice , df % header ( i )) else call df_append_integer ( new_df , int_slice ) end if deallocate ( int_slice ) case ( LOGICAL_NUM ) allocate ( logical_slice ( new_size )) do j = 1 , new_size logical_slice ( j ) = col % getl ( start_row + j - 1 ) end do if ( df % get_with_headers ()) then call df_append_logical ( new_df , logical_slice , df % header ( i )) else call df_append_logical ( new_df , logical_slice ) end if deallocate ( logical_slice ) case ( CHARACTER_NUM ) allocate ( character ( len = len ( col % getch ( 1 ))) :: char_slice ( new_size )) do j = 1 , new_size char_slice ( j ) = col % getch ( start_row + j - 1 ) end do if ( df % get_with_headers ()) then call df_append_character ( new_df , char_slice , df % header ( i )) else call df_append_character ( new_df , char_slice ) end if deallocate ( char_slice ) case ( COMPLEX_NUM ) allocate ( complex_slice ( new_size )) do j = 1 , new_size complex_slice ( j ) = col % getc ( start_row + j - 1 ) end do if ( df % get_with_headers ()) then call df_append_complex ( new_df , complex_slice , df % header ( i )) else call df_append_complex ( new_df , complex_slice ) end if deallocate ( complex_slice ) end select end do end function df_slice_rows","tags":"","url":"proc/df_slice_rows.html"},{"title":"df_tail – DataFort","text":"public  function df_tail(df, n) result(tail_df) Return last n rows as a new dataframe @param[in] df The data frame to extract from\n@param[in] n Optional number of rows (default: 6)\n@return New data frame containing last n rows Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in), optional :: n Return Value type( data_frame ) Source Code function df_tail ( df , n ) result ( tail_df ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ), optional :: n type ( data_frame ) :: tail_df integer :: num_rows , start_row if ( present ( n )) then num_rows = min ( n , df % nrows ()) else num_rows = min ( 6 , df % nrows ()) ! Default to 6 rows like pandas end if if ( num_rows == 0 . or . df % nrows () == 0 ) then call tail_df % new ( df % get_max_char_len ()) return end if start_row = df % nrows () - num_rows + 1 tail_df = df_slice_rows ( df , start_row , df % nrows ()) end function df_tail","tags":"","url":"proc/df_tail.html"},{"title":"copy_filtered_column – DataFort","text":"private  subroutine copy_filtered_column(source_df, target_df, col_index, selected_rows) Internal: Copy filtered column from source to target Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: source_df type( data_frame ), intent(inout) :: target_df integer, intent(in) :: col_index integer, intent(in), dimension(:) :: selected_rows Source Code subroutine copy_filtered_column ( source_df , target_df , col_index , selected_rows ) type ( data_frame ), intent ( in ) :: source_df type ( data_frame ), intent ( inout ) :: target_df integer , intent ( in ) :: col_index integer , dimension (:), intent ( in ) :: selected_rows integer :: i , n_selected real ( rk ), allocatable :: real_filtered (:) integer ( ik ), allocatable :: int_filtered (:) logical , allocatable :: logical_filtered (:) character ( len = :), allocatable :: char_filtered (:) complex ( rk ), allocatable :: complex_filtered (:) type ( column ) :: col n_selected = size ( selected_rows ) col = source_df % get_data_col ( col_index ) select case ( col % get_type ()) case ( REAL_NUM ) allocate ( real_filtered ( n_selected )) do i = 1 , n_selected real_filtered ( i ) = col % getr ( selected_rows ( i )) end do if ( source_df % get_with_headers ()) then call df_append_real ( target_df , real_filtered , source_df % header ( col_index )) else call df_append_real ( target_df , real_filtered ) end if deallocate ( real_filtered ) case ( INTEGER_NUM ) allocate ( int_filtered ( n_selected )) do i = 1 , n_selected int_filtered ( i ) = col % geti ( selected_rows ( i )) end do if ( source_df % get_with_headers ()) then call df_append_integer ( target_df , int_filtered , source_df % header ( col_index )) else call df_append_integer ( target_df , int_filtered ) end if deallocate ( int_filtered ) case ( LOGICAL_NUM ) allocate ( logical_filtered ( n_selected )) do i = 1 , n_selected logical_filtered ( i ) = col % getl ( selected_rows ( i )) end do if ( source_df % get_with_headers ()) then call df_append_logical ( target_df , logical_filtered , source_df % header ( col_index )) else call df_append_logical ( target_df , logical_filtered ) end if deallocate ( logical_filtered ) case ( CHARACTER_NUM ) allocate ( character ( len = len ( col % getch ( 1 ))) :: char_filtered ( n_selected )) do i = 1 , n_selected char_filtered ( i ) = col % getch ( selected_rows ( i )) end do if ( source_df % get_with_headers ()) then call df_append_character ( target_df , char_filtered , source_df % header ( col_index )) else call df_append_character ( target_df , char_filtered ) end if deallocate ( char_filtered ) case ( COMPLEX_NUM ) allocate ( complex_filtered ( n_selected )) do i = 1 , n_selected complex_filtered ( i ) = col % getc ( selected_rows ( i )) end do if ( source_df % get_with_headers ()) then call df_append_complex ( target_df , complex_filtered , source_df % header ( col_index )) else call df_append_complex ( target_df , complex_filtered ) end if deallocate ( complex_filtered ) end select end subroutine copy_filtered_column","tags":"","url":"proc/copy_filtered_column.html"},{"title":"df_clear – DataFort","text":"public  subroutine df_clear(df) Clear the dataframe (destroy and re-initialize) @param[in,out] df The data frame to clear Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df Source Code subroutine df_clear ( df ) type ( data_frame ), intent ( inout ) :: df integer :: saved_char_len saved_char_len = df % get_max_char_len () call df % destroy () call df % new ( saved_char_len ) end subroutine df_clear","tags":"","url":"proc/df_clear.html"},{"title":"df_info – DataFort","text":"public  subroutine df_info(df, unit) Print information about the dataframe @param[in] df The data frame\n@param[in] unit Optional output unit (default: stdout) Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in), optional :: unit Source Code subroutine df_info ( df , unit ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ), optional :: unit integer :: out_unit , i , dtype character ( len = 20 ) :: type_name integer , dimension ( 2 ) :: dims if ( present ( unit )) then out_unit = unit else out_unit = 6 ! stdout end if dims = df_shape ( df ) write ( out_unit , '(a)' ) repeat ( '=' , 60 ) write ( out_unit , '(a)' ) 'DataFrame Information' write ( out_unit , '(a)' ) repeat ( '=' , 60 ) write ( out_unit , '(a,i0,a,i0,a)' ) 'Shape: (' , dims ( 1 ), ' rows, ' , dims ( 2 ), ' columns)' write ( out_unit , '(a,l1)' ) 'Has headers: ' , df % get_with_headers () if ( df % ncols () > 0 ) then write ( out_unit , '(a)' ) '' write ( out_unit , '(a)' ) 'Columns:' write ( out_unit , '(a)' ) repeat ( '-' , 60 ) do i = 1 , df % ncols () dtype = df % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) type_name = 'real' case ( INTEGER_NUM ) type_name = 'integer' case ( LOGICAL_NUM ) type_name = 'logical' case ( CHARACTER_NUM ) type_name = 'character' case ( COMPLEX_NUM ) type_name = 'complex' case default type_name = 'unknown' end select if ( df % get_with_headers ()) then write ( out_unit , '(i4,2a,t30,3a)' ) i , '. ' , trim ( df % header ( i )), & '(' , trim ( type_name ), ')' else write ( out_unit , '(i4,2a,a)' ) i , '. Column (' , trim ( type_name ), ')' end if end do end if write ( out_unit , '(a)' ) repeat ( '=' , 60 ) end subroutine df_info","tags":"","url":"proc/df_info.html"},{"title":"df_shuffle – DataFort","text":"public  subroutine df_shuffle(df, seed) Shuffle all rows randomly in place @param[in,out] df The data frame to shuffle\n@param[in] seed Optional random seed Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in), optional :: seed Source Code subroutine df_shuffle ( df , seed ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ), optional :: seed integer , dimension (:), allocatable :: indices , seed_array integer :: i , j , temp , seed_size real :: rand_val if ( df % nrows () < 2 ) return ! Initialize random seed if provided if ( present ( seed )) then call random_seed ( size = seed_size ) allocate ( seed_array ( seed_size )) seed_array = seed call random_seed ( put = seed_array ) deallocate ( seed_array ) end if ! Create array of indices allocate ( indices ( df % nrows ())) do i = 1 , df % nrows () indices ( i ) = i end do ! Fisher-Yates shuffle do i = df % nrows (), 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = indices ( i ) indices ( i ) = indices ( j ) indices ( j ) = temp end do ! Reorder all columns according to shuffled indices call reorder_all_columns ( df , indices ) deallocate ( indices ) end subroutine df_shuffle","tags":"","url":"proc/df_shuffle.html"},{"title":"reorder_all_columns – DataFort","text":"private  subroutine reorder_all_columns(df, indices) Internal: Reorder all columns according to index array Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in), dimension(:) :: indices Source Code subroutine reorder_all_columns ( df , indices ) type ( data_frame ), intent ( inout ) :: df integer , dimension (:), intent ( in ) :: indices integer :: i , j real ( rk ), allocatable :: real_temp (:) integer ( ik ), allocatable :: int_temp (:) logical , allocatable :: logical_temp (:) character ( len = :), allocatable :: char_temp (:) complex ( rk ), allocatable :: complex_temp (:) type ( column ) :: col do i = 1 , df % ncols () col = df % get_data_col ( i ) select case ( col % get_type ()) case ( REAL_NUM ) allocate ( real_temp ( df % nrows ())) do j = 1 , df % nrows () real_temp ( j ) = col % getr ( indices ( j )) end do call col % destroy () call col % new ( real_temp ) call df % set_data_col ( i , col ) deallocate ( real_temp ) case ( INTEGER_NUM ) allocate ( int_temp ( df % nrows ())) do j = 1 , df % nrows () int_temp ( j ) = col % geti ( indices ( j )) end do call col % destroy () call col % new ( int_temp ) call df % set_data_col ( i , col ) deallocate ( int_temp ) case ( LOGICAL_NUM ) allocate ( logical_temp ( df % nrows ())) do j = 1 , df % nrows () logical_temp ( j ) = col % getl ( indices ( j )) end do call col % destroy () call col % new ( logical_temp ) call df % set_data_col ( i , col ) deallocate ( logical_temp ) case ( CHARACTER_NUM ) allocate ( character ( len = len ( col % getch ( 1 ))) :: char_temp ( df % nrows ())) do j = 1 , df % nrows () char_temp ( j ) = col % getch ( indices ( j )) end do call col % destroy () call col % new ( char_temp ) call df % set_data_col ( i , col ) deallocate ( char_temp ) case ( COMPLEX_NUM ) allocate ( complex_temp ( df % nrows ())) do j = 1 , df % nrows () complex_temp ( j ) = col % getc ( indices ( j )) end do call col % destroy () call col % new ( complex_temp ) call df % set_data_col ( i , col ) deallocate ( complex_temp ) end select end do end subroutine reorder_all_columns","tags":"","url":"proc/reorder_all_columns.html"},{"title":"df_dropna – DataFort","text":"public  function df_dropna(df) result(clean_df) Remove rows containing NaN values Returns a new data frame with all rows containing NaN in any column removed.\nChecks real and integer columns for NaN values. @param[in] df The data frame instance\n@return New data frame with NaN-containing rows removed Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value type( data_frame ) Source Code function df_dropna ( df ) result ( clean_df ) type ( data_frame ), intent ( in ) :: df type ( data_frame ) :: clean_df logical , dimension (:), allocatable :: keep_mask integer :: i , j , dtype , num_clean_rows integer , dimension (:), allocatable :: clean_indices real ( rk ), dimension (:), allocatable :: real_col , real_clean_col integer ( ik ), dimension (:), allocatable :: int_col , int_clean_col logical , dimension (:), allocatable :: log_col , log_clean_col character ( len = :), allocatable :: char_col (:), char_clean_col (:) complex ( rk ), dimension (:), allocatable :: cmplx_col , cmplx_clean_col character ( len = 100 ) :: header_name allocate ( keep_mask ( df % nrows ())) keep_mask = . true . ! Check all columns for NaN do i = 1 , df % ncols () dtype = df % dtype ( i ) if ( dtype == REAL_NUM ) then real_col = df_get_col_real ( df , i ) do j = 1 , size ( real_col ) if ( is_nan_real ( real_col ( j ))) then keep_mask ( j ) = . false . end if end do deallocate ( real_col ) else if ( dtype == INTEGER_NUM ) then int_col = df_get_col_integer ( df , i ) do j = 1 , size ( int_col ) if ( is_nan_integer ( int_col ( j ))) then keep_mask ( j ) = . false . end if end do deallocate ( int_col ) end if end do ! Count rows to keep num_clean_rows = count ( keep_mask ) if ( num_clean_rows == 0 ) then call clean_df % new ( df % get_max_char_len ()) return end if ! Build index array of rows to keep allocate ( clean_indices ( num_clean_rows )) j = 0 do i = 1 , df % nrows () if ( keep_mask ( i )) then j = j + 1 clean_indices ( j ) = i end if end do ! Create new dataframe with clean rows call clean_df % new ( df % get_max_char_len ()) do i = 1 , df % ncols () dtype = df % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) real_col = df_get_col_real ( df , i ) allocate ( real_clean_col ( num_clean_rows )) do j = 1 , num_clean_rows real_clean_col ( j ) = real_col ( clean_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_real ( clean_df , real_clean_col , trim ( header_name )) else call df_append_real ( clean_df , real_clean_col ) end if deallocate ( real_col ) deallocate ( real_clean_col ) case ( INTEGER_NUM ) int_col = df_get_col_integer ( df , i ) allocate ( int_clean_col ( num_clean_rows )) do j = 1 , num_clean_rows int_clean_col ( j ) = int_col ( clean_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_integer ( clean_df , int_clean_col , trim ( header_name )) else call df_append_integer ( clean_df , int_clean_col ) end if deallocate ( int_col ) deallocate ( int_clean_col ) case ( LOGICAL_NUM ) log_col = df_get_col_logical ( df , i ) allocate ( log_clean_col ( num_clean_rows )) do j = 1 , num_clean_rows log_clean_col ( j ) = log_col ( clean_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_logical ( clean_df , log_clean_col , trim ( header_name )) else call df_append_logical ( clean_df , log_clean_col ) end if deallocate ( log_col ) deallocate ( log_clean_col ) case ( CHARACTER_NUM ) char_col = df_get_col_character ( df , i ) allocate ( character ( len = len ( char_col )) :: char_clean_col ( num_clean_rows )) do j = 1 , num_clean_rows char_clean_col ( j ) = char_col ( clean_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_character ( clean_df , char_clean_col , trim ( header_name )) else call df_append_character ( clean_df , char_clean_col ) end if deallocate ( char_col ) deallocate ( char_clean_col ) case ( COMPLEX_NUM ) cmplx_col = df_get_col_complex ( df , i ) allocate ( cmplx_clean_col ( num_clean_rows )) do j = 1 , num_clean_rows cmplx_clean_col ( j ) = cmplx_col ( clean_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_complex ( clean_df , cmplx_clean_col , trim ( header_name )) else call df_append_complex ( clean_df , cmplx_clean_col ) end if deallocate ( cmplx_col ) deallocate ( cmplx_clean_col ) end select end do deallocate ( keep_mask ) deallocate ( clean_indices ) end function df_dropna","tags":"","url":"proc/df_dropna.html"},{"title":"df_isna_integer – DataFort","text":"public  function df_isna_integer(df, col_index) result(mask) Check for NaN values in an integer column Returns a logical array indicating which values are NaN (sentinel value) @param[in] df The data frame instance\n@param[in] col_index Column index to check\n@return Logical array where .true. indicates NaN Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value logical, dimension(:), allocatable Source Code function df_isna_integer ( df , col_index ) result ( mask ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index logical , dimension (:), allocatable :: mask integer ( ik ), dimension (:), allocatable :: col integer :: i if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" col = df_get_col_integer ( df , col_index ) allocate ( mask ( size ( col ))) do i = 1 , size ( col ) mask ( i ) = is_nan_integer ( col ( i )) end do end function df_isna_integer","tags":"","url":"proc/df_isna_integer.html"},{"title":"df_isna_real – DataFort","text":"public  function df_isna_real(df, col_index) result(mask) Check for NaN values in a real column Returns a logical array indicating which values are NaN @param[in] df The data frame instance\n@param[in] col_index Column index to check\n@return Logical array where .true. indicates NaN Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value logical, dimension(:), allocatable Source Code function df_isna_real ( df , col_index ) result ( mask ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index logical , dimension (:), allocatable :: mask real ( rk ), dimension (:), allocatable :: col integer :: i if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" col = df_get_col_real ( df , col_index ) allocate ( mask ( size ( col ))) do i = 1 , size ( col ) mask ( i ) = is_nan_real ( col ( i )) end do end function df_isna_real","tags":"","url":"proc/df_isna_real.html"},{"title":"df_fillna_integer – DataFort","text":"public  subroutine df_fillna_integer(df, col_index, fill_value) Replace NaN values in an integer column with a fill value Replaces all NaN sentinel values in the specified column with the given value @param[in,out] df The data frame instance\n@param[in] col_index Column index to fill\n@param[in] fill_value Value to replace NaN with Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index integer(kind=ik), intent(in) :: fill_value Source Code subroutine df_fillna_integer ( df , col_index , fill_value ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index integer ( ik ), intent ( in ) :: fill_value integer ( ik ), dimension (:), allocatable :: col integer :: i if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" col = df_get_col_integer ( df , col_index ) do i = 1 , size ( col ) if ( is_nan_integer ( col ( i ))) then col ( i ) = fill_value end if end do call df_set_col_integer ( df , col_index , col ) end subroutine df_fillna_integer","tags":"","url":"proc/df_fillna_integer.html"},{"title":"df_fillna_real – DataFort","text":"public  subroutine df_fillna_real(df, col_index, fill_value) Replace NaN values in a real column with a fill value Replaces all NaN values in the specified column with the given value @param[in,out] df The data frame instance\n@param[in] col_index Column index to fill\n@param[in] fill_value Value to replace NaN with Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: fill_value Source Code subroutine df_fillna_real ( df , col_index , fill_value ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: fill_value real ( rk ), dimension (:), allocatable :: col integer :: i if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" col = df_get_col_real ( df , col_index ) do i = 1 , size ( col ) if ( is_nan_real ( col ( i ))) then col ( i ) = fill_value end if end do call df_set_col_real ( df , col_index , col ) end subroutine df_fillna_real","tags":"","url":"proc/df_fillna_real.html"},{"title":"df_copy – DataFort","text":"public  function df_copy(df) result(new_df) Create a deep copy of a data frame Creates a new data frame with all columns and data copied from the source @param[in] df The source data frame\n@return new_df New data frame that is a copy of the source Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value type( data_frame ) Source Code function df_copy ( df ) result ( new_df ) type ( data_frame ), intent ( in ) :: df type ( data_frame ) :: new_df integer :: i type ( column ) :: col call new_df % new ( df % get_max_char_len ()) do i = 1 , df % ncols () col = df % get_data_col ( i ) select case ( col % get_type ()) case ( REAL_NUM ) if ( df % get_with_headers ()) then call df_append_real ( new_df , col % getr (), df % header ( i )) else call df_append_real ( new_df , col % getr ()) end if case ( INTEGER_NUM ) if ( df % get_with_headers ()) then call df_append_integer ( new_df , col % geti (), df % header ( i )) else call df_append_integer ( new_df , col % geti ()) end if case ( LOGICAL_NUM ) if ( df % get_with_headers ()) then call df_append_logical ( new_df , col % getl (), df % header ( i )) else call df_append_logical ( new_df , col % getl ()) end if case ( CHARACTER_NUM ) if ( df % get_with_headers ()) then call df_append_character ( new_df , col % getch (), df % header ( i )) else call df_append_character ( new_df , col % getch ()) end if case ( COMPLEX_NUM ) if ( df % get_with_headers ()) then call df_append_complex ( new_df , col % getc (), df % header ( i )) else call df_append_complex ( new_df , col % getc ()) end if end select end do end function df_copy","tags":"","url":"proc/df_copy.html"},{"title":"df_filter_rows_integer_range – DataFort","text":"public  function df_filter_rows_integer_range(df, col_index, min_val, max_val) result(filtered_df) Filter rows by integer value range Creates a new data frame containing only rows where the specified\ninteger column value is within [min_val, max_val] @param[in] df The source data frame\n@param[in] col_index Index of the integer column to filter by\n@param[in] min_val Minimum value (inclusive)\n@param[in] max_val Maximum value (inclusive)\n@return filtered_df New data frame with filtered rows Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index integer(kind=ik), intent(in) :: min_val integer(kind=ik), intent(in) :: max_val Return Value type( data_frame ) Source Code function df_filter_rows_integer_range ( df , col_index , min_val , max_val ) result ( filtered_df ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index integer ( ik ), intent ( in ) :: min_val , max_val type ( data_frame ) :: filtered_df integer , dimension (:), allocatable :: selected_rows integer :: i , count , idx integer ( ik ) :: val type ( column ) :: col col = df % get_data_col ( col_index ) if ( col % get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" ! Count matching rows count = 0 do i = 1 , df % nrows () val = col % geti ( i ) if ( val >= min_val . and . val <= max_val ) count = count + 1 end do ! Collect matching row indices allocate ( selected_rows ( count )) idx = 0 do i = 1 , df % nrows () val = col % geti ( i ) if ( val >= min_val . and . val <= max_val ) then idx = idx + 1 selected_rows ( idx ) = i end if end do ! Create filtered dataframe call filtered_df % new ( df % get_max_char_len ()) do i = 1 , df % ncols () call copy_filtered_column ( df , filtered_df , i , selected_rows ) end do deallocate ( selected_rows ) end function df_filter_rows_integer_range","tags":"","url":"proc/df_filter_rows_integer_range.html"},{"title":"df_filter_rows_logical – DataFort","text":"public  function df_filter_rows_logical(df, logical_col_index) result(new_df) Filter rows based on a logical column Creates a new data frame containing only rows where the specified\nlogical column is .true. @param[in] df The source data frame\n@param[in] logical_col_index Index of the logical column to use for filtering\n@return new_df New data frame with filtered rows Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: logical_col_index Return Value type( data_frame ) Source Code function df_filter_rows_logical ( df , logical_col_index ) result ( new_df ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: logical_col_index type ( data_frame ) :: new_df logical , dimension (:), allocatable :: mask integer , allocatable :: selected_rows (:) integer :: i , count_true , idx type ( column ) :: col col = df % get_data_col ( logical_col_index ) if ( col % get_type () /= LOGICAL_NUM ) then error stop \"Column must be logical type for df_filter_rows_logical\" end if mask = col % getl () count_true = count ( mask ) if ( count_true == 0 ) then call new_df % new ( df % get_max_char_len ()) return end if ! Get indices of true values allocate ( selected_rows ( count_true )) idx = 1 do i = 1 , size ( mask ) if ( mask ( i )) then selected_rows ( idx ) = i idx = idx + 1 end if end do call new_df % new ( df % get_max_char_len ()) ! Copy selected rows for each column do i = 1 , df % ncols () call copy_filtered_column ( df , new_df , i , selected_rows ) end do deallocate ( selected_rows ) end function df_filter_rows_logical","tags":"","url":"proc/df_filter_rows_logical.html"},{"title":"df_filter_rows_real_range – DataFort","text":"public  function df_filter_rows_real_range(df, col_index, min_val, max_val) result(filtered_df) Filter rows by real value range Creates a new data frame containing only rows where the specified\nreal column value is within [min_val, max_val] @param[in] df The source data frame\n@param[in] col_index Index of the real column to filter by\n@param[in] min_val Minimum value (inclusive)\n@param[in] max_val Maximum value (inclusive)\n@return filtered_df New data frame with filtered rows Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: min_val real(kind=rk), intent(in) :: max_val Return Value type( data_frame ) Source Code function df_filter_rows_real_range ( df , col_index , min_val , max_val ) result ( filtered_df ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ), intent ( in ) :: min_val , max_val type ( data_frame ) :: filtered_df integer , dimension (:), allocatable :: selected_rows integer :: i , count , idx real ( rk ) :: val type ( column ) :: col col = df % get_data_col ( col_index ) if ( col % get_type () /= REAL_NUM ) error stop \"column is not real type\" ! Count matching rows count = 0 do i = 1 , df % nrows () val = col % getr ( i ) if ( val >= min_val . and . val <= max_val ) count = count + 1 end do ! Collect matching row indices allocate ( selected_rows ( count )) idx = 0 do i = 1 , df % nrows () val = col % getr ( i ) if ( val >= min_val . and . val <= max_val ) then idx = idx + 1 selected_rows ( idx ) = i end if end do ! Create filtered dataframe call filtered_df % new ( df % get_max_char_len ()) do i = 1 , df % ncols () call copy_filtered_column ( df , filtered_df , i , selected_rows ) end do deallocate ( selected_rows ) end function df_filter_rows_real_range","tags":"","url":"proc/df_filter_rows_real_range.html"},{"title":"df_filter_rows_string_pattern – DataFort","text":"public  function df_filter_rows_string_pattern(df, col_index, pattern) result(filtered_df) Filter rows by string pattern Creates a new data frame containing only rows where the specified\ncharacter column contains the given pattern @param[in] df The source data frame\n@param[in] col_index Index of the character column to filter by\n@param[in] pattern String pattern to search for\n@return filtered_df New data frame with filtered rows Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index character(len=*), intent(in) :: pattern Return Value type( data_frame ) Source Code function df_filter_rows_string_pattern ( df , col_index , pattern ) result ( filtered_df ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index character ( len =* ), intent ( in ) :: pattern type ( data_frame ) :: filtered_df integer , dimension (:), allocatable :: selected_rows integer :: i , count , idx character ( len = :), allocatable :: val type ( column ) :: col col = df % get_data_col ( col_index ) if ( col % get_type () /= CHARACTER_NUM ) error stop \"column is not character type\" ! Count matching rows count = 0 do i = 1 , df % nrows () val = col % getch ( i ) if ( index ( val , pattern ) > 0 ) count = count + 1 end do ! Collect matching row indices allocate ( selected_rows ( count )) idx = 0 do i = 1 , df % nrows () val = col % getch ( i ) if ( index ( val , pattern ) > 0 ) then idx = idx + 1 selected_rows ( idx ) = i end if end do ! Create filtered dataframe call filtered_df % new ( df % get_max_char_len ()) do i = 1 , df % ncols () call copy_filtered_column ( df , filtered_df , i , selected_rows ) end do deallocate ( selected_rows ) end function df_filter_rows_string_pattern","tags":"","url":"proc/df_filter_rows_string_pattern.html"},{"title":"df_select_columns – DataFort","text":"public  function df_select_columns(df, column_indices) result(new_df) Select specific columns from a data frame Creates a new data frame containing only the specified columns @param[in] df The source data frame\n@param[in] column_indices Array of column indices to select\n@return new_df New data frame with selected columns Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in), dimension(:) :: column_indices Return Value type( data_frame ) Source Code function df_select_columns ( df , column_indices ) result ( new_df ) type ( data_frame ), intent ( in ) :: df integer , dimension (:), intent ( in ) :: column_indices type ( data_frame ) :: new_df integer :: i , col_idx type ( column ) :: col call new_df % new ( df % get_max_char_len ()) do i = 1 , size ( column_indices ) col_idx = column_indices ( i ) if ( col_idx < 1 . or . col_idx > df % ncols ()) then error stop \"Column index out of range in df_select_columns\" end if col = df % get_data_col ( col_idx ) select case ( col % get_type ()) case ( REAL_NUM ) if ( df % get_with_headers ()) then call df_append_real ( new_df , col % getr (), df % header ( col_idx )) else call df_append_real ( new_df , col % getr ()) end if case ( INTEGER_NUM ) if ( df % get_with_headers ()) then call df_append_integer ( new_df , col % geti (), df % header ( col_idx )) else call df_append_integer ( new_df , col % geti ()) end if case ( LOGICAL_NUM ) if ( df % get_with_headers ()) then call df_append_logical ( new_df , col % getl (), df % header ( col_idx )) else call df_append_logical ( new_df , col % getl ()) end if case ( CHARACTER_NUM ) if ( df % get_with_headers ()) then call df_append_character ( new_df , col % getch (), df % header ( col_idx )) else call df_append_character ( new_df , col % getch ()) end if case ( COMPLEX_NUM ) if ( df % get_with_headers ()) then call df_append_complex ( new_df , col % getc (), df % header ( col_idx )) else call df_append_complex ( new_df , col % getc ()) end if end select end do end function df_select_columns","tags":"","url":"proc/df_select_columns.html"},{"title":"df_slice_rows – DataFort","text":"public  function df_slice_rows(df, start_row, end_row) result(new_df) Slice rows to create a new data frame Creates a new data frame containing only rows in the specified range @param[in] df The source data frame\n@param[in] start_row First row to include (1-indexed)\n@param[in] end_row Last row to include (inclusive)\n@return new_df New data frame with sliced rows Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: start_row integer, intent(in) :: end_row Return Value type( data_frame ) Source Code function df_slice_rows ( df , start_row , end_row ) result ( new_df ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: start_row , end_row type ( data_frame ) :: new_df integer :: i , j , new_size real ( rk ), allocatable :: real_slice (:) integer ( ik ), allocatable :: int_slice (:) logical , allocatable :: logical_slice (:) character ( len = :), allocatable :: char_slice (:) complex ( rk ), allocatable :: complex_slice (:) type ( column ) :: col if ( start_row < 1 . or . end_row > df % nrows () . or . start_row > end_row ) then error stop \"Invalid row range in df_slice_rows\" end if new_size = end_row - start_row + 1 call new_df % new ( df % get_max_char_len ()) do i = 1 , df % ncols () col = df % get_data_col ( i ) select case ( col % get_type ()) case ( REAL_NUM ) allocate ( real_slice ( new_size )) do j = 1 , new_size real_slice ( j ) = col % getr ( start_row + j - 1 ) end do if ( df % get_with_headers ()) then call df_append_real ( new_df , real_slice , df % header ( i )) else call df_append_real ( new_df , real_slice ) end if deallocate ( real_slice ) case ( INTEGER_NUM ) allocate ( int_slice ( new_size )) do j = 1 , new_size int_slice ( j ) = col % geti ( start_row + j - 1 ) end do if ( df % get_with_headers ()) then call df_append_integer ( new_df , int_slice , df % header ( i )) else call df_append_integer ( new_df , int_slice ) end if deallocate ( int_slice ) case ( LOGICAL_NUM ) allocate ( logical_slice ( new_size )) do j = 1 , new_size logical_slice ( j ) = col % getl ( start_row + j - 1 ) end do if ( df % get_with_headers ()) then call df_append_logical ( new_df , logical_slice , df % header ( i )) else call df_append_logical ( new_df , logical_slice ) end if deallocate ( logical_slice ) case ( CHARACTER_NUM ) allocate ( character ( len = len ( col % getch ( 1 ))) :: char_slice ( new_size )) do j = 1 , new_size char_slice ( j ) = col % getch ( start_row + j - 1 ) end do if ( df % get_with_headers ()) then call df_append_character ( new_df , char_slice , df % header ( i )) else call df_append_character ( new_df , char_slice ) end if deallocate ( char_slice ) case ( COMPLEX_NUM ) allocate ( complex_slice ( new_size )) do j = 1 , new_size complex_slice ( j ) = col % getc ( start_row + j - 1 ) end do if ( df % get_with_headers ()) then call df_append_complex ( new_df , complex_slice , df % header ( i )) else call df_append_complex ( new_df , complex_slice ) end if deallocate ( complex_slice ) end select end do end function df_slice_rows","tags":"","url":"proc/df_slice_rows~2.html"},{"title":"df_transpose – DataFort","text":"public  function df_transpose(df) result(transposed_df) Transpose a data frame Creates a transposed data frame where rows become columns and columns become rows.\nNote: All data is converted to character type in the transposed frame. @param[in] df The source data frame\n@return transposed_df New data frame that is the transpose of the source Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value type( data_frame ) Source Code function df_transpose ( df ) result ( transposed_df ) type ( data_frame ), intent ( in ) :: df type ( data_frame ) :: transposed_df integer :: i , j character ( len = :), dimension (:), allocatable :: row_data character ( len = 20 ) :: temp_str type ( column ) :: col call transposed_df % new () ! Add headers as first column if present if ( df % get_with_headers ()) then allocate ( character ( len = df % get_max_char_len ()) :: row_data ( df % ncols ())) do i = 1 , df % ncols () row_data ( i ) = df % header ( i ) end do call df_append_character ( transposed_df , row_data , \"Headers\" ) deallocate ( row_data ) end if ! Add each row as a column do i = 1 , df % nrows () allocate ( character ( len = 50 ) :: row_data ( df % ncols ())) do j = 1 , df % ncols () col = df % get_data_col ( j ) select case ( col % get_type ()) case ( REAL_NUM ) write ( temp_str , '(f0.6)' ) col % getr ( i ) row_data ( j ) = trim ( temp_str ) case ( INTEGER_NUM ) write ( temp_str , '(i0)' ) col % geti ( i ) row_data ( j ) = trim ( temp_str ) case ( LOGICAL_NUM ) if ( col % getl ( i )) then row_data ( j ) = \"T\" else row_data ( j ) = \"F\" end if case ( CHARACTER_NUM ) row_data ( j ) = col % getch ( i ) case ( COMPLEX_NUM ) write ( temp_str , '(\"(\",f0.3,\",\",f0.3,\")\")' ) col % getc ( i ) row_data ( j ) = trim ( temp_str ) end select end do write ( temp_str , '(\"Row_\",i0)' ) i call df_append_character ( transposed_df , row_data , trim ( temp_str )) deallocate ( row_data ) end do end function df_transpose","tags":"","url":"proc/df_transpose.html"},{"title":"copy_filtered_column – DataFort","text":"private  subroutine copy_filtered_column(source_df, target_df, col_index, selected_rows) Helper subroutine to copy filtered rows for a single column Internal helper used by filtering functions to copy selected rows\nfrom source data frame to target data frame for a specific column @param[in] source_df Source data frame to copy from\n@param[in,out] target_df Target data frame to copy to\n@param[in] col_index Index of the column to copy\n@param[in] selected_rows Array of row indices to copy Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: source_df type( data_frame ), intent(inout) :: target_df integer, intent(in) :: col_index integer, intent(in), dimension(:) :: selected_rows Source Code subroutine copy_filtered_column ( source_df , target_df , col_index , selected_rows ) type ( data_frame ), intent ( in ) :: source_df type ( data_frame ), intent ( inout ) :: target_df integer , intent ( in ) :: col_index integer , dimension (:), intent ( in ) :: selected_rows integer :: i , n_selected real ( rk ), allocatable :: real_filtered (:) integer ( ik ), allocatable :: int_filtered (:) logical , allocatable :: logical_filtered (:) character ( len = :), allocatable :: char_filtered (:) complex ( rk ), allocatable :: complex_filtered (:) type ( column ) :: col n_selected = size ( selected_rows ) col = source_df % get_data_col ( col_index ) select case ( col % get_type ()) case ( REAL_NUM ) allocate ( real_filtered ( n_selected )) do i = 1 , n_selected real_filtered ( i ) = col % getr ( selected_rows ( i )) end do if ( source_df % get_with_headers ()) then call df_append_real ( target_df , real_filtered , source_df % header ( col_index )) else call df_append_real ( target_df , real_filtered ) end if deallocate ( real_filtered ) case ( INTEGER_NUM ) allocate ( int_filtered ( n_selected )) do i = 1 , n_selected int_filtered ( i ) = col % geti ( selected_rows ( i )) end do if ( source_df % get_with_headers ()) then call df_append_integer ( target_df , int_filtered , source_df % header ( col_index )) else call df_append_integer ( target_df , int_filtered ) end if deallocate ( int_filtered ) case ( LOGICAL_NUM ) allocate ( logical_filtered ( n_selected )) do i = 1 , n_selected logical_filtered ( i ) = col % getl ( selected_rows ( i )) end do if ( source_df % get_with_headers ()) then call df_append_logical ( target_df , logical_filtered , source_df % header ( col_index )) else call df_append_logical ( target_df , logical_filtered ) end if deallocate ( logical_filtered ) case ( CHARACTER_NUM ) allocate ( character ( len = len ( col % getch ( 1 ))) :: char_filtered ( n_selected )) do i = 1 , n_selected char_filtered ( i ) = col % getch ( selected_rows ( i )) end do if ( source_df % get_with_headers ()) then call df_append_character ( target_df , char_filtered , source_df % header ( col_index )) else call df_append_character ( target_df , char_filtered ) end if deallocate ( char_filtered ) case ( COMPLEX_NUM ) allocate ( complex_filtered ( n_selected )) do i = 1 , n_selected complex_filtered ( i ) = col % getc ( selected_rows ( i )) end do if ( source_df % get_with_headers ()) then call df_append_complex ( target_df , complex_filtered , source_df % header ( col_index )) else call df_append_complex ( target_df , complex_filtered ) end if deallocate ( complex_filtered ) end select end subroutine copy_filtered_column","tags":"","url":"proc/copy_filtered_column~2.html"},{"title":"df_drop_column – DataFort","text":"public  subroutine df_drop_column(df, col_index) Drop a column from the data frame Removes the specified column and all its data from the data frame @param[in,out] df The data frame to modify\n@param[in] col_index Index of the column to drop Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index Source Code subroutine df_drop_column ( df , col_index ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index integer :: i type ( data_frame ) :: temp_df if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" ! Create a new data frame with all columns except the one to drop call temp_df % new ( df % get_max_char_len ()) do i = 1 , df % ncols () if ( i /= col_index ) then select case ( df % dtype ( i )) case ( REAL_NUM ) if ( df % get_with_headers ()) then call df_append_real ( temp_df , df_get_col_real ( df , i ), df % header ( i )) else call df_append_real ( temp_df , df_get_col_real ( df , i )) end if case ( INTEGER_NUM ) if ( df % get_with_headers ()) then call df_append_integer ( temp_df , df_get_col_integer ( df , i ), df % header ( i )) else call df_append_integer ( temp_df , df_get_col_integer ( df , i )) end if case ( LOGICAL_NUM ) if ( df % get_with_headers ()) then call df_append_logical ( temp_df , df_get_col_logical ( df , i ), df % header ( i )) else call df_append_logical ( temp_df , df_get_col_logical ( df , i )) end if case ( CHARACTER_NUM ) if ( df % get_with_headers ()) then call df_append_character ( temp_df , df_get_col_character ( df , i ), df % header ( i )) else call df_append_character ( temp_df , df_get_col_character ( df , i )) end if case ( COMPLEX_NUM ) if ( df % get_with_headers ()) then call df_append_complex ( temp_df , df_get_col_complex ( df , i ), df % header ( i )) else call df_append_complex ( temp_df , df_get_col_complex ( df , i )) end if end select end if end do ! Destroy original and move temp_df data to df call df % destroy () df = temp_df end subroutine df_drop_column","tags":"","url":"proc/df_drop_column.html"},{"title":"df_rename_column – DataFort","text":"public  subroutine df_rename_column(df, col_index, new_name) Rename a column in the data frame Changes the header name of a specified column @param[in,out] df The data frame to modify\n@param[in] col_index Index of the column to rename\n@param[in] new_name New name for the column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index character(len=*), intent(in) :: new_name Source Code subroutine df_rename_column ( df , col_index , new_name ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index character ( len =* ), intent ( in ) :: new_name if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" if (. not . df % get_with_headers ()) error stop \"data frame has no headers to rename\" call df % set_header_at_index ( col_index , new_name ) end subroutine df_rename_column","tags":"","url":"proc/df_rename_column.html"},{"title":"df_reorder_columns – DataFort","text":"public  subroutine df_reorder_columns(df, new_order) Reorder columns in the data frame Rearranges columns according to the specified order @param[in,out] df The data frame to modify\n@param[in] new_order Array specifying the new column order (permutation of 1:ncols) Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in), dimension(:) :: new_order Source Code subroutine df_reorder_columns ( df , new_order ) type ( data_frame ), intent ( inout ) :: df integer , dimension (:), intent ( in ) :: new_order integer :: i type ( data_frame ) :: temp_df if ( size ( new_order ) /= df % ncols ()) error stop \"new_order size must equal number of columns\" ! Validate indices do i = 1 , size ( new_order ) if ( new_order ( i ) < 1 . or . new_order ( i ) > df % ncols ()) error stop \"invalid column index in new_order\" end do ! Create new data frame with reordered columns call temp_df % new ( df % get_max_char_len ()) do i = 1 , df % ncols () select case ( df % dtype ( new_order ( i ))) case ( REAL_NUM ) if ( df % get_with_headers ()) then call df_append_real ( temp_df , df_get_col_real ( df , new_order ( i )), df % header ( new_order ( i ))) else call df_append_real ( temp_df , df_get_col_real ( df , new_order ( i ))) end if case ( INTEGER_NUM ) if ( df % get_with_headers ()) then call df_append_integer ( temp_df , df_get_col_integer ( df , new_order ( i )), df % header ( new_order ( i ))) else call df_append_integer ( temp_df , df_get_col_integer ( df , new_order ( i ))) end if case ( LOGICAL_NUM ) if ( df % get_with_headers ()) then call df_append_logical ( temp_df , df_get_col_logical ( df , new_order ( i )), df % header ( new_order ( i ))) else call df_append_logical ( temp_df , df_get_col_logical ( df , new_order ( i ))) end if case ( CHARACTER_NUM ) if ( df % get_with_headers ()) then call df_append_character ( temp_df , df_get_col_character ( df , new_order ( i )), df % header ( new_order ( i ))) else call df_append_character ( temp_df , df_get_col_character ( df , new_order ( i ))) end if case ( COMPLEX_NUM ) if ( df % get_with_headers ()) then call df_append_complex ( temp_df , df_get_col_complex ( df , new_order ( i )), df % header ( new_order ( i ))) else call df_append_complex ( temp_df , df_get_col_complex ( df , new_order ( i ))) end if end select end do ! Destroy original and move temp_df data to df call df % destroy () df = temp_df end subroutine df_reorder_columns","tags":"","url":"proc/df_reorder_columns.html"},{"title":"df_get_col_character – DataFort","text":"public  function df_get_col_character(df, index) result(col) Get character column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: index Return Value character(len=:), dimension(:), allocatable Source Code function df_get_col_character ( df , index ) result ( col ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: index character ( len = :), dimension (:), allocatable :: col type ( column ) :: data_col if ( index < 1 . or . index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( index ) if ( data_col % get_type () /= CHARACTER_NUM ) error stop \"column is not character type\" col = data_col % getch () end function df_get_col_character","tags":"","url":"proc/df_get_col_character.html"},{"title":"df_get_col_complex – DataFort","text":"public  function df_get_col_complex(df, index) result(col) Get complex column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: index Return Value complex(kind=rk), dimension(:), allocatable Source Code function df_get_col_complex ( df , index ) result ( col ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: index complex ( rk ), dimension (:), allocatable :: col type ( column ) :: data_col if ( index < 1 . or . index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( index ) if ( data_col % get_type () /= COMPLEX_NUM ) error stop \"column is not complex type\" col = data_col % getc () end function df_get_col_complex","tags":"","url":"proc/df_get_col_complex.html"},{"title":"df_get_col_integer – DataFort","text":"public  function df_get_col_integer(df, index) result(col) Get integer column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: index Return Value integer(kind=ik), dimension(:), allocatable Source Code function df_get_col_integer ( df , index ) result ( col ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: index integer ( ik ), dimension (:), allocatable :: col type ( column ) :: data_col if ( index < 1 . or . index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( index ) if ( data_col % get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" col = data_col % geti () end function df_get_col_integer","tags":"","url":"proc/df_get_col_integer.html"},{"title":"df_get_col_logical – DataFort","text":"public  function df_get_col_logical(df, index) result(col) Get logical column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: index Return Value logical, dimension(:), allocatable Source Code function df_get_col_logical ( df , index ) result ( col ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: index logical , dimension (:), allocatable :: col type ( column ) :: data_col if ( index < 1 . or . index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( index ) if ( data_col % get_type () /= LOGICAL_NUM ) error stop \"column is not logical type\" col = data_col % getl () end function df_get_col_logical","tags":"","url":"proc/df_get_col_logical.html"},{"title":"df_get_col_real – DataFort","text":"public  function df_get_col_real(df, index) result(col) Get real column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: index Return Value real(kind=rk), dimension(:), allocatable Source Code function df_get_col_real ( df , index ) result ( col ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: index real ( rk ), dimension (:), allocatable :: col type ( column ) :: data_col if ( index < 1 . or . index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( index ) if ( data_col % get_type () /= REAL_NUM ) error stop \"column is not real type\" col = data_col % getr () end function df_get_col_real","tags":"","url":"proc/df_get_col_real.html"},{"title":"df_get_val_character – DataFort","text":"public  function df_get_val_character(df, row_index, col_index) result(val) Get single character value from data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index Return Value character(len=:), allocatable Source Code function df_get_val_character ( df , row_index , col_index ) result ( val ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: row_index , col_index character ( len = :), allocatable :: val type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= CHARACTER_NUM ) error stop \"column is not character type\" val = data_col % getch ( row_index ) end function df_get_val_character","tags":"","url":"proc/df_get_val_character.html"},{"title":"df_get_val_complex – DataFort","text":"public  function df_get_val_complex(df, row_index, col_index) result(val) Get single complex value from data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index Return Value complex(kind=rk) Source Code function df_get_val_complex ( df , row_index , col_index ) result ( val ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: row_index , col_index complex ( rk ) :: val type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= COMPLEX_NUM ) error stop \"column is not complex type\" val = data_col % getc ( row_index ) end function df_get_val_complex","tags":"","url":"proc/df_get_val_complex.html"},{"title":"df_get_val_integer – DataFort","text":"public  function df_get_val_integer(df, row_index, col_index) result(val) Get single integer value from data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index Return Value integer(kind=ik) Source Code function df_get_val_integer ( df , row_index , col_index ) result ( val ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: row_index , col_index integer ( ik ) :: val type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" val = data_col % geti ( row_index ) end function df_get_val_integer","tags":"","url":"proc/df_get_val_integer.html"},{"title":"df_get_val_logical – DataFort","text":"public  function df_get_val_logical(df, row_index, col_index) result(val) Get single logical value from data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index Return Value logical Source Code function df_get_val_logical ( df , row_index , col_index ) result ( val ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: row_index , col_index logical :: val type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= LOGICAL_NUM ) error stop \"column is not logical type\" val = data_col % getl ( row_index ) end function df_get_val_logical","tags":"","url":"proc/df_get_val_logical.html"},{"title":"df_get_val_real – DataFort","text":"public  function df_get_val_real(df, row_index, col_index) result(val) Get single real value from data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index Return Value real(kind=rk) Source Code function df_get_val_real ( df , row_index , col_index ) result ( val ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: row_index , col_index real ( rk ) :: val type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= REAL_NUM ) error stop \"column is not real type\" val = data_col % getr ( row_index ) end function df_get_val_real","tags":"","url":"proc/df_get_val_real.html"},{"title":"df_append_character – DataFort","text":"public  subroutine df_append_character(df, col, header) Append a character-valued column to the data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df character(len=*), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header Source Code subroutine df_append_character ( df , col , header ) type ( data_frame ), intent ( inout ) :: df character ( len =* ), dimension (:), intent ( in ) :: col character ( len =* ), intent ( in ), optional :: header type ( column ) :: new_col integer :: new_index call df % validate_column_addition ( header , size ( col )) call df % resize_storage () call df % increment_num_cols () new_index = df % ncols () call new_col % new ( col ) call df % set_data_col ( new_index , new_col ) if ( present ( header )) then call df % set_header_at_index ( new_index , header ) end if end subroutine df_append_character","tags":"","url":"proc/df_append_character.html"},{"title":"df_append_complex – DataFort","text":"public  subroutine df_append_complex(df, col, header) Append a complex-valued column to the data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df complex(kind=rk), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header Source Code subroutine df_append_complex ( df , col , header ) type ( data_frame ), intent ( inout ) :: df complex ( rk ), dimension (:), intent ( in ) :: col character ( len =* ), intent ( in ), optional :: header type ( column ) :: new_col integer :: new_index call df % validate_column_addition ( header , size ( col )) call df % resize_storage () call df % increment_num_cols () new_index = df % ncols () call new_col % new ( col ) call df % set_data_col ( new_index , new_col ) if ( present ( header )) then call df % set_header_at_index ( new_index , header ) end if end subroutine df_append_complex","tags":"","url":"proc/df_append_complex.html"},{"title":"df_append_integer – DataFort","text":"public  subroutine df_append_integer(df, col, header) Append an integer-valued column to the data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer(kind=ik), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header Source Code subroutine df_append_integer ( df , col , header ) type ( data_frame ), intent ( inout ) :: df integer ( ik ), dimension (:), intent ( in ) :: col character ( len =* ), intent ( in ), optional :: header type ( column ) :: new_col integer :: new_index call df % validate_column_addition ( header , size ( col )) call df % resize_storage () call df % increment_num_cols () new_index = df % ncols () call new_col % new ( col ) call df % set_data_col ( new_index , new_col ) if ( present ( header )) then call df % set_header_at_index ( new_index , header ) end if end subroutine df_append_integer","tags":"","url":"proc/df_append_integer.html"},{"title":"df_append_logical – DataFort","text":"public  subroutine df_append_logical(df, col, header) Append a logical-valued column to the data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df logical, intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header Source Code subroutine df_append_logical ( df , col , header ) type ( data_frame ), intent ( inout ) :: df logical , dimension (:), intent ( in ) :: col character ( len =* ), intent ( in ), optional :: header type ( column ) :: new_col integer :: new_index call df % validate_column_addition ( header , size ( col )) call df % resize_storage () call df % increment_num_cols () new_index = df % ncols () call new_col % new ( col ) call df % set_data_col ( new_index , new_col ) if ( present ( header )) then call df % set_header_at_index ( new_index , header ) end if end subroutine df_append_logical","tags":"","url":"proc/df_append_logical.html"},{"title":"df_append_real – DataFort","text":"public  subroutine df_append_real(df, col, header) Append a real-valued column to the data frame Adds a new column of real numbers to the data frame with optional header @param[in,out] df The data frame instance\n@param[in] col Array of real values to append\n@param[in] header Optional column name (if not provided, no header is set) Warning All columns must have the same number of rows Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df real(kind=rk), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header Source Code subroutine df_append_real ( df , col , header ) type ( data_frame ), intent ( inout ) :: df real ( rk ), dimension (:), intent ( in ) :: col character ( len =* ), intent ( in ), optional :: header type ( column ) :: new_col integer :: new_index call df % validate_column_addition ( header , size ( col )) call df % resize_storage () call df % increment_num_cols () new_index = df % ncols () call new_col % new ( col ) call df % set_data_col ( new_index , new_col ) if ( present ( header )) then call df % set_header_at_index ( new_index , header ) end if end subroutine df_append_real","tags":"","url":"proc/df_append_real.html"},{"title":"df_set_col_character – DataFort","text":"public  subroutine df_set_col_character(df, col_index, col) Set entire character column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index character(len=*), intent(in), dimension(:) :: col Source Code subroutine df_set_col_character ( df , col_index , col ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index character ( len =* ), dimension (:), intent ( in ) :: col type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= CHARACTER_NUM ) error stop \"column is not character type\" if ( size ( col ) /= df % nrows ()) error stop \"column size mismatch\" call data_col % destroy () call data_col % new ( col ) call df % set_data_col ( col_index , data_col ) end subroutine df_set_col_character","tags":"","url":"proc/df_set_col_character.html"},{"title":"df_set_col_complex – DataFort","text":"public  subroutine df_set_col_complex(df, col_index, col) Set entire complex column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index complex(kind=rk), intent(in), dimension(:) :: col Source Code subroutine df_set_col_complex ( df , col_index , col ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index complex ( rk ), dimension (:), intent ( in ) :: col type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= COMPLEX_NUM ) error stop \"column is not complex type\" if ( size ( col ) /= df % nrows ()) error stop \"column size mismatch\" call data_col % destroy () call data_col % new ( col ) call df % set_data_col ( col_index , data_col ) end subroutine df_set_col_complex","tags":"","url":"proc/df_set_col_complex.html"},{"title":"df_set_col_integer – DataFort","text":"public  subroutine df_set_col_integer(df, col_index, col) Set entire integer column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index integer(kind=ik), intent(in), dimension(:) :: col Source Code subroutine df_set_col_integer ( df , col_index , col ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index integer ( ik ), dimension (:), intent ( in ) :: col type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" if ( size ( col ) /= df % nrows ()) error stop \"column size mismatch\" call data_col % destroy () call data_col % new ( col ) call df % set_data_col ( col_index , data_col ) end subroutine df_set_col_integer","tags":"","url":"proc/df_set_col_integer.html"},{"title":"df_set_col_logical – DataFort","text":"public  subroutine df_set_col_logical(df, col_index, col) Set entire logical column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index logical, intent(in), dimension(:) :: col Source Code subroutine df_set_col_logical ( df , col_index , col ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index logical , dimension (:), intent ( in ) :: col type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= LOGICAL_NUM ) error stop \"column is not logical type\" if ( size ( col ) /= df % nrows ()) error stop \"column size mismatch\" call data_col % destroy () call data_col % new ( col ) call df % set_data_col ( col_index , data_col ) end subroutine df_set_col_logical","tags":"","url":"proc/df_set_col_logical.html"},{"title":"df_set_col_real – DataFort","text":"public  subroutine df_set_col_real(df, col_index, col) Set entire real column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index real(kind=rk), intent(in), dimension(:) :: col Source Code subroutine df_set_col_real ( df , col_index , col ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index real ( rk ), dimension (:), intent ( in ) :: col type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= REAL_NUM ) error stop \"column is not real type\" if ( size ( col ) /= df % nrows ()) error stop \"column size mismatch\" call data_col % destroy () call data_col % new ( col ) call df % set_data_col ( col_index , data_col ) end subroutine df_set_col_real","tags":"","url":"proc/df_set_col_real.html"},{"title":"df_set_val_character – DataFort","text":"public  subroutine df_set_val_character(df, row_index, col_index, val) Set single character value in data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index character(len=*), intent(in) :: val Source Code subroutine df_set_val_character ( df , row_index , col_index , val ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: row_index , col_index character ( len =* ), intent ( in ) :: val type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= CHARACTER_NUM ) error stop \"column is not character type\" call data_col % changech ( row_index , val ) call df % set_data_col ( col_index , data_col ) end subroutine df_set_val_character","tags":"","url":"proc/df_set_val_character.html"},{"title":"df_set_val_complex – DataFort","text":"public  subroutine df_set_val_complex(df, row_index, col_index, val) Set single complex value in data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index complex(kind=rk), intent(in) :: val Source Code subroutine df_set_val_complex ( df , row_index , col_index , val ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: row_index , col_index complex ( rk ), intent ( in ) :: val type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= COMPLEX_NUM ) error stop \"column is not complex type\" call data_col % changec ( row_index , val ) call df % set_data_col ( col_index , data_col ) end subroutine df_set_val_complex","tags":"","url":"proc/df_set_val_complex.html"},{"title":"df_set_val_integer – DataFort","text":"public  subroutine df_set_val_integer(df, row_index, col_index, val) Set single integer value in data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index integer(kind=ik), intent(in) :: val Source Code subroutine df_set_val_integer ( df , row_index , col_index , val ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: row_index , col_index integer ( ik ), intent ( in ) :: val type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= INTEGER_NUM ) error stop \"column is not integer type\" call data_col % changei ( row_index , val ) call df % set_data_col ( col_index , data_col ) end subroutine df_set_val_integer","tags":"","url":"proc/df_set_val_integer.html"},{"title":"df_set_val_logical – DataFort","text":"public  subroutine df_set_val_logical(df, row_index, col_index, val) Set single logical value in data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index logical, intent(in) :: val Source Code subroutine df_set_val_logical ( df , row_index , col_index , val ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: row_index , col_index logical , intent ( in ) :: val type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= LOGICAL_NUM ) error stop \"column is not logical type\" call data_col % changel ( row_index , val ) call df % set_data_col ( col_index , data_col ) end subroutine df_set_val_logical","tags":"","url":"proc/df_set_val_logical.html"},{"title":"df_set_val_real – DataFort","text":"public  subroutine df_set_val_real(df, row_index, col_index, val) Set single real value in data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index real(kind=rk), intent(in) :: val Source Code subroutine df_set_val_real ( df , row_index , col_index , val ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: row_index , col_index real ( rk ), intent ( in ) :: val type ( column ) :: data_col if ( col_index < 1 . or . col_index > df % ncols ()) error stop \"column index out of range\" data_col = df % get_data_col ( col_index ) if ( data_col % get_type () /= REAL_NUM ) error stop \"column is not real type\" call data_col % changer ( row_index , val ) call df % set_data_col ( col_index , data_col ) end subroutine df_set_val_real","tags":"","url":"proc/df_set_val_real.html"},{"title":"is_nan_integer – DataFort","text":"public elemental function is_nan_integer(x) result(is_nan) Check if an integer value is NaN (sentinel) @param[in] x Integer value to check\n@return True if x equals the integer NaN sentinel, false otherwise Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: x Return Value logical Source Code elemental function is_nan_integer ( x ) result ( is_nan ) integer ( ik ), intent ( in ) :: x logical :: is_nan is_nan = ( x == NaN_ik ) end function is_nan_integer","tags":"","url":"proc/is_nan_integer.html"},{"title":"is_nan_real – DataFort","text":"public elemental function is_nan_real(x) result(is_nan) Check if a real value is NaN @param[in] x Real value to check\n@return True if x is NaN, false otherwise Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical Source Code elemental function is_nan_real ( x ) result ( is_nan ) real ( rk ), intent ( in ) :: x logical :: is_nan is_nan = ieee_is_nan ( x ) end function is_nan_real","tags":"","url":"proc/is_nan_real.html"},{"title":"init_nan – DataFort","text":"public  subroutine init_nan() Initialize the NaN_rk constant Must be called before using NaN_rk. Automatically called by other functions. Arguments None Source Code subroutine init_nan () if (. not . nan_initialized ) then NaN_rk = ieee_value ( 0.0_rk , ieee_quiet_nan ) nan_initialized = . true . end if end subroutine init_nan","tags":"","url":"proc/init_nan.html"},{"title":"df_is_sorted_integer – DataFort","text":"public  function df_is_sorted_integer(df, col_index, ascending) result(sorted) Check if an integer column is sorted Verifies whether the values in an integer column are in sorted order @param[in] df The data frame instance\n@param[in] col_index Index of column to check\n@param[in] ascending Optional sort direction to check (default: .true.)\n@return .true. if column is sorted, .false. otherwise Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value logical Source Code function df_is_sorted_integer ( df , col_index , ascending ) result ( sorted ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index logical , intent ( in ), optional :: ascending logical :: sorted integer ( ik ), dimension (:), allocatable :: col type ( column ) :: data_col logical :: asc integer :: i asc = . true . if ( present ( ascending )) asc = ascending data_col = df % get_data_col ( col_index ) col = data_col % geti () sorted = . true . if ( asc ) then do i = 1 , size ( col ) - 1 if ( col ( i ) > col ( i + 1 )) then sorted = . false . return end if end do else do i = 1 , size ( col ) - 1 if ( col ( i ) < col ( i + 1 )) then sorted = . false . return end if end do end if end function df_is_sorted_integer","tags":"","url":"proc/df_is_sorted_integer.html"},{"title":"df_is_sorted_real – DataFort","text":"public  function df_is_sorted_real(df, col_index, ascending) result(sorted) Check if a real column is sorted Verifies whether the values in a real column are in sorted order @param[in] df The data frame instance\n@param[in] col_index Index of column to check\n@param[in] ascending Optional sort direction to check (default: .true.)\n@return .true. if column is sorted, .false. otherwise Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value logical Source Code function df_is_sorted_real ( df , col_index , ascending ) result ( sorted ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index logical , intent ( in ), optional :: ascending logical :: sorted real ( rk ), dimension (:), allocatable :: col type ( column ) :: data_col logical :: asc integer :: i asc = . true . if ( present ( ascending )) asc = ascending data_col = df % get_data_col ( col_index ) col = data_col % getr () sorted = . true . if ( asc ) then do i = 1 , size ( col ) - 1 if ( col ( i ) > col ( i + 1 )) then sorted = . false . return end if end do else do i = 1 , size ( col ) - 1 if ( col ( i ) < col ( i + 1 )) then sorted = . false . return end if end do end if end function df_is_sorted_real","tags":"","url":"proc/df_is_sorted_real.html"},{"title":"df_rank_integer – DataFort","text":"public  function df_rank_integer(df, col_index, ascending) result(ranks) Rank values in an integer column Assigns rank positions to each value in the column (1 = smallest/largest) @param[in] df The data frame instance\n@param[in] col_index Index of column to rank\n@param[in] ascending Optional ranking direction (default: .true. for ascending)\n@return Array of integer ranks corresponding to each row Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value integer(kind=ik), dimension(:), allocatable Source Code function df_rank_integer ( df , col_index , ascending ) result ( ranks ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index logical , intent ( in ), optional :: ascending integer ( ik ), dimension (:), allocatable :: ranks integer ( ik ), dimension (:), allocatable :: col , sorted_col type ( column ) :: data_col integer :: i , j , n logical :: asc asc = . true . if ( present ( ascending )) asc = ascending data_col = df % get_data_col ( col_index ) col = data_col % geti () n = size ( col ) allocate ( ranks ( n )) allocate ( sorted_col ( n )) sorted_col = col call quick_sort_integer ( sorted_col , 1 , n ) if (. not . asc ) then sorted_col = sorted_col ( n : 1 : - 1 ) end if do i = 1 , n do j = 1 , n if ( col ( i ) == sorted_col ( j )) then ranks ( i ) = j exit end if end do end do deallocate ( sorted_col ) end function df_rank_integer","tags":"","url":"proc/df_rank_integer.html"},{"title":"df_rank_real – DataFort","text":"public  function df_rank_real(df, col_index, ascending) result(ranks) Rank values in a real column Assigns rank positions to each value in the column (1 = smallest/largest) @param[in] df The data frame instance\n@param[in] col_index Index of column to rank\n@param[in] ascending Optional ranking direction (default: .true. for ascending)\n@return Array of integer ranks corresponding to each row Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value integer(kind=ik), dimension(:), allocatable Source Code function df_rank_real ( df , col_index , ascending ) result ( ranks ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index logical , intent ( in ), optional :: ascending integer ( ik ), dimension (:), allocatable :: ranks real ( rk ), dimension (:), allocatable :: col , sorted_col type ( column ) :: data_col integer :: i , j , n logical :: asc asc = . true . if ( present ( ascending )) asc = ascending data_col = df % get_data_col ( col_index ) col = data_col % getr () n = size ( col ) allocate ( ranks ( n )) allocate ( sorted_col ( n )) sorted_col = col call quick_sort_real ( sorted_col , 1 , n ) if (. not . asc ) then ! Reverse for descending sorted_col = sorted_col ( n : 1 : - 1 ) end if do i = 1 , n do j = 1 , n if ( abs ( col ( i ) - sorted_col ( j )) < 1.0e-10_rk ) then ranks ( i ) = j exit end if end do end do deallocate ( sorted_col ) end function df_rank_real","tags":"","url":"proc/df_rank_real.html"},{"title":"partition_indices_integer – DataFort","text":"private  function partition_indices_integer(values, indices, low, high, ascending) result(pivot_idx) Partition function for integer value quicksort Partitions the indices array around a pivot for quicksort @param[in] values Integer values to sort by\n@param[in,out] indices Index array to be partitioned\n@param[in] low Lower bound of partition range\n@param[in] high Upper bound of partition range (pivot position)\n@param[in] ascending Sort direction\n@return Index of the pivot after partitioning Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending Return Value integer Source Code function partition_indices_integer ( values , indices , low , high , ascending ) result ( pivot_idx ) integer ( ik ), dimension (:), intent ( in ) :: values integer , dimension (:), intent ( inout ) :: indices integer , intent ( in ) :: low , high logical , intent ( in ) :: ascending integer :: pivot_idx integer ( ik ) :: pivot integer :: i , j , temp pivot = values ( indices ( high )) i = low - 1 do j = low , high - 1 if (( ascending . and . values ( indices ( j )) <= pivot ) . or . & (. not . ascending . and . values ( indices ( j )) >= pivot )) then i = i + 1 temp = indices ( i ) indices ( i ) = indices ( j ) indices ( j ) = temp end if end do temp = indices ( i + 1 ) indices ( i + 1 ) = indices ( high ) indices ( high ) = temp pivot_idx = i + 1 end function partition_indices_integer","tags":"","url":"proc/partition_indices_integer.html"},{"title":"partition_indices_real – DataFort","text":"private  function partition_indices_real(values, indices, low, high, ascending) result(pivot_idx) Partition function for real value quicksort Partitions the indices array around a pivot for quicksort @param[in] values Real values to sort by\n@param[in,out] indices Index array to be partitioned\n@param[in] low Lower bound of partition range\n@param[in] high Upper bound of partition range (pivot position)\n@param[in] ascending Sort direction\n@return Index of the pivot after partitioning Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending Return Value integer Source Code function partition_indices_real ( values , indices , low , high , ascending ) result ( pivot_idx ) real ( rk ), dimension (:), intent ( in ) :: values integer , dimension (:), intent ( inout ) :: indices integer , intent ( in ) :: low , high logical , intent ( in ) :: ascending integer :: pivot_idx real ( rk ) :: pivot integer :: i , j , temp pivot = values ( indices ( high )) i = low - 1 do j = low , high - 1 if (( ascending . and . values ( indices ( j )) <= pivot ) . or . & (. not . ascending . and . values ( indices ( j )) >= pivot )) then i = i + 1 temp = indices ( i ) indices ( i ) = indices ( j ) indices ( j ) = temp end if end do temp = indices ( i + 1 ) indices ( i + 1 ) = indices ( high ) indices ( high ) = temp pivot_idx = i + 1 end function partition_indices_real","tags":"","url":"proc/partition_indices_real.html"},{"title":"df_sort_by_column – DataFort","text":"public  subroutine df_sort_by_column(df, col_index, ascending) Sort data frame by column values Sorts all rows of the data frame based on values in the specified column.\nOnly real and integer columns can be used for sorting. @param[in,out] df The data frame instance\n@param[in] col_index Index of column to sort by\n@param[in] ascending Optional sort direction (default: .true. for ascending) Note This operation modifies the data frame in place Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index logical, intent(in), optional :: ascending Source Code subroutine df_sort_by_column ( df , col_index , ascending ) type ( data_frame ), intent ( inout ) :: df integer , intent ( in ) :: col_index logical , intent ( in ), optional :: ascending logical :: asc integer , allocatable :: indices (:) integer :: i type ( column ) :: col asc = . true . if ( present ( ascending )) asc = ascending if ( col_index < 1 . or . col_index > df % ncols ()) then error stop \"Column index out of range in df_sort_by_column\" end if allocate ( indices ( df % nrows ())) do i = 1 , df % nrows () indices ( i ) = i end do col = df % get_data_col ( col_index ) select case ( col % get_type ()) case ( REAL_NUM ) call sort_indices_real ( col % getr (), indices , asc ) case ( INTEGER_NUM ) call sort_indices_integer ( col % geti (), indices , asc ) case default error stop \"Sorting only supported for real and integer columns\" end select call reorder_all_columns ( df , indices ) deallocate ( indices ) end subroutine df_sort_by_column","tags":"","url":"proc/df_sort_by_column.html"},{"title":"quicksort_indices_integer – DataFort","text":"private recursive subroutine quicksort_indices_integer(values, indices, low, high, ascending) Quicksort implementation for integer value indices Recursive quicksort algorithm that sorts indices based on integer values @param[in] values Integer values to sort by\n@param[in,out] indices Index array to be sorted\n@param[in] low Lower bound of sorting range\n@param[in] high Upper bound of sorting range\n@param[in] ascending Sort direction Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending Source Code recursive subroutine quicksort_indices_integer ( values , indices , low , high , ascending ) integer ( ik ), dimension (:), intent ( in ) :: values integer , dimension (:), intent ( inout ) :: indices integer , intent ( in ) :: low , high logical , intent ( in ) :: ascending integer :: pivot_idx if ( low < high ) then pivot_idx = partition_indices_integer ( values , indices , low , high , ascending ) call quicksort_indices_integer ( values , indices , low , pivot_idx - 1 , ascending ) call quicksort_indices_integer ( values , indices , pivot_idx + 1 , high , ascending ) end if end subroutine quicksort_indices_integer","tags":"","url":"proc/quicksort_indices_integer.html"},{"title":"quicksort_indices_real – DataFort","text":"private recursive subroutine quicksort_indices_real(values, indices, low, high, ascending) Quicksort implementation for real value indices Recursive quicksort algorithm that sorts indices based on real values @param[in] values Real values to sort by\n@param[in,out] indices Index array to be sorted\n@param[in] low Lower bound of sorting range\n@param[in] high Upper bound of sorting range\n@param[in] ascending Sort direction Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending Source Code recursive subroutine quicksort_indices_real ( values , indices , low , high , ascending ) real ( rk ), dimension (:), intent ( in ) :: values integer , dimension (:), intent ( inout ) :: indices integer , intent ( in ) :: low , high logical , intent ( in ) :: ascending integer :: pivot_idx if ( low < high ) then pivot_idx = partition_indices_real ( values , indices , low , high , ascending ) call quicksort_indices_real ( values , indices , low , pivot_idx - 1 , ascending ) call quicksort_indices_real ( values , indices , pivot_idx + 1 , high , ascending ) end if end subroutine quicksort_indices_real","tags":"","url":"proc/quicksort_indices_real.html"},{"title":"reorder_all_columns – DataFort","text":"private  subroutine reorder_all_columns(df, indices) Reorder all columns based on index array Internal helper that reorders all data frame columns according to an index array @param[in,out] df The data frame instance\n@param[in] indices Array specifying the new row order Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in), dimension(:) :: indices Source Code subroutine reorder_all_columns ( df , indices ) type ( data_frame ), intent ( inout ) :: df integer , dimension (:), intent ( in ) :: indices integer :: i , j real ( rk ), allocatable :: real_temp (:) integer ( ik ), allocatable :: int_temp (:) logical , allocatable :: logical_temp (:) character ( len = :), allocatable :: char_temp (:) complex ( rk ), allocatable :: complex_temp (:) type ( column ) :: col , new_col do i = 1 , df % ncols () col = df % get_data_col ( i ) select case ( col % get_type ()) case ( REAL_NUM ) allocate ( real_temp ( df % nrows ())) do j = 1 , df % nrows () real_temp ( j ) = col % getr ( indices ( j )) end do call col % destroy () call new_col % new ( real_temp ) call df % set_data_col ( i , new_col ) deallocate ( real_temp ) case ( INTEGER_NUM ) allocate ( int_temp ( df % nrows ())) do j = 1 , df % nrows () int_temp ( j ) = col % geti ( indices ( j )) end do call col % destroy () call new_col % new ( int_temp ) call df % set_data_col ( i , new_col ) deallocate ( int_temp ) case ( LOGICAL_NUM ) allocate ( logical_temp ( df % nrows ())) do j = 1 , df % nrows () logical_temp ( j ) = col % getl ( indices ( j )) end do call col % destroy () call new_col % new ( logical_temp ) call df % set_data_col ( i , new_col ) deallocate ( logical_temp ) case ( CHARACTER_NUM ) allocate ( character ( len = len ( col % getch ( 1 ))) :: char_temp ( df % nrows ())) do j = 1 , df % nrows () char_temp ( j ) = col % getch ( indices ( j )) end do call col % destroy () call new_col % new ( char_temp ) call df % set_data_col ( i , new_col ) deallocate ( char_temp ) case ( COMPLEX_NUM ) allocate ( complex_temp ( df % nrows ())) do j = 1 , df % nrows () complex_temp ( j ) = col % getc ( indices ( j )) end do call col % destroy () call new_col % new ( complex_temp ) call df % set_data_col ( i , new_col ) deallocate ( complex_temp ) end select end do end subroutine reorder_all_columns","tags":"","url":"proc/reorder_all_columns~2.html"},{"title":"sort_indices_integer – DataFort","text":"private  subroutine sort_indices_integer(values, indices, ascending) Sort indices array based on integer values Internal helper that sorts an index array based on corresponding integer values @param[in] values Integer values to sort by\n@param[in,out] indices Index array to be sorted\n@param[in] ascending Sort direction Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices logical, intent(in) :: ascending Source Code subroutine sort_indices_integer ( values , indices , ascending ) integer ( ik ), dimension (:), intent ( in ) :: values integer , dimension (:), intent ( inout ) :: indices logical , intent ( in ) :: ascending if ( size ( values ) > 0 ) then call quicksort_indices_integer ( values , indices , 1 , size ( values ), ascending ) end if end subroutine sort_indices_integer","tags":"","url":"proc/sort_indices_integer.html"},{"title":"sort_indices_real – DataFort","text":"private  subroutine sort_indices_real(values, indices, ascending) Sort indices array based on real values Internal helper that sorts an index array based on corresponding real values @param[in] values Real values to sort by\n@param[in,out] indices Index array to be sorted\n@param[in] ascending Sort direction Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices logical, intent(in) :: ascending Source Code subroutine sort_indices_real ( values , indices , ascending ) real ( rk ), dimension (:), intent ( in ) :: values integer , dimension (:), intent ( inout ) :: indices logical , intent ( in ) :: ascending if ( size ( values ) > 0 ) then call quicksort_indices_real ( values , indices , 1 , size ( values ), ascending ) end if end subroutine sort_indices_real","tags":"","url":"proc/sort_indices_real.html"},{"title":"df_concat – DataFort","text":"public  function df_concat(df1, df2, axis) result(result_df) Concatenate two data frames vertically (rows) or horizontally (columns) @param[in] df1 First data frame\n@param[in] df2 Second data frame\n@param[in] axis 0 for vertical (stack rows), 1 for horizontal (add columns)\n@return Concatenated data frame Note For axis=0 (vertical), both data frames must have same number of columns Note For axis=1 (horizontal), both data frames must have same number of rows Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in) :: axis Return Value type( data_frame ) Source Code function df_concat ( df1 , df2 , axis ) result ( result_df ) type ( data_frame ), intent ( in ) :: df1 , df2 integer , intent ( in ) :: axis type ( data_frame ) :: result_df integer :: i , j , dtype character ( len = 100 ) :: header_name real ( rk ), dimension (:), allocatable :: real_col1 , real_col2 , real_combined , real_col integer ( ik ), dimension (:), allocatable :: int_col1 , int_col2 , int_combined , int_col logical , dimension (:), allocatable :: log_col1 , log_col2 , log_combined , log_col character ( len = :), allocatable :: char_col1 (:), char_col2 (:), char_combined (:), char_col (:) complex ( rk ), dimension (:), allocatable :: cmplx_col1 , cmplx_col2 , cmplx_combined , cmplx_col if ( axis == 0 ) then ! Vertical concatenation (stack rows) if ( df1 % ncols () /= df2 % ncols ()) then print * , \"Error: DataFrames must have same number of columns\" call result_df % new () return end if call result_df % new ( max ( df1 % get_max_char_len (), df2 % get_max_char_len ())) do i = 1 , df1 % ncols () dtype = df1 % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) real_col1 = df_get_col_real ( df1 , i ) real_col2 = df_get_col_real ( df2 , i ) allocate ( real_combined ( size ( real_col1 ) + size ( real_col2 ))) real_combined ( 1 : size ( real_col1 )) = real_col1 real_combined ( size ( real_col1 ) + 1 :) = real_col2 if ( df1 % get_with_headers ()) then header_name = df1 % header ( i ) call df_append_real ( result_df , real_combined , trim ( header_name )) else call df_append_real ( result_df , real_combined ) end if deallocate ( real_col1 , real_col2 , real_combined ) case ( INTEGER_NUM ) int_col1 = df_get_col_integer ( df1 , i ) int_col2 = df_get_col_integer ( df2 , i ) allocate ( int_combined ( size ( int_col1 ) + size ( int_col2 ))) int_combined ( 1 : size ( int_col1 )) = int_col1 int_combined ( size ( int_col1 ) + 1 :) = int_col2 if ( df1 % get_with_headers ()) then header_name = df1 % header ( i ) call df_append_integer ( result_df , int_combined , trim ( header_name )) else call df_append_integer ( result_df , int_combined ) end if deallocate ( int_col1 , int_col2 , int_combined ) case ( LOGICAL_NUM ) log_col1 = df_get_col_logical ( df1 , i ) log_col2 = df_get_col_logical ( df2 , i ) allocate ( log_combined ( size ( log_col1 ) + size ( log_col2 ))) log_combined ( 1 : size ( log_col1 )) = log_col1 log_combined ( size ( log_col1 ) + 1 :) = log_col2 if ( df1 % get_with_headers ()) then header_name = df1 % header ( i ) call df_append_logical ( result_df , log_combined , trim ( header_name )) else call df_append_logical ( result_df , log_combined ) end if deallocate ( log_col1 , log_col2 , log_combined ) case ( CHARACTER_NUM ) char_col1 = df_get_col_character ( df1 , i ) char_col2 = df_get_col_character ( df2 , i ) allocate ( character ( len = max ( len ( char_col1 ), len ( char_col2 ))) :: char_combined ( size ( char_col1 ) + size ( char_col2 ))) char_combined ( 1 : size ( char_col1 )) = char_col1 char_combined ( size ( char_col1 ) + 1 :) = char_col2 if ( df1 % get_with_headers ()) then header_name = df1 % header ( i ) call df_append_character ( result_df , char_combined , trim ( header_name )) else call df_append_character ( result_df , char_combined ) end if deallocate ( char_col1 , char_col2 , char_combined ) case ( COMPLEX_NUM ) cmplx_col1 = df_get_col_complex ( df1 , i ) cmplx_col2 = df_get_col_complex ( df2 , i ) allocate ( cmplx_combined ( size ( cmplx_col1 ) + size ( cmplx_col2 ))) cmplx_combined ( 1 : size ( cmplx_col1 )) = cmplx_col1 cmplx_combined ( size ( cmplx_col1 ) + 1 :) = cmplx_col2 if ( df1 % get_with_headers ()) then header_name = df1 % header ( i ) call df_append_complex ( result_df , cmplx_combined , trim ( header_name )) else call df_append_complex ( result_df , cmplx_combined ) end if deallocate ( cmplx_col1 , cmplx_col2 , cmplx_combined ) end select end do else if ( axis == 1 ) then ! Horizontal concatenation (add columns) if ( df1 % nrows () /= df2 % nrows ()) then print * , \"Error: DataFrames must have same number of rows\" call result_df % new () return end if result_df = df_copy ( df1 ) ! Add columns from df2 do i = 1 , df2 % ncols () dtype = df2 % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) real_col = df_get_col_real ( df2 , i ) if ( df2 % get_with_headers ()) then header_name = df2 % header ( i ) call df_append_real ( result_df , real_col , trim ( header_name )) else call df_append_real ( result_df , real_col ) end if deallocate ( real_col ) case ( INTEGER_NUM ) int_col = df_get_col_integer ( df2 , i ) if ( df2 % get_with_headers ()) then header_name = df2 % header ( i ) call df_append_integer ( result_df , int_col , trim ( header_name )) else call df_append_integer ( result_df , int_col ) end if deallocate ( int_col ) case ( LOGICAL_NUM ) log_col = df_get_col_logical ( df2 , i ) if ( df2 % get_with_headers ()) then header_name = df2 % header ( i ) call df_append_logical ( result_df , log_col , trim ( header_name )) else call df_append_logical ( result_df , log_col ) end if deallocate ( log_col ) case ( CHARACTER_NUM ) char_col = df_get_col_character ( df2 , i ) if ( df2 % get_with_headers ()) then header_name = df2 % header ( i ) call df_append_character ( result_df , char_col , trim ( header_name )) else call df_append_character ( result_df , char_col ) end if deallocate ( char_col ) case ( COMPLEX_NUM ) cmplx_col = df_get_col_complex ( df2 , i ) if ( df2 % get_with_headers ()) then header_name = df2 % header ( i ) call df_append_complex ( result_df , cmplx_col , trim ( header_name )) else call df_append_complex ( result_df , cmplx_col ) end if deallocate ( cmplx_col ) end select end do else print * , \"Error: axis must be 0 (vertical) or 1 (horizontal)\" call result_df % new () end if end function df_concat","tags":"","url":"proc/df_concat.html"},{"title":"df_drop_duplicates – DataFort","text":"public  function df_drop_duplicates(df) result(unique_df) Remove duplicate rows Returns new data frame with duplicate rows removed (keeps first occurrence) @param[in] df The data frame instance\n@return Data frame with unique rows only Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value type( data_frame ) Source Code function df_drop_duplicates ( df ) result ( unique_df ) type ( data_frame ), intent ( in ) :: df type ( data_frame ) :: unique_df logical , dimension (:), allocatable :: is_dup , keep_mask integer :: i , j , num_unique , dtype integer , dimension (:), allocatable :: unique_indices character ( len = 100 ) :: header_name real ( rk ), dimension (:), allocatable :: real_col , real_unique_col integer ( ik ), dimension (:), allocatable :: int_col , int_unique_col logical , dimension (:), allocatable :: log_col , log_unique_col character ( len = :), allocatable :: char_col (:), char_unique_col (:) complex ( rk ), dimension (:), allocatable :: cmplx_col , cmplx_unique_col is_dup = df_duplicated ( df ) allocate ( keep_mask ( df % nrows ())) keep_mask = . not . is_dup num_unique = count ( keep_mask ) if ( num_unique == 0 ) then call unique_df % new () return end if ! Build index array allocate ( unique_indices ( num_unique )) j = 0 do i = 1 , df % nrows () if ( keep_mask ( i )) then j = j + 1 unique_indices ( j ) = i end if end do ! Build result data frame call unique_df % new ( df % get_max_char_len ()) do i = 1 , df % ncols () dtype = df % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) real_col = df_get_col_real ( df , i ) allocate ( real_unique_col ( num_unique )) do j = 1 , num_unique real_unique_col ( j ) = real_col ( unique_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_real ( unique_df , real_unique_col , trim ( header_name )) else call df_append_real ( unique_df , real_unique_col ) end if deallocate ( real_unique_col ) case ( INTEGER_NUM ) int_col = df_get_col_integer ( df , i ) allocate ( int_unique_col ( num_unique )) do j = 1 , num_unique int_unique_col ( j ) = int_col ( unique_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_integer ( unique_df , int_unique_col , trim ( header_name )) else call df_append_integer ( unique_df , int_unique_col ) end if deallocate ( int_unique_col ) case ( LOGICAL_NUM ) log_col = df_get_col_logical ( df , i ) allocate ( log_unique_col ( num_unique )) do j = 1 , num_unique log_unique_col ( j ) = log_col ( unique_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_logical ( unique_df , log_unique_col , trim ( header_name )) else call df_append_logical ( unique_df , log_unique_col ) end if deallocate ( log_unique_col ) case ( CHARACTER_NUM ) char_col = df_get_col_character ( df , i ) allocate ( character ( len = len ( char_col )) :: char_unique_col ( num_unique )) do j = 1 , num_unique char_unique_col ( j ) = char_col ( unique_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_character ( unique_df , char_unique_col , trim ( header_name )) else call df_append_character ( unique_df , char_unique_col ) end if deallocate ( char_unique_col ) case ( COMPLEX_NUM ) cmplx_col = df_get_col_complex ( df , i ) allocate ( cmplx_unique_col ( num_unique )) do j = 1 , num_unique cmplx_unique_col ( j ) = cmplx_col ( unique_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_complex ( unique_df , cmplx_unique_col , trim ( header_name )) else call df_append_complex ( unique_df , cmplx_unique_col ) end if deallocate ( cmplx_unique_col ) end select end do deallocate ( is_dup , keep_mask , unique_indices ) end function df_drop_duplicates","tags":"","url":"proc/df_drop_duplicates.html"},{"title":"df_drop_duplicates_subset – DataFort","text":"public  function df_drop_duplicates_subset(df, col_indices) result(unique_df) Drop duplicate rows based on specific columns (subset) Returns new data frame with duplicate rows removed, where duplicates are\ndetermined by comparing only the specified columns. Keeps first occurrence. @param[in] df The data frame instance\n@param[in] col_indices Array of column indices to check for duplicates\n@return New data frame with duplicate rows removed Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_indices (:) Return Value type( data_frame ) Source Code function df_drop_duplicates_subset ( df , col_indices ) result ( unique_df ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_indices (:) type ( data_frame ) :: unique_df logical , dimension (:), allocatable :: is_dup , keep_mask integer , dimension (:), allocatable :: unique_indices integer :: i , j , k , row1 , row2 , dtype , num_unique , col_idx logical :: is_duplicate character ( len = :), allocatable :: header_name real ( rk ), dimension (:), allocatable :: real_col , real_unique_col integer ( ik ), dimension (:), allocatable :: int_col , int_unique_col logical , dimension (:), allocatable :: log_col , log_unique_col character ( len = :), allocatable :: char_col (:), char_unique_col (:) complex ( rk ), dimension (:), allocatable :: cmplx_col , cmplx_unique_col allocate ( is_dup ( df % nrows ())) is_dup = . false . ! Check each row against all previous rows (only comparing subset columns) do row1 = 1 , df % nrows () if ( is_dup ( row1 )) cycle do row2 = row1 + 1 , df % nrows () if ( is_dup ( row2 )) cycle is_duplicate = . true . ! Only check columns in subset do k = 1 , size ( col_indices ) col_idx = col_indices ( k ) dtype = df % dtype ( col_idx ) select case ( dtype ) case ( REAL_NUM ) real_col = df_get_col_real ( df , col_idx ) if (. not . ieee_is_nan ( real_col ( row1 )) . and . . not . ieee_is_nan ( real_col ( row2 ))) then if ( real_col ( row1 ) /= real_col ( row2 )) then is_duplicate = . false . exit end if else if ( ieee_is_nan ( real_col ( row1 )) . neqv . ieee_is_nan ( real_col ( row2 ))) then is_duplicate = . false . exit end if case ( INTEGER_NUM ) int_col = df_get_col_integer ( df , col_idx ) if (. not . is_nan_integer ( int_col ( row1 )) . and . . not . is_nan_integer ( int_col ( row2 ))) then if ( int_col ( row1 ) /= int_col ( row2 )) then is_duplicate = . false . exit end if else if ( is_nan_integer ( int_col ( row1 )) . neqv . is_nan_integer ( int_col ( row2 ))) then is_duplicate = . false . exit end if case ( LOGICAL_NUM ) log_col = df_get_col_logical ( df , col_idx ) if ( log_col ( row1 ) . neqv . log_col ( row2 )) then is_duplicate = . false . exit end if case ( CHARACTER_NUM ) char_col = df_get_col_character ( df , col_idx ) if ( char_col ( row1 ) /= char_col ( row2 )) then is_duplicate = . false . exit end if case ( COMPLEX_NUM ) cmplx_col = df_get_col_complex ( df , col_idx ) if ( cmplx_col ( row1 ) /= cmplx_col ( row2 )) then is_duplicate = . false . exit end if end select end do if ( is_duplicate ) then is_dup ( row2 ) = . true . end if end do end do ! Build mask for rows to keep allocate ( keep_mask ( df % nrows ())) keep_mask = . not . is_dup num_unique = count ( keep_mask ) ! Get indices of unique rows allocate ( unique_indices ( num_unique )) j = 0 do i = 1 , df % nrows () if ( keep_mask ( i )) then j = j + 1 unique_indices ( j ) = i end if end do ! Build result data frame with all columns call unique_df % new ( df % get_max_char_len ()) do i = 1 , df % ncols () dtype = df % dtype ( i ) select case ( dtype ) case ( REAL_NUM ) real_col = df_get_col_real ( df , i ) allocate ( real_unique_col ( num_unique )) do j = 1 , num_unique real_unique_col ( j ) = real_col ( unique_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_real ( unique_df , real_unique_col , trim ( header_name )) else call df_append_real ( unique_df , real_unique_col ) end if deallocate ( real_unique_col ) case ( INTEGER_NUM ) int_col = df_get_col_integer ( df , i ) allocate ( int_unique_col ( num_unique )) do j = 1 , num_unique int_unique_col ( j ) = int_col ( unique_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_integer ( unique_df , int_unique_col , trim ( header_name )) else call df_append_integer ( unique_df , int_unique_col ) end if deallocate ( int_unique_col ) case ( LOGICAL_NUM ) log_col = df_get_col_logical ( df , i ) allocate ( log_unique_col ( num_unique )) do j = 1 , num_unique log_unique_col ( j ) = log_col ( unique_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_logical ( unique_df , log_unique_col , trim ( header_name )) else call df_append_logical ( unique_df , log_unique_col ) end if deallocate ( log_unique_col ) case ( CHARACTER_NUM ) char_col = df_get_col_character ( df , i ) allocate ( character ( len = len ( char_col )) :: char_unique_col ( num_unique )) do j = 1 , num_unique char_unique_col ( j ) = char_col ( unique_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_character ( unique_df , char_unique_col , trim ( header_name )) else call df_append_character ( unique_df , char_unique_col ) end if deallocate ( char_unique_col ) case ( COMPLEX_NUM ) cmplx_col = df_get_col_complex ( df , i ) allocate ( cmplx_unique_col ( num_unique )) do j = 1 , num_unique cmplx_unique_col ( j ) = cmplx_col ( unique_indices ( j )) end do if ( df % get_with_headers ()) then header_name = df % header ( i ) call df_append_complex ( unique_df , cmplx_unique_col , trim ( header_name )) else call df_append_complex ( unique_df , cmplx_unique_col ) end if deallocate ( cmplx_unique_col ) end select end do deallocate ( is_dup , keep_mask , unique_indices ) end function df_drop_duplicates_subset","tags":"","url":"proc/df_drop_duplicates_subset.html"},{"title":"df_duplicated – DataFort","text":"public  function df_duplicated(df) result(is_dup) Check which rows are duplicates Returns a logical array where .true. indicates the row is a duplicate\nof a previous row. The first occurrence is not marked as duplicate. @param[in] df The data frame instance\n@return Logical array indicating duplicate rows Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value logical, dimension(:), allocatable Source Code function df_duplicated ( df ) result ( is_dup ) type ( data_frame ), intent ( in ) :: df logical , dimension (:), allocatable :: is_dup integer :: i , j , k , dtype logical :: rows_match allocate ( is_dup ( df % nrows ())) is_dup = . false . do i = 2 , df % nrows () do j = 1 , i - 1 rows_match = . true . ! Compare all columns do k = 1 , df % ncols () dtype = df % dtype ( k ) select case ( dtype ) case ( REAL_NUM ) if ( abs ( df_get_val_real ( df , i , k ) - df_get_val_real ( df , j , k )) >= 1.0e-10_rk ) then rows_match = . false . exit end if case ( INTEGER_NUM ) if ( df_get_val_integer ( df , i , k ) /= df_get_val_integer ( df , j , k )) then rows_match = . false . exit end if case ( LOGICAL_NUM ) if ( df_get_val_logical ( df , i , k ) . neqv . df_get_val_logical ( df , j , k )) then rows_match = . false . exit end if case ( CHARACTER_NUM ) if ( trim ( df_get_val_character ( df , i , k )) /= trim ( df_get_val_character ( df , j , k ))) then rows_match = . false . exit end if case ( COMPLEX_NUM ) if ( df_get_val_complex ( df , i , k ) /= df_get_val_complex ( df , j , k )) then rows_match = . false . exit end if end select end do if ( rows_match ) then is_dup ( i ) = . true . exit end if end do end do end function df_duplicated","tags":"","url":"proc/df_duplicated.html"},{"title":"df_unique_character – DataFort","text":"public  function df_unique_character(df, col_index) result(unique_vals) Get unique values from a character column Returns array of unique values from the specified character column @param[in] df The data frame instance\n@param[in] col_index Column index (1-based)\n@return Array of unique values (unsorted) Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value character(len=:), allocatable, (:) Source Code function df_unique_character ( df , col_index ) result ( unique_vals ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index character ( len = :), allocatable :: unique_vals (:) character ( len = :), allocatable :: col (:), temp_unique (:) integer :: i , j , n_unique logical :: is_unique col = df_get_col_character ( df , col_index ) allocate ( character ( len = len ( col )) :: temp_unique ( size ( col ))) n_unique = 0 do i = 1 , size ( col ) is_unique = . true . do j = 1 , n_unique if ( trim ( col ( i )) == trim ( temp_unique ( j ))) then is_unique = . false . exit end if end do if ( is_unique ) then n_unique = n_unique + 1 temp_unique ( n_unique ) = col ( i ) end if end do allocate ( character ( len = len ( col )) :: unique_vals ( n_unique )) unique_vals = temp_unique ( 1 : n_unique ) deallocate ( temp_unique ) end function df_unique_character","tags":"","url":"proc/df_unique_character.html"},{"title":"df_unique_integer – DataFort","text":"public  function df_unique_integer(df, col_index) result(unique_vals) Get unique values from an integer column Returns sorted array of unique values from the specified integer column @param[in] df The data frame instance\n@param[in] col_index Column index (1-based)\n@return Array of unique values (sorted) Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value integer(kind=ik), dimension(:), allocatable Source Code function df_unique_integer ( df , col_index ) result ( unique_vals ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index integer ( ik ), dimension (:), allocatable :: unique_vals integer ( ik ), dimension (:), allocatable :: col , temp_unique integer :: i , j , n_unique logical :: is_unique col = df_get_col_integer ( df , col_index ) allocate ( temp_unique ( size ( col ))) n_unique = 0 do i = 1 , size ( col ) is_unique = . true . do j = 1 , n_unique if ( col ( i ) == temp_unique ( j )) then is_unique = . false . exit end if end do if ( is_unique ) then n_unique = n_unique + 1 temp_unique ( n_unique ) = col ( i ) end if end do allocate ( unique_vals ( n_unique )) unique_vals = temp_unique ( 1 : n_unique ) ! Sort unique values call quick_sort_integer ( unique_vals , 1 , n_unique ) deallocate ( temp_unique ) end function df_unique_integer","tags":"","url":"proc/df_unique_integer.html"},{"title":"df_unique_real – DataFort","text":"public  function df_unique_real(df, col_index) result(unique_vals) Get unique values from a real column Returns sorted array of unique values from the specified real column @param[in] df The data frame instance\n@param[in] col_index Column index (1-based)\n@return Array of unique values (sorted) Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk), dimension(:), allocatable Source Code function df_unique_real ( df , col_index ) result ( unique_vals ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index real ( rk ), dimension (:), allocatable :: unique_vals real ( rk ), dimension (:), allocatable :: col , temp_unique integer :: i , j , n_unique logical :: is_unique col = df_get_col_real ( df , col_index ) allocate ( temp_unique ( size ( col ))) n_unique = 0 do i = 1 , size ( col ) is_unique = . true . do j = 1 , n_unique if ( abs ( col ( i ) - temp_unique ( j )) < 1.0e-10_rk ) then is_unique = . false . exit end if end do if ( is_unique ) then n_unique = n_unique + 1 temp_unique ( n_unique ) = col ( i ) end if end do allocate ( unique_vals ( n_unique )) unique_vals = temp_unique ( 1 : n_unique ) ! Sort unique values call quick_sort_real ( unique_vals , 1 , n_unique ) deallocate ( temp_unique ) end function df_unique_real","tags":"","url":"proc/df_unique_real.html"},{"title":"df_value_counts_character – DataFort","text":"public  function df_value_counts_character(df, col_index) result(counts_df) Count occurrences of each value in a character column Returns a data frame with two columns: unique values and their counts @param[in] df The data frame instance\n@param[in] col_index Column index (1-based)\n@return Data frame with columns “Value” and “Count” Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value type( data_frame ) Source Code function df_value_counts_character ( df , col_index ) result ( counts_df ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index type ( data_frame ) :: counts_df character ( len = :), allocatable :: col (:), unique_vals (:) integer ( ik ), dimension (:), allocatable :: counts integer :: i , j unique_vals = df_unique_character ( df , col_index ) allocate ( counts ( size ( unique_vals ))) counts = 0 col = df_get_col_character ( df , col_index ) do i = 1 , size ( col ) do j = 1 , size ( unique_vals ) if ( trim ( col ( i )) == trim ( unique_vals ( j ))) then counts ( j ) = counts ( j ) + 1 exit end if end do end do call counts_df % new () call df_append_character ( counts_df , unique_vals , \"Value\" ) call df_append_integer ( counts_df , counts , \"Count\" ) end function df_value_counts_character","tags":"","url":"proc/df_value_counts_character.html"},{"title":"df_value_counts_integer – DataFort","text":"public  function df_value_counts_integer(df, col_index) result(counts_df) Count occurrences of each value in an integer column Returns a data frame with two columns: unique values and their counts @param[in] df The data frame instance\n@param[in] col_index Column index (1-based)\n@return Data frame with columns “Value” and “Count” Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value type( data_frame ) Source Code function df_value_counts_integer ( df , col_index ) result ( counts_df ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index type ( data_frame ) :: counts_df integer ( ik ), dimension (:), allocatable :: col , unique_vals , counts integer :: i , j unique_vals = df_unique_integer ( df , col_index ) allocate ( counts ( size ( unique_vals ))) counts = 0 col = df_get_col_integer ( df , col_index ) do i = 1 , size ( col ) do j = 1 , size ( unique_vals ) if ( col ( i ) == unique_vals ( j )) then counts ( j ) = counts ( j ) + 1 exit end if end do end do call counts_df % new () call df_append_integer ( counts_df , unique_vals , \"Value\" ) call df_append_integer ( counts_df , counts , \"Count\" ) end function df_value_counts_integer","tags":"","url":"proc/df_value_counts_integer.html"},{"title":"df_value_counts_real – DataFort","text":"public  function df_value_counts_real(df, col_index) result(counts_df) Count occurrences of each value in a real column Returns a data frame with two columns: unique values and their counts @param[in] df The data frame instance\n@param[in] col_index Column index (1-based)\n@return Data frame with columns “Value” and “Count” Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value type( data_frame ) Source Code function df_value_counts_real ( df , col_index ) result ( counts_df ) type ( data_frame ), intent ( in ) :: df integer , intent ( in ) :: col_index type ( data_frame ) :: counts_df real ( rk ), dimension (:), allocatable :: col , unique_vals integer ( ik ), dimension (:), allocatable :: counts integer :: i , j unique_vals = df_unique_real ( df , col_index ) allocate ( counts ( size ( unique_vals ))) counts = 0 col = df_get_col_real ( df , col_index ) do i = 1 , size ( col ) do j = 1 , size ( unique_vals ) if ( abs ( col ( i ) - unique_vals ( j )) < 1.0e-10_rk ) then counts ( j ) = counts ( j ) + 1 exit end if end do end do call counts_df % new () call df_append_real ( counts_df , unique_vals , \"Value\" ) call df_append_integer ( counts_df , counts , \"Count\" ) end function df_value_counts_real","tags":"","url":"proc/df_value_counts_real.html"},{"title":"partition_integer – DataFort","text":"private  function partition_integer(arr, low, high) result(pivot_index) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high Return Value integer Source Code function partition_integer ( arr , low , high ) result ( pivot_index ) integer ( ik ), intent ( inout ) :: arr (:) integer , intent ( in ) :: low , high integer :: pivot_index integer ( ik ) :: pivot , temp integer :: i , j pivot = arr ( high ) i = low - 1 do j = low , high - 1 if ( arr ( j ) <= pivot ) then i = i + 1 temp = arr ( i ) arr ( i ) = arr ( j ) arr ( j ) = temp end if end do temp = arr ( i + 1 ) arr ( i + 1 ) = arr ( high ) arr ( high ) = temp pivot_index = i + 1 end function partition_integer","tags":"","url":"proc/partition_integer.html"},{"title":"partition_real – DataFort","text":"private  function partition_real(arr, low, high) result(pivot_index) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high Return Value integer Source Code function partition_real ( arr , low , high ) result ( pivot_index ) real ( rk ), intent ( inout ) :: arr (:) integer , intent ( in ) :: low , high integer :: pivot_index real ( rk ) :: pivot , temp integer :: i , j pivot = arr ( high ) i = low - 1 do j = low , high - 1 if ( arr ( j ) <= pivot ) then i = i + 1 temp = arr ( i ) arr ( i ) = arr ( j ) arr ( j ) = temp end if end do temp = arr ( i + 1 ) arr ( i + 1 ) = arr ( high ) arr ( high ) = temp pivot_index = i + 1 end function partition_real","tags":"","url":"proc/partition_real.html"},{"title":"quick_sort_integer – DataFort","text":"public recursive subroutine quick_sort_integer(arr, low, high) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high Source Code recursive subroutine quick_sort_integer ( arr , low , high ) integer ( ik ), intent ( inout ) :: arr (:) integer , intent ( in ) :: low , high integer :: pivot_index if ( low < high ) then pivot_index = partition_integer ( arr , low , high ) call quick_sort_integer ( arr , low , pivot_index - 1 ) call quick_sort_integer ( arr , pivot_index + 1 , high ) end if end subroutine quick_sort_integer","tags":"","url":"proc/quick_sort_integer.html"},{"title":"quick_sort_real – DataFort","text":"public recursive subroutine quick_sort_real(arr, low, high) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high Source Code recursive subroutine quick_sort_real ( arr , low , high ) real ( rk ), intent ( inout ) :: arr (:) integer , intent ( in ) :: low , high integer :: pivot_index if ( low < high ) then pivot_index = partition_real ( arr , low , high ) call quick_sort_real ( arr , low , pivot_index - 1 ) call quick_sort_real ( arr , pivot_index + 1 , high ) end if end subroutine quick_sort_real","tags":"","url":"proc/quick_sort_real.html"},{"title":"column_class – DataFort","text":"Uses types precision Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_CHAR_LEN_DEFAULT = 100 Derived Types type, public :: column Components Type Visibility Attributes Name Initial complex(kind=rk), private, dimension(:), allocatable :: ccol character(len=:), private, dimension(:), allocatable :: charcol integer, public :: dtype = 0 integer(kind=ik), private, dimension(:), allocatable :: icol logical, private :: initialized = .false. logical, private, dimension(:), allocatable :: lcol integer, public :: n real(kind=rk), private, dimension(:), allocatable :: rcol Type-Bound Procedures procedure, public :: changec => change_col_complex procedure, public :: changech => change_col_character procedure, public :: changei => change_col_integer procedure, public :: changel => change_col_logical procedure, public :: changer => change_col_real procedure, private :: col_constructor_character procedure, private :: col_constructor_complex procedure, private :: col_constructor_integer procedure, private :: col_constructor_logical procedure, private :: col_constructor_real procedure, public :: destroy => col_destructor procedure, public :: emptyc => col_constructor_alloc_complex procedure, public :: emptych => col_constructor_alloc_character procedure, public :: emptyi => col_constructor_alloc_integer procedure, public :: emptyl => col_constructor_alloc_logical procedure, public :: emptyr => col_constructor_alloc_real procedure, private :: get_from_col_character procedure, private :: get_from_col_complex procedure, private :: get_from_col_integer procedure, private :: get_from_col_logical procedure, private :: get_from_col_real procedure, private :: get_single_col_character procedure, private :: get_single_col_complex procedure, private :: get_single_col_integer procedure, private :: get_single_col_logical procedure, private :: get_single_col_real procedure, public :: get_type => get_from_col_dtype generic, public :: getc => get_from_col_complex , get_single_col_complex generic, public :: getch => get_from_col_character , get_single_col_character generic, public :: geti => get_from_col_integer , get_single_col_integer generic, public :: getl => get_from_col_logical , get_single_col_logical generic, public :: getr => get_from_col_real , get_single_col_real generic, public :: new => col_constructor_real , col_constructor_integer , col_constructor_logical , col_constructor_character , col_constructor_complex Functions private pure function get_from_col_character (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value character(len=:), dimension(:), allocatable private pure function get_from_col_complex (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value complex(kind=rk), dimension(this % n) private pure function get_from_col_dtype (this) result(dtype) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer private pure function get_from_col_integer (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value integer(kind=ik), dimension(this % n) private pure function get_from_col_logical (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value logical, dimension(this % n) private pure function get_from_col_real (this) result(col) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this Return Value real(kind=rk), dimension(this % n) private pure function get_single_col_character (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value character(len=:), allocatable private pure function get_single_col_complex (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value complex(kind=rk) private pure function get_single_col_integer (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value integer(kind=ik) private pure function get_single_col_logical (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value logical private pure function get_single_col_real (this, i) result(val) Arguments Type Intent Optional Attributes Name class( column ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) Subroutines private  subroutine change_col_character (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i character(len=*), intent(in) :: val private  subroutine change_col_complex (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i complex(kind=rk), intent(in) :: val private  subroutine change_col_integer (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i integer(kind=ik), intent(in) :: val private  subroutine change_col_logical (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i logical, intent(in) :: val private  subroutine change_col_real (this, i, val) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: i real(kind=rk), intent(in) :: val private  subroutine col_constructor_alloc_character (this, n, len) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n integer, intent(in), optional :: len private  subroutine col_constructor_alloc_complex (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n private  subroutine col_constructor_alloc_integer (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n private  subroutine col_constructor_alloc_logical (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n private  subroutine col_constructor_alloc_real (this, n) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer, intent(in) :: n private  subroutine col_constructor_character (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: dcol private  subroutine col_constructor_complex (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: dcol private  subroutine col_constructor_integer (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: dcol private  subroutine col_constructor_logical (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this logical, intent(in), dimension(:) :: dcol private  subroutine col_constructor_real (this, dcol) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: dcol private  subroutine col_destructor (this) Arguments Type Intent Optional Attributes Name class( column ), intent(inout) :: this","tags":"","url":"module/column_class.html"},{"title":"types – DataFort","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: CHARACTER_NUM = 4 integer, public, parameter :: COMPLEX_NUM = 5 integer, public, parameter :: INTEGER_NUM = 2 integer, public, parameter :: LOGICAL_NUM = 3 integer, public, parameter :: REAL_NUM = 1","tags":"","url":"module/types.html"},{"title":"datafort_io – DataFort","text":"DataFort I/O Module This module provides I/O operations for data frames including CSV reading/writing\nand console output. Functions CSV Operations df_write_csv(df, filename) - Export data frame to CSV file df_read_csv(df, filename, has_headers) - Import CSV file into data frame Console Output df_write_console(df, unit) - Display data frame in console Uses datafort_types column_class types precision datafort_accessors Subroutines private  subroutine add_csv_column (df, data_strings, headers, col_index, has_headers) Add a column with automatic type detection Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df character(len=*), intent(in), dimension(:) :: data_strings character(len=*), intent(in), optional, dimension(:) :: headers integer, intent(in) :: col_index logical, intent(in) :: has_headers public  subroutine df_read_csv (df, filename, has_headers) Import CSV file into data frame Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df character(len=*), intent(in) :: filename logical, intent(in) :: has_headers public  subroutine df_write_console (df, unit) Display data frame in console Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in), optional :: unit public  subroutine df_write_csv (df, filename) Export data frame to CSV file Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df character(len=*), intent(in) :: filename private  subroutine parse_csv_line (line, fields) Parse a CSV line into fields Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=100), intent(out), allocatable :: fields (:)","tags":"","url":"module/datafort_io.html"},{"title":"datafort_types – DataFort","text":"DataFort Types Module This module provides the core data_frame type definition and essential operations.\nIt contains the type definition, constructor/destructor, and basic getter functions. All data manipulation operations are provided as standalone functions in separate modules. Uses types column_class precision Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_CHAR_LEN_DEFAULT = 100 Derived Types type, public :: data_frame Main data frame type for storing heterogeneous tabular data Read more… Components Type Visibility Attributes Name Initial type( column ), private, dimension(:), allocatable :: data_cols character(len=:), private, dimension(:), allocatable :: headers logical, private :: initialized = .false. integer, private :: max_char_len = MAX_CHAR_LEN_DEFAULT integer, private :: num_cols = 0 logical, private :: with_headers = .false. Type-Bound Procedures procedure, public :: already_header procedure, public :: destroy => df_destructor procedure, private :: df_get_col_type_header procedure, private :: df_get_col_type_index generic, public :: dtype => df_get_col_type_header , df_get_col_type_index procedure, public :: find_header_index procedure, public :: get_data_col procedure, public :: get_max_char_len => df_get_max_char_len procedure, public :: get_with_headers procedure, public :: header => get_header procedure, public :: increment_num_cols procedure, public :: is_initialized => df_is_initialized procedure, public :: ncols => df_get_num_cols procedure, public :: new => df_constructor procedure, public :: nrows => df_get_num_rows procedure, public :: resize_storage procedure, public :: set_data_col procedure, public :: set_header_at_index procedure, public :: set_with_headers procedure, public :: validate_column_addition Functions private  function already_header (this, header) result(exists) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value logical private pure function df_get_col_type_header (this, header) result(dtype) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer private pure function df_get_col_type_index (this, index) result(dtype) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value integer private pure function df_get_max_char_len (this) result(max_len) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer private pure function df_get_num_cols (this) result(num_cols) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer private pure function df_get_num_rows (this) result(num_rows) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value integer private pure function df_is_initialized (this) result(is_init) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical private pure function find_header_index (this, header) result(index) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this character(len=*), intent(in) :: header Return Value integer private  function get_data_col (this, index) result(col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value type( column ) private  function get_header (this, index) result(header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this integer, intent(in) :: index Return Value character(len=:), allocatable private pure function get_with_headers (this) result(has_headers) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(in) :: this Return Value logical Subroutines private  subroutine df_constructor (this, char_len) Initialize a new data frame Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in), optional :: char_len private  subroutine df_destructor (this) Destroy a data frame and free all memory Read more… Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this private  subroutine increment_num_cols (this) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this private  subroutine resize_storage (this) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this private  subroutine set_data_col (this, index, col) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: index type( column ), intent(in) :: col private  subroutine set_header_at_index (this, index, header) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this integer, intent(in) :: index character(len=*), intent(in) :: header private  subroutine set_with_headers (this, has_headers) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this logical, intent(in) :: has_headers private  subroutine validate_column_addition (this, header, col_size) Arguments Type Intent Optional Attributes Name class( data_frame ), intent(inout) :: this character(len=*), intent(in), optional :: header integer, intent(in) :: col_size","tags":"","url":"module/datafort_types.html"},{"title":"split_mod – DataFort","text":"Functions private pure elemental function lower (str, begin, end) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character(len=len(str)) public pure function split (input_line, delimiters, order, nulls) result(array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls Return Value character(len=:), allocatable, (:)","tags":"","url":"module/split_mod.html"},{"title":"datafort_statistics – DataFort","text":"DataFort Statistics Module This module provides standalone statistical functions for data frame analysis.\nAll functions take a data_frame as the first argument instead of being type-bound procedures. Functions Sum Functions df_sum_real(df, col_index) - Calculate sum of real column df_sum_integer(df, col_index) - Calculate sum of integer column Mean Functions df_mean_real(df, col_index) - Calculate mean of real column df_mean_integer(df, col_index) - Calculate mean of integer column Standard Deviation Functions df_std_real(df, col_index) - Calculate standard deviation of real column df_std_integer(df, col_index) - Calculate standard deviation of integer column Median Functions df_median_real(df, col_index) - Calculate median of real column df_median_integer(df, col_index) - Calculate median of integer column Percentile Functions df_percentile_real(df, col_index, percentile) - Calculate percentile of real column df_percentile_integer(df, col_index, percentile) - Calculate percentile of integer column Variance Functions df_variance_real(df, col_index) - Calculate variance of real column df_variance_integer(df, col_index) - Calculate variance of integer column Min/Max Functions df_min_real(df, col_index) - Find minimum value in real column df_min_integer(df, col_index) - Find minimum value in integer column df_max_real(df, col_index) - Find maximum value in real column df_max_integer(df, col_index) - Find maximum value in integer column Correlation Functions df_correlation_real(df, col_index1, col_index2) - Calculate Pearson correlation Summary Functions df_describe_numeric(df, unit) - Print summary statistics for all numeric columns Uses datafort_types utilities column_class types precision Functions public  function df_correlation_real (df, col_index1, col_index2) result(corr) Calculate Pearson correlation coefficient between two real columns Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index1 integer, intent(in) :: col_index2 Return Value real(kind=rk) public  function df_max_integer (df, col_index) result(max_val) Find maximum value in integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value integer(kind=ik) public  function df_max_real (df, col_index) result(max_val) Find maximum value in real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) public  function df_mean_integer (df, col_index) result(avg) Calculate the arithmetic mean of an integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) public  function df_mean_real (df, col_index) result(avg) Calculate the arithmetic mean of a real column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) public  function df_median_integer (df, col_index) result(med) Calculate median of integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) public  function df_median_real (df, col_index) result(med) Calculate median of real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) public  function df_min_integer (df, col_index) result(min_val) Find minimum value in integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value integer(kind=ik) public  function df_min_real (df, col_index) result(min_val) Find minimum value in real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) public  function df_percentile_integer (df, col_index, percentile) result(perc) Calculate percentile of integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: percentile Return Value real(kind=rk) public  function df_percentile_real (df, col_index, percentile) result(perc) Calculate percentile of real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: percentile Return Value real(kind=rk) public  function df_std_integer (df, col_index) result(stddev) Calculate standard deviation of integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) public  function df_std_real (df, col_index) result(stddev) Calculate standard deviation of real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) public  function df_sum_integer (df, col_index) result(total) Calculate sum of integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value integer(kind=ik) public  function df_sum_real (df, col_index) result(total) Calculate sum of real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) public  function df_variance_integer (df, col_index) result(var) Calculate variance of integer column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) public  function df_variance_real (df, col_index) result(var) Calculate variance of real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) Subroutines public  subroutine df_describe_numeric (df, unit) Print summary statistics for all numeric columns Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in), optional :: unit","tags":"","url":"module/datafort_statistics.html"},{"title":"datafort_joins – DataFort","text":"DataFort Joins Module This module provides standalone join and merge functions for data frames.\nAll functions take a data_frame as the first argument instead of being type-bound procedures. Functions Join Functions df_inner_join(df1, df2, key_col1, key_col2) - SQL-style inner join df_left_join(df1, df2, key_col1, key_col2) - SQL-style left join df_right_join(df1, df2, key_col1, key_col2) - SQL-style right join df_outer_join(df1, df2, key_col1, key_col2) - SQL-style outer join (full outer join) Merge Functions df_merge(df1, df2, on_column, how) - Merge using column names Notes All join functions return a new data frame Key columns must have the same data type (integer, real, or character) Right table columns are suffixed with “_right” to avoid name conflicts For merge, the ‘how’ parameter can be: “inner”, “left”, “right”, or “outer” Uses datafort_types column_class types precision datafort_accessors Functions public  function df_inner_join (df1, df2, key_col1, key_col2) result(joined_df) Perform an inner join between two data frames Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in) :: key_col1 integer, intent(in) :: key_col2 Return Value type( data_frame ) public  function df_left_join (df1, df2, key_col1, key_col2) result(joined_df) Perform a left join between two data frames Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in) :: key_col1 integer, intent(in) :: key_col2 Return Value type( data_frame ) public  function df_merge (df1, df2, on_column, how) result(merged_df) Merge two dataframes on column names (similar to SQL join but using names) Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 character(len=*), intent(in) :: on_column character(len=*), intent(in) :: how Return Value type( data_frame ) public  function df_outer_join (df1, df2, key_col1, key_col2) result(joined_df) Perform an outer join between two data frames Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in) :: key_col1 integer, intent(in) :: key_col2 Return Value type( data_frame ) public  function df_right_join (df1, df2, key_col1, key_col2) result(joined_df) Perform a right join between two data frames Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in) :: key_col1 integer, intent(in) :: key_col2 Return Value type( data_frame ) Subroutines private  subroutine build_joined_dataframe (df1, df2, indices1, indices2, num_rows, result_df) Helper subroutine to build joined dataframe from match indices Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in), dimension(:) :: indices1 integer, intent(in), dimension(:) :: indices2 integer, intent(in) :: num_rows type( data_frame ), intent(out) :: result_df","tags":"","url":"module/datafort_joins.html"},{"title":"datafort_transformations – DataFort","text":"DataFort Transformations Module This module provides standalone functions for transforming data frame columns.\nAll functions take a data_frame as the first argument instead of being type-bound procedures. Functions Normalization/Standardization df_normalize_column_real(df, col_index) - Normalize to [0,1] range df_standardize_column_real(df, col_index) - Standardize to mean=0, std=1 Absolute Value df_abs_column_real(df, col_index) - Absolute value for real column df_abs_column_integer(df, col_index) - Absolute value for integer column Cumulative Sum df_cumsum_real(df, col_index) - Cumulative sum for real column df_cumsum_integer(df, col_index) - Cumulative sum for integer column Differences df_diff_real(df, col_index) - Differences between consecutive rows (real) df_diff_integer(df, col_index) - Differences between consecutive rows (integer) Value Replacement df_replace_value_real(df, col_index, old_value, new_value) - Replace values in real column df_replace_value_integer(df, col_index, old_value, new_value) - Replace values in integer column Clipping df_clip_real(df, col_index, min_val, max_val) - Clip real values to range df_clip_integer(df, col_index, min_val, max_val) - Clip integer values to range Rounding df_round_column(df, col_index, decimals) - Round to decimal places Mathematical Functions df_log_column(df, col_index) - Natural logarithm df_exp_column(df, col_index) - Exponential df_sqrt_column(df, col_index) - Square root df_pow_column(df, col_index, power) - Raise to power Custom Transformation df_apply_to_column(df, col_index, func) - Apply custom function Uses datafort_types column_class types precision datafort_accessors Abstract Interfaces abstract interface public pure function transform_func(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk) Functions private  function calculate_max_real (df, col_index) result(max_val) Calculate maximum of a real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) private  function calculate_mean_real (df, col_index) result(avg) Calculate mean of a real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) private  function calculate_min_real (df, col_index) result(min_val) Calculate minimum of a real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) private  function calculate_std_real (df, col_index) result(stddev) Calculate standard deviation of a real column Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk) public  function df_diff_integer (df, col_index) result(differences) Calculate differences between consecutive rows (result has n-1 elements) Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value integer(kind=ik), dimension(:), allocatable public  function df_diff_real (df, col_index) result(differences) Calculate differences between consecutive rows (result has n-1 elements) Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk), dimension(:), allocatable Subroutines public  subroutine df_abs_column_integer (df, col_index) Take absolute value of all elements in an integer column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index public  subroutine df_abs_column_real (df, col_index) Take absolute value of all elements in a real column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index public  subroutine df_apply_to_column (df, col_index, func) Apply custom function to column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index procedure( transform_func ) :: func public  subroutine df_clip_integer (df, col_index, min_val, max_val) Clip (clamp) values in an integer column to [min_val, max_val] Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index integer(kind=ik), intent(in) :: min_val integer(kind=ik), intent(in) :: max_val public  subroutine df_clip_real (df, col_index, min_val, max_val) Clip (clamp) values in a real column to [min_val, max_val] Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: min_val real(kind=rk), intent(in) :: max_val public  subroutine df_cumsum_integer (df, col_index) Calculate cumulative sum for an integer column (modifies in place) Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index public  subroutine df_cumsum_real (df, col_index) Calculate cumulative sum for a real column (modifies in place) Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index public  subroutine df_exp_column (df, col_index) Apply exponential to column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index public  subroutine df_log_column (df, col_index) Apply natural logarithm to column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index public  subroutine df_normalize_column_real (df, col_index) Normalize a real column to [0, 1] range Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index public  subroutine df_pow_column (df, col_index, power) Raise column to a power Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: power public  subroutine df_replace_value_integer (df, col_index, old_value, new_value) Replace all occurrences of a value in an integer column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index integer(kind=ik), intent(in) :: old_value integer(kind=ik), intent(in) :: new_value public  subroutine df_replace_value_real (df, col_index, old_value, new_value) Replace all occurrences of a value in a real column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: old_value real(kind=rk), intent(in) :: new_value public  subroutine df_round_column (df, col_index, decimals) Round real column to specified number of decimal places Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index integer, intent(in) :: decimals public  subroutine df_sqrt_column (df, col_index) Apply square root to column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index public  subroutine df_standardize_column_real (df, col_index) Standardize a real column (z-score: mean=0, std=1) Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index","tags":"","url":"module/datafort_transformations.html"},{"title":"datafort_utilities – DataFort","text":"DataFort Utilities Module This module provides utility procedures for data frame operations including:\n- Data inspection: head, tail, shape, info, empty\n- Data manipulation: clear, sample, shuffle\n- Row operations: apply_to_row_real, apply_to_all_rows_real All procedures are standalone functions prefixed with df_ . Uses datafort_types column_class types precision datafort_accessors Abstract Interfaces abstract interface public  function row_func_real(row_values, num_cols) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: row_values integer, intent(in) :: num_cols Return Value real(kind=rk) Functions public  function df_apply_to_all_rows_real (df, func) result(outputs) Apply a function to all rows Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df procedure( row_func_real ) :: func Return Value real(kind=rk), dimension(:), allocatable public  function df_apply_to_row_real (df, row_idx, func) result(output) Apply a function to a specific row Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: row_idx procedure( row_func_real ) :: func Return Value real(kind=rk) public pure function df_empty (df) result(is_empty) Check if dataframe is empty (no rows or no columns) Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value logical public  function df_head (df, n) result(head_df) Return first n rows as a new dataframe Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in), optional :: n Return Value type( data_frame ) public  function df_sample (df, n, seed) result(sampled_df) Get n random rows from the dataframe Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: n integer, intent(in), optional :: seed Return Value type( data_frame ) public  function df_shape (df) result(dims) Return shape as [nrows, ncols] Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value integer, dimension(2) private  function df_slice_rows (df, start_row, end_row) result(new_df) Internal: Slice rows to create a new data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: start_row integer, intent(in) :: end_row Return Value type( data_frame ) public  function df_tail (df, n) result(tail_df) Return last n rows as a new dataframe Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in), optional :: n Return Value type( data_frame ) Subroutines private  subroutine copy_filtered_column (source_df, target_df, col_index, selected_rows) Internal: Copy filtered column from source to target Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: source_df type( data_frame ), intent(inout) :: target_df integer, intent(in) :: col_index integer, intent(in), dimension(:) :: selected_rows public  subroutine df_clear (df) Clear the dataframe (destroy and re-initialize) Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df public  subroutine df_info (df, unit) Print information about the dataframe Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in), optional :: unit public  subroutine df_shuffle (df, seed) Shuffle all rows randomly in place Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in), optional :: seed private  subroutine reorder_all_columns (df, indices) Internal: Reorder all columns according to index array Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in), dimension(:) :: indices","tags":"","url":"module/datafort_utilities.html"},{"title":"datafort_nan – DataFort","text":"DataFort NaN Handling Module This module provides standalone NaN handling functions for data frames.\nAll functions take a data_frame as the first argument instead of being type-bound procedures. Functions NaN Detection Functions df_isna_real(df, col_index) - Check for NaN values in real column df_isna_integer(df, col_index) - Check for NaN values in integer column NaN Replacement Functions df_fillna_real(df, col_index, fill_value) - Replace NaN with fill value (real) df_fillna_integer(df, col_index, fill_value) - Replace NaN with fill value (integer) Row Removal Functions df_dropna(df) - Remove rows containing NaN values Notes For real columns, NaN is detected using IEEE floating-point NaN For integer columns, NaN is represented by a sentinel value (huge(1_ik)) df_dropna returns a new data frame with NaN-containing rows removed df_fillna_* subroutines modify the data frame in-place Uses datafort_types column_class types precision datafort_accessors Functions public  function df_dropna (df) result(clean_df) Remove rows containing NaN values Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value type( data_frame ) public  function df_isna_integer (df, col_index) result(mask) Check for NaN values in an integer column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value logical, dimension(:), allocatable public  function df_isna_real (df, col_index) result(mask) Check for NaN values in a real column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value logical, dimension(:), allocatable Subroutines public  subroutine df_fillna_integer (df, col_index, fill_value) Replace NaN values in an integer column with a fill value Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index integer(kind=ik), intent(in) :: fill_value public  subroutine df_fillna_real (df, col_index, fill_value) Replace NaN values in a real column with a fill value Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: fill_value","tags":"","url":"module/datafort_nan.html"},{"title":"datafort_manipulation – DataFort","text":"DataFort Manipulation Module This module provides standalone functions for data frame manipulation operations.\nAll functions take a data_frame as the first argument instead of being type-bound procedures. Functions Selection and Slicing df_select_columns(df, column_indices) - Extract subset of columns df_slice_rows(df, start_row, end_row) - Extract row range Filtering df_filter_rows_logical(df, logical_col_index) - Filter rows by logical column df_filter_rows_real_range(df, col_index, min_val, max_val) - Filter rows by real value range df_filter_rows_integer_range(df, col_index, min_val, max_val) - Filter rows by integer value range df_filter_rows_string_pattern(df, col_index, pattern) - Filter rows by string pattern Copy and Transform df_copy(df) - Create a deep copy of the data frame df_transpose(df) - Transpose the data frame (converts to character) Column Manipulation df_rename_column(df, col_index, new_name) - Rename a column df_drop_column(df, col_index) - Remove a column df_reorder_columns(df, new_order) - Reorder columns Uses datafort_types column_class types precision datafort_accessors Functions public  function df_copy (df) result(new_df) Create a deep copy of a data frame Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value type( data_frame ) public  function df_filter_rows_integer_range (df, col_index, min_val, max_val) result(filtered_df) Filter rows by integer value range Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index integer(kind=ik), intent(in) :: min_val integer(kind=ik), intent(in) :: max_val Return Value type( data_frame ) public  function df_filter_rows_logical (df, logical_col_index) result(new_df) Filter rows based on a logical column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: logical_col_index Return Value type( data_frame ) public  function df_filter_rows_real_range (df, col_index, min_val, max_val) result(filtered_df) Filter rows by real value range Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index real(kind=rk), intent(in) :: min_val real(kind=rk), intent(in) :: max_val Return Value type( data_frame ) public  function df_filter_rows_string_pattern (df, col_index, pattern) result(filtered_df) Filter rows by string pattern Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index character(len=*), intent(in) :: pattern Return Value type( data_frame ) public  function df_select_columns (df, column_indices) result(new_df) Select specific columns from a data frame Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in), dimension(:) :: column_indices Return Value type( data_frame ) public  function df_slice_rows (df, start_row, end_row) result(new_df) Slice rows to create a new data frame Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: start_row integer, intent(in) :: end_row Return Value type( data_frame ) public  function df_transpose (df) result(transposed_df) Transpose a data frame Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value type( data_frame ) Subroutines private  subroutine copy_filtered_column (source_df, target_df, col_index, selected_rows) Helper subroutine to copy filtered rows for a single column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: source_df type( data_frame ), intent(inout) :: target_df integer, intent(in) :: col_index integer, intent(in), dimension(:) :: selected_rows public  subroutine df_drop_column (df, col_index) Drop a column from the data frame Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index public  subroutine df_rename_column (df, col_index, new_name) Rename a column in the data frame Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index character(len=*), intent(in) :: new_name public  subroutine df_reorder_columns (df, new_order) Reorder columns in the data frame Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in), dimension(:) :: new_order","tags":"","url":"module/datafort_manipulation.html"},{"title":"datafort_accessors – DataFort","text":"DataFort Accessors Module This module provides standalone functions for accessing and modifying data frame columns and values.\nAll functions take a data_frame as the first argument instead of being type-bound procedures. Functions Column Append Functions df_append_real/integer/logical/character/complex(df, col, header) - Add column Get Column Functions df_get_col_real/integer/logical/character/complex(df, col_index) - Get entire column Get Value Functions df_get_val_real/integer/logical/character/complex(df, row, col) - Get single value Set Column Functions df_set_col_real/integer/logical/character/complex(df, col_index, col) - Set entire column Set Value Functions df_set_val_real/integer/logical/character/complex(df, row, col, val) - Set single value Uses types datafort_types column_class precision Functions public  function df_get_col_character (df, index) result(col) Get character column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: index Return Value character(len=:), dimension(:), allocatable public  function df_get_col_complex (df, index) result(col) Get complex column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: index Return Value complex(kind=rk), dimension(:), allocatable public  function df_get_col_integer (df, index) result(col) Get integer column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: index Return Value integer(kind=ik), dimension(:), allocatable public  function df_get_col_logical (df, index) result(col) Get logical column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: index Return Value logical, dimension(:), allocatable public  function df_get_col_real (df, index) result(col) Get real column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: index Return Value real(kind=rk), dimension(:), allocatable public  function df_get_val_character (df, row_index, col_index) result(val) Get single character value from data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index Return Value character(len=:), allocatable public  function df_get_val_complex (df, row_index, col_index) result(val) Get single complex value from data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index Return Value complex(kind=rk) public  function df_get_val_integer (df, row_index, col_index) result(val) Get single integer value from data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index Return Value integer(kind=ik) public  function df_get_val_logical (df, row_index, col_index) result(val) Get single logical value from data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index Return Value logical public  function df_get_val_real (df, row_index, col_index) result(val) Get single real value from data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index Return Value real(kind=rk) Subroutines public  subroutine df_append_character (df, col, header) Append a character-valued column to the data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df character(len=*), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header public  subroutine df_append_complex (df, col, header) Append a complex-valued column to the data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df complex(kind=rk), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header public  subroutine df_append_integer (df, col, header) Append an integer-valued column to the data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer(kind=ik), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header public  subroutine df_append_logical (df, col, header) Append a logical-valued column to the data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df logical, intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header public  subroutine df_append_real (df, col, header) Append a real-valued column to the data frame Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df real(kind=rk), intent(in), dimension(:) :: col character(len=*), intent(in), optional :: header public  subroutine df_set_col_character (df, col_index, col) Set entire character column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index character(len=*), intent(in), dimension(:) :: col public  subroutine df_set_col_complex (df, col_index, col) Set entire complex column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index complex(kind=rk), intent(in), dimension(:) :: col public  subroutine df_set_col_integer (df, col_index, col) Set entire integer column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index integer(kind=ik), intent(in), dimension(:) :: col public  subroutine df_set_col_logical (df, col_index, col) Set entire logical column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index logical, intent(in), dimension(:) :: col public  subroutine df_set_col_real (df, col_index, col) Set entire real column by index Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index real(kind=rk), intent(in), dimension(:) :: col public  subroutine df_set_val_character (df, row_index, col_index, val) Set single character value in data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index character(len=*), intent(in) :: val public  subroutine df_set_val_complex (df, row_index, col_index, val) Set single complex value in data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index complex(kind=rk), intent(in) :: val public  subroutine df_set_val_integer (df, row_index, col_index, val) Set single integer value in data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index integer(kind=ik), intent(in) :: val public  subroutine df_set_val_logical (df, row_index, col_index, val) Set single logical value in data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index logical, intent(in) :: val public  subroutine df_set_val_real (df, row_index, col_index, val) Set single real value in data frame Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: row_index integer, intent(in) :: col_index real(kind=rk), intent(in) :: val","tags":"","url":"module/datafort_accessors.html"},{"title":"precision – DataFort","text":"Precision and NaN handling module Defines precision parameters and NaN (Not-a-Number) constants for the library Uses ieee_arithmetic iso_fortran_env Variables Type Visibility Attributes Name Initial integer(kind=ik), public, parameter :: NaN_ik = -huge(0_ik)-1_ik real(kind=rk), public :: NaN_rk integer, public, parameter :: ik = i32 logical, public, save :: nan_initialized = .false. integer, public, parameter :: rk = r64 Functions public elemental function is_nan_integer (x) result(is_nan) Check if an integer value is NaN (sentinel) Read more… Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: x Return Value logical public elemental function is_nan_real (x) result(is_nan) Check if a real value is NaN Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical Subroutines public  subroutine init_nan () Initialize the NaN_rk constant Read more… Arguments None","tags":"","url":"module/precision.html"},{"title":"datafort_sorting – DataFort","text":"DataFort Sorting Module This module provides standalone functions for sorting and ranking operations on data frames.\nAll functions take a data_frame as the first argument instead of being type-bound procedures. Functions Sorting Functions df_sort_by_column(df, col_index, ascending) - Sort data frame by column values Sorting Check Functions df_is_sorted_real(df, col_index, ascending) - Check if real column is sorted df_is_sorted_integer(df, col_index, ascending) - Check if integer column is sorted Ranking Functions df_rank_real(df, col_index, ascending) - Get ranks for real column values df_rank_integer(df, col_index, ascending) - Get ranks for integer column values Uses datafort_types utilities column_class types precision Functions public  function df_is_sorted_integer (df, col_index, ascending) result(sorted) Check if an integer column is sorted Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value logical public  function df_is_sorted_real (df, col_index, ascending) result(sorted) Check if a real column is sorted Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value logical public  function df_rank_integer (df, col_index, ascending) result(ranks) Rank values in an integer column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value integer(kind=ik), dimension(:), allocatable public  function df_rank_real (df, col_index, ascending) result(ranks) Rank values in a real column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index logical, intent(in), optional :: ascending Return Value integer(kind=ik), dimension(:), allocatable private  function partition_indices_integer (values, indices, low, high, ascending) result(pivot_idx) Partition function for integer value quicksort Read more… Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending Return Value integer private  function partition_indices_real (values, indices, low, high, ascending) result(pivot_idx) Partition function for real value quicksort Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending Return Value integer Subroutines public  subroutine df_sort_by_column (df, col_index, ascending) Sort data frame by column values Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in) :: col_index logical, intent(in), optional :: ascending private recursive subroutine quicksort_indices_integer (values, indices, low, high, ascending) Quicksort implementation for integer value indices Read more… Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending private recursive subroutine quicksort_indices_real (values, indices, low, high, ascending) Quicksort implementation for real value indices Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices integer, intent(in) :: low integer, intent(in) :: high logical, intent(in) :: ascending private  subroutine reorder_all_columns (df, indices) Reorder all columns based on index array Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(inout) :: df integer, intent(in), dimension(:) :: indices private  subroutine sort_indices_integer (values, indices, ascending) Sort indices array based on integer values Read more… Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices logical, intent(in) :: ascending private  subroutine sort_indices_real (values, indices, ascending) Sort indices array based on real values Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: values integer, intent(inout), dimension(:) :: indices logical, intent(in) :: ascending","tags":"","url":"module/datafort_sorting.html"},{"title":"datafort – DataFort","text":"DataFort - Modern Data Frame Library for Fortran This module provides a comprehensive data frame implementation for Fortran,\noffering pandas-like functionality for scientific computing and data analysis. Features Mixed-type columns : real, integer, logical, character, complex Statistical operations : mean, std, median, percentile, variance, correlation Data manipulation : filter, sort, slice, transpose, join Mathematical functions : cumsum, diff, normalize, log, exp, sqrt I/O operations : CSV import/export, console display Convenience methods : head, tail, info, describe, sample, shuffle Example Usage use datafort use precision type ( data_frame ) :: df real ( rk ) :: temps ( 3 ) = [ 2 0.0_rk , 2 5.0_rk , 2 2.0_rk ] call df % new () call df % append ( temps , \"Temperature\" ) call df % write_console () print * , \"Mean:\" , df % mean_real ( 1 ) call df % destroy () Module Organization This module serves as the main entry point and re-exports all functionality\nfrom specialized submodules: datafort_types - Core data_frame type definition datafort_accessors - Append, get, and set operations datafort_statistics - Statistical operations datafort_transformations - Mathematical transformations datafort_manipulation - Data selection and manipulation datafort_sorting - Sorting and ranking operations datafort_io - Input/output operations datafort_utilities - Convenience functions datafort_joins - Join operations datafort_nan - NaN handling datafort_advanced - Advanced data operations Uses datafort_nan datafort_types datafort_statistics column_class datafort_advanced datafort_joins datafort_manipulation datafort_sorting datafort_transformations datafort_utilities datafort_io types precision datafort_accessors","tags":"","url":"module/datafort.html"},{"title":"datafort_advanced – DataFort","text":"DataFort Advanced Operations Module This module provides standalone advanced data operations for data frames.\nAll functions take a data_frame as the first argument instead of being type-bound procedures. Functions Unique Value Functions df_unique_real(df, col_index) - Get unique values from real column df_unique_integer(df, col_index) - Get unique values from integer column df_unique_character(df, col_index) - Get unique values from character column Value Counting Functions df_value_counts_real(df, col_index) - Count occurrences of each value (real) df_value_counts_integer(df, col_index) - Count occurrences of each value (integer) df_value_counts_character(df, col_index) - Count occurrences of each value (character) Concatenation Functions df_concat(df1, df2, axis) - Concatenate two data frames (axis=0: vertical, axis=1: horizontal) Duplicate Detection and Removal Functions df_duplicated(df) - Check which rows are duplicates df_drop_duplicates(df) - Remove duplicate rows df_drop_duplicates_subset(df, col_indices) - Remove duplicates based on specific columns Notes Unique functions return sorted unique values (except character which is unsorted) Value counts return a data frame with “Value” and “Count” columns Concat with axis=0 requires same number of columns; axis=1 requires same number of rows Duplicate detection compares all data types including NaN values Uses datafort_types utilities column_class ieee_arithmetic datafort_manipulation types precision datafort_accessors Functions public  function df_concat (df1, df2, axis) result(result_df) Concatenate two data frames vertically (rows) or horizontally (columns) Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df1 type( data_frame ), intent(in) :: df2 integer, intent(in) :: axis Return Value type( data_frame ) public  function df_drop_duplicates (df) result(unique_df) Remove duplicate rows Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value type( data_frame ) public  function df_drop_duplicates_subset (df, col_indices) result(unique_df) Drop duplicate rows based on specific columns (subset) Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_indices (:) Return Value type( data_frame ) public  function df_duplicated (df) result(is_dup) Check which rows are duplicates Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df Return Value logical, dimension(:), allocatable public  function df_unique_character (df, col_index) result(unique_vals) Get unique values from a character column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value character(len=:), allocatable, (:) public  function df_unique_integer (df, col_index) result(unique_vals) Get unique values from an integer column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value integer(kind=ik), dimension(:), allocatable public  function df_unique_real (df, col_index) result(unique_vals) Get unique values from a real column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value real(kind=rk), dimension(:), allocatable public  function df_value_counts_character (df, col_index) result(counts_df) Count occurrences of each value in a character column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value type( data_frame ) public  function df_value_counts_integer (df, col_index) result(counts_df) Count occurrences of each value in an integer column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value type( data_frame ) public  function df_value_counts_real (df, col_index) result(counts_df) Count occurrences of each value in a real column Read more… Arguments Type Intent Optional Attributes Name type( data_frame ), intent(in) :: df integer, intent(in) :: col_index Return Value type( data_frame )","tags":"","url":"module/datafort_advanced.html"},{"title":"utilities – DataFort","text":"Uses types column_class precision Functions private  function partition_integer (arr, low, high) result(pivot_index) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high Return Value integer private  function partition_real (arr, low, high) result(pivot_index) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high Return Value integer Subroutines public recursive subroutine quick_sort_integer (arr, low, high) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high public recursive subroutine quick_sort_real (arr, low, high) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: arr (:) integer, intent(in) :: low integer, intent(in) :: high","tags":"","url":"module/utilities.html"},{"title":"Documentation – DataFort","text":"DataFort Guide Reading and Writing Data Load CSV with Headers type ( data_frame ) :: df call df_read_csv ( df , \"data.csv\" , . true .) ! .true. = has headers call df_write_console ( df ) Write to CSV call df_write_csv ( df , \"output.csv\" ) Data Exploration Display First/Last Rows type ( data_frame ) :: head_df , tail_df head_df = df_head ( df , 5 ) ! First 5 rows tail_df = df_tail ( df , 10 ) ! Last 10 rows call df_write_console ( head_df ) Get DataFrame Info call df_info ( df ) ! Print structure and types call df_describe_numeric ( df ) ! Statistical summary print * , \"Shape:\" , df_shape ( df ) print * , \"Rows:\" , df % nrows () print * , \"Cols:\" , df % ncols () Access Individual Elements Get a Single Value real ( rk ) :: value_r integer ( ik ) :: value_i character ( len = :), allocatable :: value_c logical :: value_l ! Get value at row i, column j (by index) call df_get_val_real ( df , i , j , value_r ) ! For real columns call df_get_val_integer ( df , i , j , value_i ) ! For integer columns call df_get_val_character ( df , i , j , value_c ) ! For character columns call df_get_val_logical ( df , i , j , value_l ) ! For logical columns ! Example: Get value at row 5, column 2 call df_get_val_real ( df , 5 , 2 , value_r ) print * , \"Value at [5,2]:\" , value_r Get Value by Column Name character ( len = :), allocatable :: col_name real ( rk ) :: temperature integer :: row_idx , col_idx row_idx = 10 col_name = \"Temperature\" ! First find column index col_idx = df % find_header_index ( col_name ) ! Then get the value call df_get_val_real ( df , row_idx , col_idx , temperature ) print * , \"Temperature at row\" , row_idx , \":\" , temperature Set a Single Value ! Set value at row i, column j call df_set_val_real ( df , i , j , 4 2.5_rk ) ! For real columns call df_set_val_integer ( df , i , j , 100_ik ) ! For integer columns call df_set_val_character ( df , i , j , \"NewVal\" ) ! For character columns call df_set_val_logical ( df , i , j , . true .) ! For logical columns ! Example: Set value at row 3, column 1 call df_set_val_real ( df , 3 , 1 , 9 9.9_rk ) Access by Header Name character ( len = :), allocatable :: header integer :: col_index ! Get column index from header name header = \"Age\" col_index = df % find_header_index ( header ) if ( col_index > 0 ) then ! Use the column index to access data call df_get_val_integer ( df , 5 , col_index , value_i ) print * , \"Age at row 5:\" , value_i else print * , \"Column not found\" end if Data Selection and Filtering Select Columns type ( data_frame ) :: subset integer , dimension ( 3 ) :: cols = [ 1 , 3 , 5 ] subset = df_select_columns ( df , cols ) Slice Rows type ( data_frame ) :: sliced sliced = df_slice_rows ( df , 10 , 20 ) ! Rows 10 to 20 Filter by Condition type ( data_frame ) :: filtered logical , dimension (:), allocatable :: mask ! Filter numeric range filtered = df_filter_rows_real_range ( df , 1 , 2 0.0_rk , 3 0.0_rk ) ! Filter by string pattern filtered = df_filter_rows_string_pattern ( df , 2 , \"Alice\" ) ! Custom logical mask allocate ( mask ( df % nrows ())) mask = temperatures > 2 5.0_rk filtered = df_filter_rows_logical ( df , mask ) Statistics and Aggregation Basic Statistics real ( rk ) :: avg , std_dev , var integer ( ik ) :: total ! Column 1 statistics avg = df_mean_real ( df , 1 ) std_dev = df_std_real ( df , 1 ) var = df_variance_real ( df , 1 ) total = df_sum_integer ( df , 2 ) print * , \"Mean:\" , avg print * , \"Std Dev:\" , std_dev Percentiles and Quantiles real ( rk ) :: median , q25 , q75 median = df_median_real ( df , 1 ) q25 = df_percentile_real ( df , 1 , 2 5.0_rk ) q75 = df_percentile_real ( df , 1 , 7 5.0_rk ) print * , \"Median:\" , median print * , \"IQR:\" , q75 - q25 Correlation real ( rk ) :: corr corr = df_correlation_real ( df , 1 , 2 ) ! Between columns 1 and 2 print * , \"Correlation:\" , corr Data Transformation Normalize Data call df_normalize_column_real ( df , 1 ) ! Scale to [0, 1] Standardize Data call df_standardize_column_real ( df , 1 ) ! z-score normalization Mathematical Operations ! Apply functions to entire columns call df_abs_column_real ( df , 1 ) call df_log_column ( df , 1 ) call df_exp_column ( df , 1 ) call df_sqrt_column ( df , 1 ) call df_pow_column ( df , 1 , 2.0_rk ) ! Raise to power call df_round_column ( df , 1 , 2 ) ! Round to 2 decimals Cumulative and Differencing real ( rk ), dimension (:), allocatable :: cumulative , differences cumulative = df_cumsum_real ( df , 1 ) differences = df_diff_real ( df , 1 ) Sorting and Ranking Sort by Column call df_sort_by_column ( df , 1 , ascending = . true .) Get Ranks real ( rk ), dimension (:), allocatable :: ranks ranks = df_rank_real ( df , 1 ) Check if Sorted logical :: sorted sorted = df_is_sorted_real ( df , 1 ) Missing Data (NaN) Handling Check for Missing Values logical , dimension (:), allocatable :: na_mask na_mask = df_isna_real ( df , 1 ) ! Count missing values print * , \"Missing values:\" , count ( na_mask ) Fill Missing Values call df_fillna_real ( df , 1 , 0.0_rk ) ! Fill with 0 Drop Missing Values type ( data_frame ) :: cleaned cleaned = df_dropna ( df ) Column Operations Add Column real ( rk ), dimension ( 100 ) :: new_data call df_append_real ( df , new_data , \"NewColumn\" ) Drop Column call df_drop_column ( df , 3 ) ! Drop column 3 Rename Column call df_rename_column ( df , 1 , \"Temperature_C\" ) Reorder Columns integer , dimension ( 4 ) :: new_order = [ 3 , 1 , 4 , 2 ] call df_reorder_columns ( df , new_order ) Get Column Type integer :: col_type col_type = df % get_col_type ( 1 ) ! Returns: 1=Real, 2=Integer, 3=Logical, 4=Character, 5=Complex Joining and Merging Inner Join type ( data_frame ) :: df1 , df2 , result result = df_inner_join ( df1 , df2 , 1 , 1 ) ! Join on column 1 of both Left Join result = df_left_join ( df1 , df2 , 1 , 1 ) Right Join result = df_right_join ( df1 , df2 , 1 , 1 ) Outer Join result = df_outer_join ( df1 , df2 , 1 , 1 ) Concatenate DataFrames type ( data_frame ) :: combined integer :: axis axis = 0 ! 0 = vertical stacking, 1 = horizontal stacking combined = df_concat ( df1 , df2 , axis ) Duplicates Find Duplicates logical , dimension (:), allocatable :: is_dup is_dup = df_duplicated ( df ) ! Check for duplicate rows Drop Duplicates type ( data_frame ) :: unique_df unique_df = df_drop_duplicates ( df ) ! Remove duplicate rows Get Unique Values real ( rk ), dimension (:), allocatable :: unique_vals unique_vals = df_unique_real ( df , 1 ) Value Counts type ( data_frame ) :: counts counts = df_value_counts_real ( df , 1 ) call df_write_console ( counts ) Row Operations Apply Function to Row ! Define a function that operates on a row function row_sum ( row_values , num_cols ) result ( output ) use precision real ( rk ), dimension (:), intent ( in ) :: row_values integer , intent ( in ) :: num_cols real ( rk ) :: output output = sum ( row_values ) end function row_sum ! Apply to a single row real ( rk ) :: result result = df_apply_to_row_real ( df , 5 , row_sum ) ! Apply to row 5 Apply Function to All Rows real ( rk ), dimension (:), allocatable :: results results = df_apply_to_all_rows_real ( df , row_sum ) ! Apply to all rows Other Operations Transpose type ( data_frame ) :: transposed transposed = df_transpose ( df ) Sample Rows type ( data_frame ) :: sample_df sample_df = df_sample ( df , 10 ) ! Random 10 rows Shuffle call df_shuffle ( df ) ! Randomize row order Copy type ( data_frame ) :: df_copy df_copy = df_copy ( df ) Clear call df_clear ( df ) ! Empty the dataframe Complete Example program datafort_example use datafort use precision implicit none type ( data_frame ) :: df , filtered , stats real ( rk ), dimension ( 5 ) :: temps = [ 2 3.1_rk , 2 5.3_rk , 2 4.8_rk , 2 2.5_rk , 2 6.0_rk ] integer ( ik ), dimension ( 5 ) :: ids = [ 1_ik , 2_ik , 3_ik , 4_ik , 5_ik ] ! Create dataframe call df % new () call df_append_integer ( df , ids , \"ID\" ) call df_append_real ( df , temps , \"Temperature\" ) ! Basic info call df_info ( df ) call df_describe_numeric ( df ) ! Statistics print * , \"Mean temp:\" , df_mean_real ( df , 2 ) print * , \"Max temp:\" , df_max_real ( df , 2 ) ! Filter filtered = df_filter_rows_real_range ( df , 2 , 2 4.0_rk , 2 6.0_rk ) call df_write_console ( filtered ) ! Transform call df_normalize_column_real ( df , 2 ) ! Export call df_write_csv ( df , \"output.csv\" ) ! Cleanup call df % destroy () call filtered % destroy () end program datafort_example","tags":"","url":"page/index.html"}]}